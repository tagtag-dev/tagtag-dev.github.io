# 项目介绍

Tagtag Starter 是一个基于 Java 和 Spring Boot 3 构建的通用、模块化后台管理框架。它旨在为构建商业应用提供一个轻量、坚实的基础，帮助开发者快速搭建高质量的后台管理系统。

![Tagtag Starter - Analytics](https://tagtag.dev/images/docs/1.getting-started/analytics.png)

Tagtag Starter 的定位非常明确：**做最适合新项目的起步脚手架**。我们不追求大而全的复杂功能，而是专注于提供一个**功能简洁、上手简单**的开发底座，让开发者能够专注于业务逻辑的实现，而不是和配置文件斗智斗勇。

## 核心特性

- **模块化架构**：系统被拆分为多个功能明确的模块（`common`、`framework`、`kernel`、`contract`、`module` 等），结构清晰，易于维护和扩展。就像乐高积木一样，想怎么搭就怎么搭。
- **契约优先设计**：使用 `contract` 模块将 API 定义与实现分离，代码结构更规范，便于前后端协作和接口管理。前后端再也不用因为接口定义吵架了。
- **完备的权限体系**：内置基于 RBAC（基于角色的访问控制）的权限管理系统，支持菜单权限、按钮权限和数据权限。谁该看什么、能做什么，一清二楚。
- **丰富的核心功能**：内置操作日志、接口限流、字典管理、文件存储等核心功能，满足大多数后台系统的需求。开箱即用，不用自己造轮子。
- **现代技术栈**：后端基于 Spring Boot 3、MyBatis Plus 和 Redis 构建，前端基于 Vue 3 + TypeScript + Vite 构建，采用 Vben Admin 5 框架。用最新的技术，写最优雅的代码。
- **灵活的扩展机制**：模块化设计使得新增业务功能只需创建一个新的 Maven 模块，不会污染现有核心代码。想加什么功能就加什么，不用担心把核心搞坏了。

## 为什么选择 Tagtag Starter？

在众多的后台管理框架中，Tagtag 具有以下独特优势：

### 1. 极致简洁，快速上手

- **拒绝过度设计**：没有复杂的微服务架构负担，没有难以理解的抽象层。Tagtag 保持了代码的纯净与直观，您可以在几分钟内跑通项目，而不是花几天时间研究配置。毕竟，我们的目标是写业务代码，不是研究框架源码。
- **新项目的最佳选择**：当您需要开启一个新的后台项目时，Tagtag 提供了最纯粹的起点。它没有预装成吨的冗余代码，让您能够轻装上阵，专注于业务逻辑的实现。就像买新车一样，不需要先拆掉一堆用不上的配件。
- **清晰的文档**：提供完整、清晰的文档，帮助开发者快速上手和深入理解框架。我们相信，好的文档比好的代码更重要（当然，我们的代码也不错）。

### 2. 恰到好处的功能集

- **只给您最需要的**：我们仅内置了几乎所有后台系统都必须的基础功能——用户管理、角色权限、菜单配置、操作日志、接口限流、字典管理和文件存储。不多不少，刚刚好。
- **无复杂集成**：没有预装一大堆可能永远用不上的中间件和第三方库。保持代码库的轻盈，意味着更少的维护成本和更低的各种依赖冲突风险。毕竟，谁也不想因为一个不常用的依赖把整个项目搞崩。
- **可按需扩展**：您可以根据项目需求，轻松扩展新的功能模块。就像点外卖一样，想吃啥就加啥，不用强制消费。

### 3. 清晰的代码结构

- **易于理解与扩展**：基于标准的 Spring Boot 结构，结合模块化设计，使得代码逻辑一目了然。即使是新手开发者也能快速看懂并上手开发，方便团队在此基础上进行二次定制。不用像读天书一样研究代码。
- **规范的开发模式**：内置了统一的响应封装、异常处理和日志规范，为团队协作建立了一套标准化的开发模版。团队成员再也不用因为代码风格问题争论不休了。
- **优秀的代码质量**：遵循严格的代码规范，代码结构清晰，注释完善，便于维护和扩展。我们相信，好的代码是会说话的。

### 4. 拥抱现代技术栈

- **后端技术栈**：基于 Spring Boot 3 + JDK 17 构建，集成 MyBatis Plus、Redis、Spring Security、JWT 等主流技术。用最新的技术，写最稳的代码。
- **前端技术栈**：基于 Vue 3 + TypeScript + Vite 构建，采用 Vben Admin 5 框架，使用 Tailwind CSS 和 Shadcn UI 进行界面开发。界面美观，交互流畅，用户体验一级棒。
- **持续更新**：我们会持续关注和采用最新的技术栈，确保框架始终保持现代化。毕竟，技术发展这么快，我们可不能掉队。

### 5. 灵活的模块化扩展

- **按需扩展**：得益于清晰的模块划分，新增业务功能只需创建一个新的 Maven 模块，不会污染现有核心代码。就像搭积木一样，想加什么功能就加什么。
- **即插即用**：各模块职责分明，耦合度低。无论是集成新的第三方服务，还是拆分现有业务逻辑，模块化的设计都能让扩展变得轻松自如。不用牵一发而动全身。
- **松耦合设计**：模块之间通过契约层进行通信，降低了模块间的依赖关系，提高了系统的灵活性和可维护性。改一个模块，不用担心把其他模块搞坏。

## 使用场景

Tagtag 适合以下类型的项目：

- **企业内部管理系统**：如 CRM、ERP、OA 等企业内部管理系统。让企业运营更高效，让员工工作更轻松。
- **SaaS 平台**：适合构建多租户 SaaS 平台的后台管理系统。一套系统，服务多个客户，省钱又省心。
- **电商后台**：适合构建电商平台的后台管理系统。商品管理、订单处理、数据分析，一应俱全。
- **内容管理系统**：适合构建各种内容管理系统。文章、图片、视频，想管理什么就管理什么。
- **API 管理平台**：适合构建 API 管理和监控平台。接口文档、接口测试、接口监控，一站式搞定。
- **其他后台管理系统**：适合构建各种类型的后台管理系统。只要是后台管理系统，Tagtag 都能胜任。

Tagtag 不适合以下类型的项目：

- **高并发、高流量的互联网应用**：如社交网络、直播平台等。这种级别的项目，还是用专业的分布式架构吧。
- **复杂的微服务架构项目**：如果您的项目需要复杂的微服务架构，Tagtag 可能不是最佳选择。我们专注于单体应用，简单才是美。
- **需要大量定制化 UI 的项目**：如果您需要高度定制化的 UI 设计，可能需要对前端代码进行大量修改。不过，我们的 UI 已经很漂亮了，您可能根本不需要定制。

## 快速开始

想要快速上手 Tagtag Starter？请查看我们的 [快速开始指南](https://tagtag.dev/getting-started/quick-start)，您可以在几分钟内跑通整个项目。相信我，比煮一碗泡面还快。

## 架构设计

Tagtag 采用前后端分离的架构设计，后端基于 Java 和 Spring Boot 3 构建，前端基于 Vue 3 + TypeScript + Vite 构建。想要了解更多关于 Tagtag 的架构设计，请查看我们的 [架构文档](https://tagtag.dev/architecture/overview)。我们的架构设计就像搭积木一样清晰，保证你看完就能懂。

## 社区与贡献

Tagtag 是一个开源项目，我们欢迎社区的贡献和反馈。如果您有任何问题或建议，欢迎在 GitHub 上提交 Issue 或 Pull Request。我们承诺，每一个 Issue 都会认真对待，每一个 PR 都会仔细 review。

- **GitHub 仓库**：<https://github.com/tagtag-dev/tagtag-starter>{rel="nofollow"}
- **文档地址**：<https://tagtag.dev>{rel="nofollow"}

---

感谢您对 Tagtag Starter 的关注和支持！我们相信，Tagtag Starter 会成为您构建后台管理系统的得力助手。选择 Tagtag Starter，就是选择简单、高效、优雅的开发体验。让我们一起，用最少的代码，实现最大的价值。


# 快速上手

本指南将帮助您在本地机器上搭建 Tagtag Starter 的后端服务和前端应用。别担心，我们会一步一步带您完成整个过程，就像教小朋友走路一样简单。

## 环境要求

确保您已安装以下软件。如果没有，赶紧去安装吧，别磨蹭了。

### 后端

- **Java JDK 17+** - 没错，我们用的是最新的 Java，跟上时代潮流
- **Maven 3.8+** - 依赖管理的好帮手，不用自己手动下载 jar 包了
- **MySQL 8.0+** - 数据存储的基石，数据都靠它
- **Redis 6.0+** - 缓存加速的神器，让系统飞起来

### 前端

- **Node.js >= 20.12.0** - 前端运行的基础环境
- **pnpm >= 10.0.0** - 比 npm 更快的包管理器，用过都说好

## 安装步骤

### 1. 克隆仓库

```bash
git clone https://github.com/tagtag-dev/tagtag-starter.git
cd tagtag-starter
```

这一步应该不会出问题吧？如果出问题了，检查一下您的网络连接，或者换个姿势试试。

### 2. 初始化数据库 (后端)

1. **创建数据库**：在 MySQL 中创建一个名为 `tagtag` 的数据库。

```sql
CREATE DATABASE tagtag CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

记住，数据库名字必须是 `tagtag`，别自己发挥改成别的名字，不然系统会找不到数据库的。

2. **自动初始化**：Tagtag Starter 使用 Spring Boot 的自动初始化功能，会在应用启动时自动执行数据库脚本。没错，就是这么智能，不用您手动导入 SQL 文件了。

**脚本位置**：

- 表结构脚本：各模块下的 `src/main/resources/db/schema.sql`
- 初始数据脚本：各模块下的 `src/main/resources/db/data/` 目录

**自动加载配置**（已在 `backend/tagtag-start/src/main/resources/application-dev.yml` 中配置）：

```yaml
spring:
  datasource:
    init:
      mode: always
      schema-locations:
        - classpath*:db/schema.sql
      data-locations:
        - classpath*:db/data/**.sql
```

3. **初始数据说明**：

- 管理员账号：`admin` / `admin123` - 超级管理员，拥有所有权限
- 普通用户账号：`user` / `user123` - 普通用户，权限有限
- 初始角色：超级管理员、管理员、普通用户 - 权限分级，各司其职
- 初始菜单：系统管理、用户管理、角色管理、菜单管理等 - 该有的都有了

记住这些初始账号密码，别到时候登录不上又来找我们。

### 3. 配置应用 (后端)

编辑 `backend/tagtag-start/src/main/resources/application.yml` 以匹配您的本地环境（数据库凭据、Redis 主机）。

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/tagtag?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: your_password
  data:
    redis:
      host: localhost
      port: 6379
```

把 `your_password` 替换成您真实的数据库密码。别用默认密码，不然被黑客攻破了可别怪我们没提醒您。

### 4. 启动后端服务

```bash
cd backend
mvn clean package -DskipTests
java -jar tagtag-start/target/tagtag-start-0.0.1-SNAPSHOT.jar
```

或者，直接在您的 IDE 中运行 `TagtagApplication.java`。如果您用的是 IDEA，直接右键运行就行，不用我们教了吧？

等一会儿，看到控制台输出一堆日志，最后出现类似 "Started TagtagApplication in X.XXX seconds" 的信息，就说明启动成功了。恭喜您，后端服务已经跑起来了！

### 5. 启动前端应用

1. 进入前端目录：
   ```bash
   cd frontend
   ```
2. 安装依赖：
   ```bash
   pnpm install
   ```

这一步可能需要一点时间，毕竟要下载那么多依赖包。耐心等待，别急，好饭不怕晚。

3. 启动开发服务器：

   ```bash
   pnpm run dev
   ```

看到类似 "Local: <http://localhost:5666/>{rel="nofollow"}" 的信息，就说明前端也启动成功了。太棒了，前后端都跑起来了！

## 验证

启动成功后，您可以访问以下地址来验证系统是否正常运行：

- **前端应用**: 访问 <http://localhost:5666>{rel="nofollow"} - 登录界面，用 admin/admin123 登录试试
- **后端 API 文档**: 访问 <http://localhost:8080/index.html>{rel="nofollow"} (Scalar) - 看看系统提供了哪些 API 接口
- **健康检查**: 访问 <http://localhost:8080/actuator/health>{rel="nofollow"} - 检查后端服务是否健康

如果这些地址都能正常访问，恭喜您，您已经成功搭建了 Tagtag Starter 系统！给自己鼓个掌吧！

## 常见问题与解决方案

如果不幸遇到了问题，别慌，我们准备了一份常见问题清单，看看能不能帮到您。

### 1. 数据库连接失败

**问题描述**：应用启动时出现数据库连接错误。

**解决方案**：

- 检查 MySQL 服务是否正常运行 - 先确认服务没挂
- 确认数据库名称、用户名和密码是否正确 - 别输错了
- 检查数据库地址和端口是否正确 - 默认是 localhost:3306
- 确认数据库用户具有足够的权限 - 给它足够的权限，别太抠门

### 2. Redis 连接失败

**问题描述**：应用启动时出现 Redis 连接错误。

**解决方案**：

- 检查 Redis 服务是否正常运行 - 确认 Redis 没挂
- 确认 Redis 地址和端口是否正确 - 默认是 localhost:6379
- 检查 Redis 密码（如果有设置） - 别忘了密码
- 确认 Redis 实例是否允许远程连接 - 检查一下防火墙设置

### 3. 前端无法访问后端 API

**问题描述**：前端应用无法连接到后端 API。

**解决方案**：

- 检查后端服务是否正常运行 - 后端没跑起来，前端当然访问不了
- 确认前端配置的 API 地址是否正确 - 检查一下配置文件
- 检查 CORS 配置是否正确 - 跨域问题是个常见坑
- 检查防火墙设置，确保端口未被阻止 - 别让防火墙挡住了您的路

### 4. 启动时出现端口冲突

**问题描述**：应用启动时出现端口已被占用的错误。

**解决方案**：

- 修改后端端口：编辑 `application.yml` 中的 `server.port` 配置 - 换个端口试试
- 修改前端端口：编辑 `tagtag-ui/apps/tagtag/.env` 中的 `PORT` 配置 - 前端也可以换端口
- 查找并终止占用端口的进程 - 谁占用了端口，把它干掉

### 5. Maven 依赖下载失败

**问题描述**：执行 `mvn clean package` 时出现依赖下载失败。

**解决方案**：

- 检查网络连接是否正常 - 网络不通，什么都下载不了
- 清理 Maven 本地仓库：删除 `~/.m2/repository` 目录，重新下载依赖 - 有时候缓存会出问题
- 配置 Maven 镜像：在 `settings.xml` 中配置国内镜像源 - 国内下载慢，用镜像加速

### 6. pnpm 依赖安装失败

**问题描述**：执行 `pnpm install` 时出现依赖安装失败。

**解决方案**：

- 检查网络连接是否正常 - 网络问题，老生常谈
- 清理 pnpm 缓存：执行 `pnpm store prune` - 清理一下缓存试试
- 升级 pnpm 版本：执行 `npm install -g pnpm` - 用最新版总没错
- 配置 pnpm 镜像：在 `.npmrc` 中配置国内镜像源 - 国内下载，镜像加速是王道

### 7. 编译错误

**问题描述**：编译过程中出现错误。

**解决方案**：

- 检查 JDK 版本是否符合要求（JDK 17+） - 别用旧版本了
- 检查 Node.js 版本是否符合要求（Node.js >= 20.12.0） - 前端也得跟上
- 清理编译缓存：执行 `mvn clean` 或 `pnpm run clean` - 清理一下缓存
- 检查代码是否存在语法错误或类型错误 - 自己写的代码，自己检查

### 8. 登录失败

**问题描述**：使用初始账号登录失败。

**解决方案**：

- 确认账号和密码是否正确（初始账号：`admin` / `admin123`） - 别输错了
- 检查后端服务是否正常运行 - 后端没跑起来，当然登录不了
- 检查数据库中是否存在用户数据 - 数据库初始化了吗？
- 检查 JWT 配置是否正确 - JWT 配置错了，登录肯定失败

## 下一步

现在您已经成功启动了 Tagtag 应用，您可以：

1. 登录系统，体验各项功能 - 先玩玩看，熟悉一下系统
2. 查看 API 文档，了解系统提供的接口 - 看看有哪些 API 可以用
3. 阅读开发指南，学习如何开发新功能 - 开始您的开发之旅
4. 查看架构文档，深入了解系统设计 - 了解系统的设计思想

祝您使用愉快！如果遇到问题，欢迎在 GitHub 上提 Issue，我们会尽快回复。当然，更欢迎您直接提交 PR，帮助我们改进 Tagtag Starter。


# 架构概览

Tagtag Starter 采用现代化的前后端分离架构，前端负责用户交互与界面展示，后端负责业务逻辑与数据处理。系统设计遵循模块化、高内聚、低耦合的原则，便于扩展和维护。简单来说，就是把事情分清楚，各司其职，别乱来。

## 总体架构

### 架构图

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                           客户端 (Browser)                              │
└─────────────────────────────────────────────────────────────────────────┘
                                    │ HTTPS/HTTP
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           前端应用 (frontend)               │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────────────┐ │
│  │  路由层 │  │  视图层 │  │  组件层 │  │  状态层 │  │  API 客户端层    │ │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
                                    │ RESTful API (JSON)
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           后端应用 (Spring Boot)                        │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────────────┐ │
│  │  控制层 │  │  服务层 │  │  业务层 │  │  数据层 │  │  基础设施层      │ │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           数据存储层                                    │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                     │
│  │  MySQL  │  │  Redis  │  │  MinIO  │  │ 其他存储 │                     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘                     │
└─────────────────────────────────────────────────────────────────────────┘
```

Tagtag Starter 系统由以下两个主要部分组成：

- **前端 (Frontend)**: 位于 `frontend` 目录。基于 Vue 3 + Vite + TypeScript 构建的现代化单页应用 (SPA)，采用了 Vben Admin 5 框架，使用 Tailwind CSS 和 Shadcn UI 进行界面开发。界面美观，交互流畅，用户体验一级棒。
- **后端 (Backend)**: 位于 `backend` 目录下的多个 Java 模块。基于 Spring Boot 构建的模块化应用，负责提供 RESTful API 和数据持久化服务。稳定可靠，性能卓越，就像老黄牛一样任劳任怨。

### 交互方式

- **通信协议**: 前后端通过 HTTP/HTTPS 协议进行通信，采用 RESTful API 风格。简单、标准、易理解。
- **数据格式**: 统一使用 JSON 格式进行数据交换。轻量、易读、易解析。
- **认证机制**: 使用 JWT (JSON Web Token) 进行无状态身份验证。安全、高效、无状态。

### 前后端交互流程

1. **用户认证流程**：

   - 用户访问前端应用，输入用户名和密码
   - 前端调用登录 API，发送认证请求
   - 后端验证用户名和密码，生成 JWT 令牌
   - 前端存储 JWT 令牌，后续请求携带令牌

   :br这个过程就像去银行取钱，先验证身份，拿到凭证，然后就可以凭凭证办理业务了。
2. **API 请求流程**：

   - 前端发起 API 请求，携带 JWT 令牌
   - 后端过滤器验证令牌有效性
   - 控制器接收请求，调用服务层处理业务逻辑
   - 服务层调用数据层访问数据库
   - 数据层返回结果，服务层封装业务响应
   - 控制器返回 JSON 响应给前端
   - 前端处理响应，更新界面

   :br这个流程就像点外卖，您下单（前端请求），商家接单（控制器），厨师做饭（服务层），打包（数据层），配送（返回响应），最后您收到外卖（前端处理）。
3. **WebSocket 实时通信**（可选）：

   - 前端建立 WebSocket 连接，携带认证信息
   - 后端验证并建立连接
   - 双方通过 WebSocket 进行实时数据交换

   :br这就像打电话，建立连接后，双方可以随时说话，不用每次都重新拨号。

### 技术选型理由

#### 后端技术栈

| 技术              | 版本  | 选型理由                                                        |
| --------------- | --- | ----------------------------------------------------------- |
| Spring Boot     | 3.x | 现代化 Java 应用开发框架，提供自动配置、内嵌服务器等特性，简化开发流程。让开发者专注于业务逻辑，而不是配置文件。 |
| Java JDK        | 17  | LTS 版本，提供更好的性能、安全性和新特性支持。用最新的技术，写最稳的代码。                     |
| MyBatis Plus    | 3.x | 简化 MyBatis 开发，提供代码生成、分页插件、逻辑删除等功能。少写代码，多摸鱼（开玩笑的）。           |
| Redis           | 6.x | 用于缓存、会话管理和分布式锁，提高系统性能。让系统飞起来。                               |
| Spring Security | 6.x | 强大的安全框架，支持 JWT 认证和权限控制。安全第一，别让黑客有机可乘。                       |
| MySQL           | 8.x | 稳定可靠的关系型数据库，适合存储结构化数据。数据存储的基石，数据都靠它。                        |

#### 前端技术栈

| 技术           | 版本   | 选型理由                                                  |
| ------------ | ---- | ----------------------------------------------------- |
| Vue 3        | 3.x  | 响应式前端框架，提供 Composition API，更好的类型支持和性能。用最新的框架，写最优雅的代码。 |
| TypeScript   | 5.x  | 静态类型检查，提高代码质量和开发效率。让 bug 无处遁形。                        |
| Vite         | 5.x  | 现代化前端构建工具，提供快速的开发体验和优化的生产构建。开发体验一级棒，启动速度嗖嗖的。          |
| Pinia        | 2.x  | Vue 3 官方状态管理库，简洁易用，支持 TypeScript。状态管理，就这么简单。          |
| Vue Router   | 4.x  | Vue 官方路由管理库，支持组件级路由和嵌套路由。页面跳转，轻轻松松。                   |
| Tailwind CSS | 3.x  | 实用优先的 CSS 框架，提高样式开发效率，支持响应式设计。不用写一堆 CSS 文件了。          |
| Shadcn UI    | 最新   | 可定制的 UI 组件库，基于 Tailwind CSS，提供现代化的设计风格。界面美观，交互流畅。     |
| pnpm         | 10.x | 高效的包管理器，支持 Monorepo 结构，节省磁盘空间和安装时间。比 npm 更快，用过都说好。    |

## 后端架构

Tagtag Starter 后端遵循严格的多模块架构，以分离基础设施、业务逻辑和 API 定义。这种设计使得系统各部分职责清晰，便于维护和扩展。简单来说，就是把事情分清楚，各司其职，别乱来。

**注意**：以下描述均在 `cd backend` 后的目录结构基础上进行说明。

### 后端模块依赖关系

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                           启动层 (tagtag-start)                          │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           模块层 (tagtag-module-*)                       │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           契约层 (tagtag-contract-*)                     │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────┼─────────────────────────────────────────────────┐
│                           核心层 (tagtag-kernel)                         │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────┼─────────────────────────────────────────────────┐
│                           框架层 (tagtag-framework)                      │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────┼─────────────────────────────────────────────────┐
│                           通用层 (tagtag-common)                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 后端分层设计

后端项目组织为以下几个层级：

#### 1. 通用层 (`tagtag-common`)

纯工具类，**无 Spring 依赖**，可独立于 Spring 框架使用。

- 常量定义
- 异常类
- 基础模型 (PageResult, Result)
- 工具类 (BeanUtils, StringUtils, DateUtils) :br 这一层就像工具箱，里面装着各种工具，谁都可以拿来用，不用担心依赖问题。

#### 2. 框架层 (`tagtag-framework`)

基础设施集成。此层依赖于 Spring Boot 和其他第三方库，为上层提供技术支持。

- MyBatis Plus 配置与扩展
- Redis 配置与工具类
- Spring Security & JWT 认证机制

  - JWT 服务与策略
  - 权限守卫
  - 认证上下文管理
- 全局异常处理
- 切面定义 (RateLimit)
- 全局响应封装
- MapStruct 配置
- Web 配置 (CORS, TraceId) :br 这一层就像地基，为上层提供稳定的技术支持。没有这一层，上层就建不起来。

#### 3. 核心层 (`tagtag-kernel`)

核心业务支持逻辑。提供业务开发所需的通用支持和扩展点。

- 自定义注解 (`@RateLimit`, `@RequirePerm`, `@RequireRole`)
- 枚举定义 (Status, Gender)
- 业务常量与错误码
- 安全相关常量和声明 :br 这一层就像核心业务规则，定义了业务开发的基本规范和约束。

#### 4. 契约层 (`tagtag-contract`)

定义模块间的接口和数据结构，采用契约优先设计。

- **DTOs**: 用于 API 输入/输出的数据传输对象。
- **API 接口**: 定义服务契约的 Java 接口。
- **VO**: 视图对象，用于前端展示的数据封装。
- **枚举**: 业务相关的枚举定义。 :br 这一层就像合同，定义了各方（模块）之间的接口和数据结构。有了合同，大家就知道该怎么合作了。

#### 5. 模块层 (`tagtag-module`)

实际的业务实现，每个模块对应一个具体的业务域。

- **控制器 (Controllers)**: 处理 HTTP 请求，调用服务层。
- **服务实现 (Service Implementations)**: 实现业务逻辑。
- **实体类 (Entities)**: 映射到数据库表的实体。
- **映射器 (Mappers)**: 数据库操作接口。
- **业务模型**: 领域模型和业务规则。 :br 这一层就像各个部门，每个部门负责自己的业务，各司其职。

#### 6. 启动层 (`tagtag-start`)

应用入口点。聚合所有模块并提供配置文件。

- Spring Boot 主应用类
- 配置文件 (`application.yml`)
- 环境变量配置
- 依赖管理 :br 这一层就像公司大门，所有模块都从这里进出。

### 后端模块设计原则

1. **高内聚，低耦合**：每个模块只负责一个业务域，模块间通过契约层通信。就像各个部门，各司其职，通过合同（契约层）合作。
2. **依赖倒置**：高层模块依赖于抽象，不依赖于具体实现。就像老板依赖合同，而不是依赖具体的员工。
3. **开闭原则**：对扩展开放，对修改关闭。就像软件升级，可以加新功能，但不能改旧功能。
4. **单一职责**：每个类和方法只负责一个功能。就像一个人只负责一件事，不会什么都干。
5. **分层设计**：严格遵循分层架构，不跨层调用。就像公司层级，不能越级汇报。

## 前端架构

Tagtag Starter 前端采用现代化的 Monorepo 结构，基于 **Vben Admin 5** 框架构建，旨在提供高效、可扩展的前端开发体验。简单来说，就是把前端代码组织得井井有条，方便管理和维护。

**注意**：以下描述均在 `cd frontend` 后的目录结构基础上进行说明。

### 前端架构图

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                           应用层 (apps)                                 │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                     │
│  │  路由层 │  │  视图层 │  │  组件层 │  │  状态层 │                     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘                     │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           核心包层 (packages)                           │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                     │
│  │  UI组件 │  │  Hooks  │  │  工具类 │  │  服务层 │                     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘                     │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           内部工具层 (internal)                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                     │
│  │  构建工具│  │  代码规范│  │  配置文件│  │  脚本工具│                     │
│  └─────────┘  └─────────┘  └─────────┘  └─────────┘                     │
└─────────────────────────────────────────────────────────────────────────┘
```

### 核心技术栈

| 技术           | 版本   | 用途                                         |
| ------------ | ---- | ------------------------------------------ |
| Vue 3        | 3.x  | 响应式前端框架，提供 Composition API。用最新的框架，写最优雅的代码。 |
| TypeScript   | 5.x  | 静态类型检查，提高代码质量。让 bug 无处遁形。                  |
| Vite         | 5.x  | 现代化前端构建工具，提供快速的开发体验。开发体验一级棒，启动速度嗖嗖的。       |
| Pinia        | 2.x  | Vue 3 官方状态管理库。状态管理，就这么简单。                  |
| Vue Router   | 4.x  | Vue 官方路由管理库。页面跳转，轻轻松松。                     |
| Tailwind CSS | 3.x  | 实用优先的 CSS 框架，提高样式开发效率。不用写一堆 CSS 文件了。       |
| Shadcn UI    | 最新   | 可定制的 UI 组件库，基于 Tailwind CSS。界面美观，交互流畅。     |
| pnpm         | 10.x | 高效的包管理器，支持 Monorepo 结构。比 npm 更快，用过都说好。     |

### 模块划分

前端项目主要分为三个层级：

#### 1. 应用层 (`apps`)

包含具体的应用实现，每个子目录对应一个独立的前端应用。

- **`apps/tagtag`**: 主应用程序，包含完整的业务逻辑和界面。

  - `src/api`: API 请求定义和封装。
  - `src/views`: 页面视图组件。
  - `src/router`: 路由配置和守卫。
  - `src/store`: Pinia 状态管理。
  - `src/layouts`: 布局组件。
  - `src/components`: 业务组件。

  :br这一层就像具体的业务部门，负责实现具体的业务功能。

#### 2. 核心包层 (`packages`)

提供可复用的核心功能和组件，供应用层使用。

- **`packages/@core`**: 核心共享库。

  - **`base`**: 基础设计系统、图标和共享工具。
  - **`ui-kit`**: 封装的 UI 组件库。


    - `shadcn-ui`: 基于 Shadcn UI 的基础组件。
    - `form-ui`: 表单组件封装。
    - `layout-ui`: 布局组件封装。
    - `popup-ui`: 弹窗、抽屉等组件封装。
  - **`effects`**: 业务副作用与逻辑封装。


    - `access`: 权限控制逻辑。
    - `hooks`: 通用 Hooks (如 `useTabs`, `useRefresh`)。
    - `request`: 请求库封装。
    - `plugins`: 第三方插件集成 (Echarts, Motion, Vxe-table)。
  - **`preferences`**: 应用偏好设置管理。

  :br这一层就像公共设施，各个业务部门都可以使用，提高代码复用率。

#### 3. 内部工具层 (`internal`)

提供构建、开发和维护所需的工具和配置。

- **`internal/lint-configs`**: ESLint, Prettier, Stylelint 等代码规范配置。
- **`internal/vite-config`**: Vite 构建配置封装。
- **`internal/tailwind-config`**: Tailwind CSS 配置封装。
- **`internal/tsconfig`**: TypeScript 配置文件。 :br 这一层就像后勤部门，为开发提供各种工具和配置支持。

### 前端设计原则

1. **组件化设计**: 将 UI 拆分为可复用的组件，提高代码复用率。就像乐高积木，想怎么搭就怎么搭。
2. **关注点分离**: 业务逻辑、UI 展示和状态管理分离。各司其职，互不干扰。
3. **类型安全**: 充分利用 TypeScript 提供的类型检查。让 bug 无处遁形。
4. **响应式设计**: 适配不同屏幕尺寸的设备。手机、平板、电脑，都能用。
5. **性能优化**: 代码分割、懒加载、虚拟滚动等优化手段。让应用跑得飞快。
6. **可访问性**: 确保应用对所有用户可访问，包括残障用户。人人都能用，才是好应用。
7. **国际化支持**: 支持多语言切换。中文、英文、日文，想用什么语言就用什么语言。

### Monorepo 优势

1. **代码共享**: 多个应用可以共享组件、工具类和配置。不用重复造轮子。
2. **统一依赖管理**: 所有应用使用相同版本的依赖，避免版本冲突。版本统一，少出问题。
3. **统一构建工具**: 共享构建配置和脚本，提高开发效率。一套工具，多个项目。
4. **更好的协作**: 团队成员可以更方便地共享和复用代码。协作更顺畅。
5. **简化版本管理**: 统一版本号管理，简化发布流程。版本管理，轻松搞定。


# 项目结构

Tagtag Starter 项目采用前后端分离架构，包含后端 Java 模块化应用、前端 Vue 3 Monorepo 应用以及完善的文档系统。这种结构设计旨在实现高内聚、低耦合的系统架构，便于维护和扩展。

## 目录概览

```text
tagtag-starter
├── docs                      # 文档项目 (Nuxt Content)
│   ├── app                   # 文档应用源码
│   ├── content               # 文档内容
│   ├── public                # 静态资源
│   └── nuxt.config.ts        # Nuxt 配置
├── backend                   # 后端项目
│   ├── tagtag-common         # 通用工具层（纯 Java 工具，无 Spring 依赖）
│   ├── tagtag-framework      # 基础设施层（Spring Boot, Security, MyBatis Plus）
│   ├── tagtag-kernel         # 核心业务支持（注解, 枚举, 常量, 上下文）
│   ├── tagtag-contract       # API 定义与契约
│   │   ├── tagtag-contract-auth  # 认证契约
│   │   ├── tagtag-contract-iam   # 身份与访问管理契约
│   │   ├── tagtag-contract-storage # 存储契约
│   │   └── tagtag-contract-system # 系统契约
│   ├── tagtag-module         # 业务实现
│   │   ├── tagtag-module-auth    # 认证模块实现
│   │   ├── tagtag-module-iam     # 身份与访问管理模块实现
│   │   ├── tagtag-module-storage # 存储模块实现
│   │   └── tagtag-module-system  # 系统模块实现
│   ├── tagtag-start          # 应用启动入口与配置
│   └── pom.xml              # 根 Maven POM 文件
└── frontend                 # 前端项目 (Vue 3 + Vite, Monorepo)
    ├── apps                  # 应用入口
    │   └── tagtag           # 主应用
    ├── packages              # 核心包与 UI 组件库
    └── internal              # 构建与工具脚本
```

## 后端模块依赖关系

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                           tagtag-start                                 │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
┌─────────────────────────┼─────────────────────────────────────────────────┐
│  tagtag-module-auth   tagtag-module-iam  tagtag-module-storage  tagtag-module-system │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
┌─────────────────────────┼─────────────────────────────────────────────────┐
│ tagtag-contract-auth tagtag-contract-iam tagtag-contract-storage tagtag-contract-system │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
┌─────────────────────────┼─────────────────────────────────────────────────┐
│                           tagtag-kernel                                 │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
┌─────────────────────────┼─────────────────────────────────────────────────┐
│                           tagtag-framework                              │
└─────────────────────────┬─────────────────────────────────────────────────┘
                          │
┌─────────────────────────┼─────────────────────────────────────────────────┐
│                           tagtag-common                                 │
└─────────────────────────────────────────────────────────────────────────┘
```

## 后端模块详解

### 1. 通用工具层 (`tagtag-common`)

纯 Java 工具类库，不依赖 Spring 框架，提供最基础的工具支持。

**主要职责**：

- 提供通用工具类（字符串处理、日期处理、Bean 转换等）
- 定义基础数据模型（PageResult, Result, Exception 等）
- 提供基础常量定义
- 提供验证分组定义

**核心组件**：

- `constant/`: 基础常量（GlobalConstants）
- `enums/`: 基础枚举（CodeEnum）
- `exception/`: 异常类定义（BusinessException, ErrorCode, AssertUtils）
- `model/`: 基础数据模型（PageQuery, PageRequest, PageResult, Result 等）
- `util/`: 工具类（DateTimeUtil, EnumUtil, PageUtil, TreeUtil）
- `validation/`: 验证分组（CreateGroup, UpdateGroup）

### 2. 框架层 (`tagtag-framework`)

基础设施集成层，依赖 Spring Boot 和其他第三方库，为上层提供技术支持。

**主要职责**：

- 集成 Spring Boot 生态组件
- 配置数据库、缓存、安全等基础设施
- 提供全局异常处理和响应封装
- 实现 AOP 切面（日志、限流、操作日志等）

**核心组件**：

- `aop/`: 切面实现（RateLimitAspect）
- `config/`: 配置类（CacheConfig, JacksonConfig, RedisConfig, SecurityConfig 等）
- `mapstruct/`: MapStruct 配置
- `mybatis/`: MyBatis Plus 配置和字段自动填充
- `security/`: Spring Security 配置和 JWT 实现


  - `config/`: JWT 认证配置
  - `context/`: 认证上下文管理
  - `filter/`: 自定义过滤器
  - `guard/`: 权限守卫（PermissionGuard, RoleGuard）
  - `handler/`: 自定义认证和授权处理器
  - `model/`: 安全相关模型
  - `service/`: JWT 服务和 Token 版本服务
  - `strategy/`: JWT 解码和签名策略
  - `util/`: JWT 工具类
- `util/`: 工具类（PageResults, Pages, WebUtil）
- `web/`: 全局异常处理、CORS 配置、TraceId 过滤器


  - `exception/`: 各种异常处理器
  - `CorsConfig.java`: CORS 配置
  - `FilterConfig.java`: 过滤器配置
  - `TraceIdFilter.java`: TraceId 过滤器

### 3. 核心层 (`tagtag-kernel`)

核心业务支持层，提供业务开发所需的通用支持和扩展点。

**主要职责**：

- 定义自定义注解（限流等）
- 提供业务常量和枚举类
- 实现用户上下文管理
- 提供业务 AOP 切面
- 实现安全相关的模型和工具

**核心组件**：

- `annotation/`: 自定义注解（@RateLimit, @RequirePerm, @RequireRole）
- `constant/`: 业务常量（AppMessages, CacheConstants, Permissions, Roles, SecurityClaims, SecurityConstants）
- `enums/`: 业务枚举（GenderEnum, StatusEnum）

### 4. 契约层 (`tagtag-contract`)

API 定义与契约层，采用契约优先设计，将 API 定义与实现分离。

**主要职责**：

- 定义 API 接口和数据传输对象（DTO）
- 定义视图对象（VO）
- 定义业务枚举和常量
- 定义服务接口

**子模块**：

#### `tagtag-contract-auth`

- 认证相关 API 定义
- 登录、登出、刷新令牌等接口
- 认证相关 DTO 和 VO

#### `tagtag-contract-iam`

- 身份与访问管理 API 定义
- 用户、角色、菜单、部门管理接口
- IAM 相关 DTO 和 VO

#### `tagtag-contract-storage`

- 存储服务 API 定义
- 文件上传、下载、删除等接口
- 存储相关 DTO 和 VO

#### `tagtag-contract-system`

- 系统管理 API 定义
- 字典、消息、系统配置等接口
- 系统相关 DTO 和 VO

### 5. 模块层 (`tagtag-module`)

业务实现层，每个模块对应一个具体的业务域，实现契约层定义的接口。

**主要职责**：

- 实现业务逻辑
- 访问数据库
- 调用其他服务
- 实现控制器

**子模块**：

#### `tagtag-module-auth`

- 认证业务逻辑实现
- 登录、登出、刷新令牌等功能
- JWT 令牌生成和验证

#### `tagtag-module-iam`

- 身份与访问管理业务逻辑
- 用户、角色、菜单、部门管理实现
- 权限校验和数据权限控制

#### `tagtag-module-storage`

- 存储业务逻辑实现
- 文件上传、下载、删除等功能
- 支持本地存储和云存储

#### `tagtag-module-system`

- 系统管理业务逻辑
- 字典、消息、系统配置等功能
- 系统监控和统计

### 6. 启动层 (`tagtag-start`)

应用启动入口，聚合所有模块并提供配置文件。

**主要职责**：

- Spring Boot 主应用类
- 应用配置文件管理
- 环境变量配置
- 依赖管理

**核心组件**：

- `TagtagApplication.java`: 主应用类
- `resources/application.yml`: 主配置文件
- `resources/application-dev.yml`: 开发环境配置
- `resources/application-prod.yml`: 生产环境配置
- `resources/logback-spring.xml`: 日志配置

## 前端模块详解

`tagtag-ui` 采用 Monorepo 结构管理，使用 pnpm 作为包管理器，实现代码共享和依赖管理的优化。

### Monorepo 设计理念

Monorepo 是一种将多个项目代码存储在单个仓库中的软件架构策略。Tagtag 采用 Monorepo 结构的主要优势包括：

1. **代码共享**：多个应用可以共享组件、工具类和配置
2. **统一依赖管理**：所有应用使用相同版本的依赖，避免版本冲突
3. **统一构建工具**：共享构建配置和脚本，提高开发效率
4. **更好的协作**：团队成员可以更方便地共享和复用代码
5. **简化版本管理**：统一版本号管理，简化发布流程

### 1. 应用层 (`apps`)

包含具体的应用实现，每个子目录对应一个独立的前端应用。

#### `apps/tagtag` - 主应用

**核心组件**：

- `src/api/`: API 请求定义和封装


  - `core/`: 核心 API（认证、用户、菜单）
  - `modules/`: 模块 API（IAM、系统、存储）
- `src/views/`: 页面视图组件


  - `_core/`: 核心页面（登录、个人中心、404 等）
  - `dashboard/`: 仪表盘页面
  - `modules/`: 模块页面（IAM、系统、存储）
- `src/router/`: 路由配置


  - `routes/`: 路由定义
  - `access.ts`: 路由守卫
  - `guard.ts`: 权限守卫
- `src/store/`: Pinia 状态管理
- `src/layouts/`: 布局组件
- `src/components/`: 业务组件
- `src/locales/`: 国际化配置

### 2. 核心包层 (`packages`)

提供可复用的核心功能和组件，供应用层使用。

#### `packages/@core` - 核心共享库

**子模块**：

- **`base`**: 基础设计系统、图标和共享工具


  - `design/`: 设计系统和设计令牌
  - `icons/`: 图标库
  - `shared/`: 共享工具类
- **`ui-kit`**: 封装的 UI 组件库


  - `shadcn-ui`: 基于 Shadcn UI 的基础组件
  - `form-ui`: 表单组件封装
  - `layout-ui`: 布局组件封装
  - `popup-ui`: 弹窗、抽屉等组件封装
  - `tabs-ui`: 标签页组件封装
  - `menu-ui`: 菜单组件封装
- **`effects`**: 业务副作用与逻辑封装


  - `access`: 权限控制逻辑
  - `hooks`: 通用 Hooks（useTabs, useRefresh, usePagination）
  - `request`: 请求库封装
  - `plugins`: 第三方插件集成（Echarts, Motion, Vxe-table）
- **`preferences`**: 应用偏好设置管理

#### `packages/effects` - 业务副作用与逻辑

- `access/`: 权限控制实现
- `common-ui/`: 通用 UI 组件
- `hooks/`: 业务 Hooks
- `layouts/`: 布局组件
- `plugins/`: 插件集成

### 3. 内部工具层 (`internal`)

提供构建、开发和维护所需的工具和配置。

**核心组件**：

- `lint-configs/`: ESLint, Prettier, Stylelint 等代码规范配置
- `vite-config/`: Vite 构建配置封装
- `tailwind-config/`: Tailwind CSS 配置封装
- `tsconfig/`: TypeScript 配置文件
- `node-utils/`: Node.js 工具函数

## 配置文件详解

### 后端配置

#### 主配置文件 (`tagtag-start/src/main/resources/application.yml`)

```yaml
spring:
  application:
    name: tagtag-admin  # 应用名称
    version: 1.0.0      # 应用版本
  profiles:
    active: dev         # 激活的配置文件
  jackson:
    date-format: yyyy-MM-dd HH:mm:ss  # 日期格式
    time-zone: GMT+8    # 时区
  servlet:
    multipart:
      max-file-size: 50MB  # 单个文件最大大小
      max-request-size: 50MB  # 请求最大大小

server:
  port: 8080           # 服务端口
  servlet:
    context-path: /    # 上下文路径

logging:
  config: classpath:logback-spring.xml  # 日志配置文件

mybatis-plus:
  global-config:
    banner: false      # 关闭 MyBatis Plus  banner

# 存储配置
storage:
  local:
    base-path: uploads  # 本地存储基础路径
```

### 前端配置

#### 应用配置 (`tagtag-ui/apps/tagtag/vite.config.mts`)

基于内部封装的 Vite 配置，提供统一的构建配置。

#### 环境配置 (`tagtag-ui/apps/tagtag/.env`)

```env
# 开发环境
VITE_APP_API_BASE_URL=http://localhost:8080
VITE_APP_TITLE=Tagtag Admin
VITE_APP_SHORT_NAME=Tagtag
```

#### Tailwind 配置 (`tagtag-ui/internal/tailwind-config/src/index.ts`)

统一的 Tailwind CSS 配置，包含主题、插件和自定义工具类。

## 文档系统

文档系统基于 Nuxt Content 构建，提供现代化的文档阅读体验。

**核心组件**：

- `docs/app/`: Nuxt 应用源码
- `docs/content/`: 文档内容（Markdown 文件）
- `docs/nuxt.config.ts`: Nuxt 配置

**文档结构**：

- `1.getting-started/`: 入门指南
- `2.architecture/`: 架构文档
- `3.developer-guide/`: 开发者指南
- `3.modules/`: 模块文档
- `en/`: 英文文档

## 最佳实践

### 后端开发最佳实践

1. **遵循分层设计**：严格按照通用层、框架层、核心层、契约层、模块层的顺序依赖
2. **契约优先**：先定义 API 契约，再实现业务逻辑
3. **使用自定义注解**：利用 @OperationLog, @DataPermission 等注解简化开发
4. **统一响应格式**：使用 Result 封装 API 响应
5. **异常处理**：统一使用自定义异常，由全局异常处理器处理

### 前端开发最佳实践

1. **组件化开发**：将 UI 拆分为可复用的组件
2. **类型安全**：充分利用 TypeScript 提供的类型检查
3. **状态管理**：合理使用 Pinia 管理应用状态
4. **API 封装**：统一封装 API 请求，处理错误和认证
5. **国际化**：支持多语言切换，使用 locales 目录管理翻译
6. **代码规范**：遵循 ESLint、Prettier 等代码规范

### 目录结构最佳实践

1. **按功能组织代码**：将相关功能放在同一个目录下
2. **命名规范**：使用清晰、一致的命名约定
3. **避免深层嵌套**：目录层级不宜过深，建议不超过 4 层
4. **保持代码精简**：避免不必要的文件和代码
5. **文档化**：为重要组件和功能编写文档

## 扩展建议

### 后端扩展

1. **添加新模块**：

   - 在 `tagtag-contract` 下创建新的契约模块
   - 在 `tagtag-module` 下创建对应的实现模块
   - 在 `tagtag-start` 中添加依赖
2. **集成新功能**：

   - 在 `tagtag-framework` 中集成新的基础设施
   - 在 `tagtag-kernel` 中添加对应的支持
   - 在 `tagtag-contract` 中定义 API 契约
   - 在 `tagtag-module` 中实现业务逻辑

### 前端扩展

1. **添加新组件**：

   - 在 `packages/@core/ui-kit` 中添加新组件
   - 在应用中导入使用
2. **添加新页面**：

   - 在 `apps/tagtag/src/views` 中添加新页面
   - 在 `apps/tagtag/src/router` 中配置路由
   - 在 `apps/tagtag/src/api` 中添加 API 定义
3. **添加新功能**：

   - 在 `packages/effects` 中添加新的副作用逻辑
   - 在 `packages/@core/hooks` 中添加新的 Hooks
   - 在应用中使用新功能


# 前端架构

Tagtag Starter 前端采用现代化的架构设计，基于 Vue 3 + TypeScript + Vite 构建，使用 Monorepo 结构管理代码。本文档将详细介绍前端架构的设计理念、技术栈、核心组件和最佳实践。

## 1. 架构设计理念

Tagtag Starter 前端架构遵循以下设计理念：

### 1.1 组件化设计

将 UI 拆分为可复用的组件，每个组件负责一个独立的功能，提高代码复用率和可维护性。

### 1.2 关注点分离

业务逻辑、UI 展示和状态管理分离，使代码结构清晰，易于测试和维护。

### 1.3 类型安全

充分利用 TypeScript 提供的静态类型检查，提高代码质量和开发效率。

### 1.4 响应式设计

适配不同屏幕尺寸的设备，提供良好的用户体验。

### 1.5 性能优化

采用代码分割、懒加载、虚拟滚动等优化手段，提高应用性能。

### 1.6 可扩展性

设计灵活的扩展机制，便于添加新功能和集成第三方库。

## 2. 技术栈

| 技术           | 版本   | 用途                           |
| ------------ | ---- | ---------------------------- |
| Vue 3        | 3.x  | 响应式前端框架，提供 Composition API。  |
| TypeScript   | 5.x  | 静态类型检查，提高代码质量。               |
| Vite         | 5.x  | 现代化前端构建工具，提供快速的开发体验。         |
| Pinia        | 2.x  | Vue 3 官方状态管理库。               |
| Vue Router   | 4.x  | Vue 官方路由管理库。                 |
| Tailwind CSS | 3.x  | 实用优先的 CSS 框架，提高样式开发效率。       |
| Shadcn UI    | 最新   | 可定制的 UI 组件库，基于 Tailwind CSS。 |
| pnpm         | 10.x | 高效的包管理器，支持 Monorepo 结构。      |
| Axios        | 1.x  | HTTP 客户端，用于 API 请求。          |
| Echarts      | 5.x  | 数据可视化库。                      |

## 3. Monorepo 结构

Tagtag Starter 前端采用 Monorepo 结构管理代码，使用 pnpm 作为包管理器。这种结构的优势包括：

### 3.1 代码共享

多个应用可以共享组件、工具类和配置，减少重复代码。

### 3.2 统一依赖管理

所有应用使用相同版本的依赖，避免版本冲突。

### 3.3 统一构建工具

共享构建配置和脚本，提高开发效率。

### 3.4 更好的协作

团队成员可以更方便地共享和复用代码。

### 3.5 简化版本管理

统一版本号管理，简化发布流程。

## 4. 目录结构

**注意**：以下描述均在 `cd frontend` 后的目录结构基础上进行说明。

```text
frontend
├── apps                  # 应用层
│   └── tagtag            # 主应用
│       ├── public        # 静态资源
│       └── src           # 源代码
├── packages              # 核心包层
│   ├── @core             # 核心共享库
│   │   ├── base          # 基础设计系统、图标和共享工具
│   │   ├── composables   # 通用组合式函数
│   │   ├── preferences   # 应用偏好设置管理
│   │   └── ui-kit        # UI 组件库
│   ├── constants         # 常量定义
│   └── effects           # 业务副作用与逻辑封装
└── internal              # 内部工具层
    ├── lint-configs      # 代码规范配置
    ├── node-utils        # Node.js 工具函数
    ├── tailwind-config   # Tailwind CSS 配置
    ├── tsconfig          # TypeScript 配置文件
    └── vite-config       # Vite 构建配置
```

## 5. 核心模块

### 5.1 应用层 (`apps`)

包含具体的应用实现，每个子目录对应一个独立的前端应用。

#### 5.1.1 主应用 (`apps/tagtag`)

**核心组件**：

- `src/api/`: API 请求定义和封装

  - `core/`: 核心 API（认证、用户、菜单）
  - `modules/`: 模块 API（IAM、系统、存储）
  - `request.ts`: Axios 实例配置
- `src/views/`: 页面视图组件

  - `_core/`: 核心页面（登录、个人中心、404 等）
  - `dashboard/`: 仪表盘页面
  - `modules/`: 模块页面（IAM、系统、存储）
- `src/router/`: 路由配置

  - `routes/`: 路由定义
  - `access.ts`: 路由守卫
  - `guard.ts`: 权限守卫
- `src/store/`: Pinia 状态管理

  - `auth.ts`: 认证状态管理
- `src/layouts/`: 布局组件

  - `auth.vue`: 认证布局
  - `basic.vue`: 基础布局
- `src/components/`: 业务组件
- `src/locales/`: 国际化配置

  - `langs/`: 语言包

### 5.2 核心包层 (`packages`)

提供可复用的核心功能和组件，供应用层使用。

**子模块**：

#### 5.2.1 核心共享库 (`packages/@core`)

**子模块**：

- **`base`**: 基础设计系统、图标和共享工具

  - `design/`: 设计系统和设计令牌
  - `icons/`: 图标库
  - `shared/`: 共享工具类
  - `typings/`: 类型定义
- **`composables`**: 通用组合式函数

  - `use-is-mobile.ts`: 移动端检测
  - `use-layout-style.ts`: 布局样式管理
  - `use-namespace.ts`: 命名空间管理
  - `use-scroll-lock.ts`: 滚动锁定管理
  - `use-sortable.ts`: 排序功能
- **`preferences`**: 应用偏好设置管理

  - 主题设置
  - 布局设置
  - 其他用户偏好
- **`ui-kit`**: 封装的 UI 组件库

  - `shadcn-ui`: 基于 Shadcn UI 的基础组件
  - `form-ui`: 表单组件封装
  - `layout-ui`: 布局组件封装
  - `popup-ui`: 弹窗、抽屉等组件封装
  - `tabs-ui`: 标签页组件封装
  - `menu-ui`: 菜单组件封装

#### 5.2.2 常量定义 (`packages/constants`)

- 核心常量定义
- 业务常量定义

#### 5.2.3 业务副作用与逻辑封装 (`packages/effects`)

- **`access`**: 权限控制逻辑

  - 权限指令
  - 权限组件
  - 权限管理
- **`common-ui`**: 通用 UI 组件

  - 关于页面
  - fallback 页面
  - 个人中心组件
- **`hooks`**: 通用 Hooks

  - `use-app-config.ts`: 应用配置管理
  - `use-content-maximize.ts`: 内容最大化管理
  - `use-design-tokens.ts`: 设计令牌管理
  - `use-hover-toggle.ts`: 悬停切换管理
  - `use-pagination.ts`: 分页管理
  - `use-refresh.ts`: 刷新功能
  - `use-tabs.ts`: 标签页管理
  - `use-watermark.ts`: 水印功能
- **`layouts`**: 布局组件

  - 基础布局
  - 认证布局
  - iframe 布局
- **`plugins`**: 第三方插件集成

  - `echarts`: ECharts 图表集成
  - `motion`: 动画集成
  - `vxe-table`: 表格集成

### 5.3 内部工具层 (`internal`)

提供构建、开发和维护所需的工具和配置。

**核心组件**：

- `lint-configs/`: ESLint, Prettier, Stylelint 等代码规范配置
- `node-utils/`: Node.js 工具函数
- `tailwind-config/`: Tailwind CSS 配置封装
- `tsconfig/`: TypeScript 配置文件


  - `base.json`: 基础 TypeScript 配置
  - `library.json`: 库 TypeScript 配置
  - `node.json`: Node.js TypeScript 配置
  - `web-app.json`: Web 应用 TypeScript 配置
  - `web.json`: Web TypeScript 配置
- `vite-config/`: Vite 构建配置封装


  - 应用配置
  - 库配置
  - 插件配置

## 6. 数据流设计

### 6.1 状态管理

使用 Pinia 进行状态管理，将应用状态划分为多个模块，每个模块负责一个独立的功能域。

**状态管理流程**：

1. 组件通过 `useStore` 钩子获取状态
2. 组件调用 action 修改状态
3. Action 可以调用 API 获取数据
4. Mutation 修改状态（在 Pinia 中，action 可以直接修改状态）
5. 状态变化触发组件重新渲染

### 6.2 API 请求流程

1. 组件调用 API 函数
2. API 函数使用封装的 Axios 实例发送请求
3. 请求拦截器添加认证信息和其他头部
4. 后端处理请求，返回响应
5. 响应拦截器处理响应，统一处理错误
6. API 函数返回响应数据
7. 组件处理响应数据，更新状态或 UI

### 6.3 路由流程

1. 用户访问某个路由
2. 路由守卫检查用户权限
3. 权限通过后，加载对应的组件
4. 组件获取数据，渲染页面

## 7. 权限控制

Tagtag Starter 前端实现了基于角色的权限控制（RBAC），包括：

### 7.1 路由权限

- 动态路由生成：根据用户角色生成可访问的路由
- 路由守卫：检查用户是否有权限访问某个路由

### 7.2 组件权限

- 权限指令：使用 `v-access` 指令控制组件的显示和隐藏
- 权限组件：使用 `AccessControl` 组件控制子组件的显示和隐藏

### 7.3 按钮权限

- 按钮权限指令：使用 `v-access` 指令控制按钮的显示和隐藏

## 8. 国际化支持

Tagtag Starter 前端支持多语言切换，使用 Vue I18n 实现。

**国际化配置**：

- `src/locales/langs/`: 语言包文件
- `src/locales/index.ts`: 国际化配置

**使用方式**：

```vue
<template>
  <div>{{ $t('common.save') }}</div>
</template>

<script setup lang="ts">
import { useI18n } from 'vue-i18n'
const { t } = useI18n()
</script>
```

## 9. 构建和部署

### 9.1 构建流程

1. 安装依赖：`pnpm install`
2. 开发模式：`pnpm run dev`
3. 生产构建：`pnpm run build`
4. 预览生产构建：`pnpm run preview`

### 9.2 构建优化

- 代码分割：根据路由和组件分割代码
- 懒加载：按需加载路由和组件
- Tree Shaking：移除未使用的代码
- 压缩：压缩 JavaScript、CSS 和 HTML

### 9.3 部署方式

- 静态文件部署：将构建生成的静态文件部署到 CDN 或 Web 服务器
- Docker 部署：使用 Docker 容器部署应用
- Kubernetes 部署：使用 Kubernetes 管理容器化应用

## 10. 最佳实践

### 10.1 组件开发

- 组件命名：使用 PascalCase 命名组件
- 组件职责：每个组件负责一个独立的功能
- 组件通信：使用 Props 和 Emits 进行组件通信
- 组件测试：为组件编写单元测试

### 10.2 API 开发

- API 命名：使用 RESTful API 风格
- API 封装：统一封装 API 请求，处理错误和认证
- API 文档：使用 Swagger 或其他工具生成 API 文档

### 10.3 状态管理

- 状态设计：保持状态简洁，避免冗余
- 状态划分：根据功能域划分状态模块
- 异步处理：在 action 中处理异步逻辑

### 10.4 性能优化

- 避免不必要的渲染：使用 `v-memo` 和 `v-once` 指令
- 虚拟滚动：处理大量数据时使用虚拟滚动
- 图片优化：使用适当的图片格式和大小
- 懒加载：按需加载路由和组件

### 10.5 代码规范

- 遵循 ESLint 和 Prettier 配置
- 使用 TypeScript 严格模式
- 注释规范：为复杂代码添加注释

## 11. 开发工具和流程

### 11.1 开发工具

- VS Code：推荐的代码编辑器
- Volar：Vue 3 开发插件
- ESLint：代码质量检查
- Prettier：代码格式化

### 11.2 开发流程

1. 克隆代码仓库
2. 安装依赖
3. 启动开发服务器
4. 编写代码
5. 运行测试
6. 提交代码
7. 代码审查
8. 合并代码
9. 构建和部署

## 12. 测试策略

### 12.1 单元测试

使用 Vitest 进行单元测试，测试组件、工具函数和状态管理。

### 12.2 集成测试

测试组件之间的交互和 API 调用。

### 12.3 E2E 测试

使用 Cypress 进行端到端测试，测试完整的用户流程。

## 13. 监控和日志

### 13.1 应用监控

- 使用 Sentry 或其他工具监控应用错误
- 收集用户行为数据，分析应用使用情况

### 13.2 日志记录

- 记录应用错误和警告
- 记录关键操作日志
- 使用日志分析工具分析日志

## 14. 未来规划

- 支持微前端架构
- 增强 TypeScript 类型支持
- 优化性能和用户体验
- 增加更多的 UI 组件和模板
- 支持更多的国际化语言

# 总结

Tagtag Starter 前端架构采用现代化的设计理念和技术栈，基于 Vue 3 + TypeScript + Vite 构建，使用 Monorepo 结构管理代码。这种架构设计具有良好的可扩展性、可维护性和性能，适合构建复杂的企业级应用。

通过本文档的介绍，您应该对 Tagtag Starter 前端架构有了全面的了解。如果您想深入了解某个具体的模块或组件，可以查看相关的源代码和文档。


# 实战教程：开发 CRUD 功能

本教程将以开发一个简单的 &#x2A;*"文章管理 (Post)"** 功能为例，带您完整体验 Tagtag Starter 的前后端开发流程。

我们将实现以下功能：

1. 文章列表的分页查询（支持条件筛选）
2. 新增文章（包含表单验证）
3. 编辑文章（支持部分字段更新）
4. 删除文章（支持单个和批量删除）
5. 文章状态管理（启用/禁用）
6. 批量操作（批量删除、批量更新状态）

---

## 第一步：后端开发 (Backend)

### 1. 数据库设计

首先，在数据库中创建 `sys_post` 表。

```sql
CREATE TABLE `sys_post` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(100) NOT NULL COMMENT '文章标题',
  `content` text COMMENT '文章内容',
  `status` tinyint(4) DEFAULT 1 COMMENT '状态: 1-发布, 0-草稿',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `create_by` bigint(20) DEFAULT NULL COMMENT '创建人',
  `update_by` bigint(20) DEFAULT NULL COMMENT '更新人',
  `deleted` tinyint(4) DEFAULT 0 COMMENT '删除标识: 0-未删除, 1-已删除',
  PRIMARY KEY (`id`),
  KEY `idx_title` (`title`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文章表';
```

### 2. 定义契约 (Contract)

在 `tagtag-contract` 模块中定义 DTO (Data Transfer Object)。建议新建 `PostDTO.java` 和 `PostQueryDTO.java`。

**PostDTO.java (用于新增/修改)**

```java
package dev.tagtag.contract.system.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

@Data
public class PostDTO {
    private Long id;

    @NotBlank(message = "标题不能为空")
    private String title;

    private String content;

    @NotNull(message = "状态不能为空")
    private Integer status;
}
```

**PostQueryDTO.java (用于查询)**

```java
package dev.tagtag.contract.system.dto;

import lombok.Data;

@Data
public class PostQueryDTO {
    private String title;
    private Integer status;
}
```

**PostOperationRequest.java (用于批量操作)**

```java
package dev.tagtag.contract.system.dto;

import jakarta.validation.constraints.NotEmpty;
import lombok.Data;

@Data
public class PostOperationRequest {
    @NotEmpty(message = "ID列表不能为空")
    private java.util.List<Long> ids;

    @NotNull(message = "状态不能为空")
    private Integer status;

    private String password;
}
```

### 3. 持久层实现 (Mapper & Entity)

在 `tagtag-module-system` 模块中创建实体类和 Mapper。

**PostEntity.java**

```java
package dev.tagtag.module.system.entity;

import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableLogic;
import com.baomidou.mybatisplus.annotation.TableName;
import dev.tagtag.framework.mybatis.entity.BaseEntity;
import lombok.Data;
import lombok.EqualsAndHashCode;

@Data
@EqualsAndHashCode(callSuper = true)
@TableName("sys_post")
public class PostEntity extends BaseEntity {
    private String title;
    private String content;
    private Integer status;

    @TableLogic
    private Integer deleted;
}
```

**PostMapper.java**

```java
package dev.tagtag.module.system.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import dev.tagtag.contract.system.dto.PostQueryDTO;
import dev.tagtag.module.system.entity.Post;
import dev.tagtag.module.system.entity.vo.PostVO;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

@Mapper
public interface PostMapper extends BaseMapper<Post> {

    /**
     * XML 分页查询（由 MyBatis XML 构建 WHERE/ORDER BY）
     *
     * @param page 分页对象（MyBatis Plus 拦截器识别）
     * @param q    查询条件 DTO
     * @return 分页结果
     */
    IPage<PostVO> selectPage(IPage<PostVO> page, @Param("q") PostQueryDTO q);
}
```

**PostVO.java (视图对象)**

```java
package dev.tagtag.module.system.entity.vo;

import lombok.Data;

import java.time.LocalDateTime;

@Data
public class PostVO {
    private Long id;
    private String title;
    private String content;
    private Integer status;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
```

### 4. 业务层实现 (Service)

**PostService.java**

```java
package dev.tagtag.module.system.service;

import dev.tagtag.common.model.PageQuery;
import dev.tagtag.common.model.PageResult;
import dev.tagtag.contract.system.dto.PostDTO;
import dev.tagtag.contract.system.dto.PostQueryDTO;
import java.util.List;

public interface PostService {

    /**
     * 文章分页查询
     * @param query 查询条件DTO
     * @param pageQuery 分页参数
     * @return 分页结果
     */
    PageResult<PostDTO> page(PostQueryDTO query, PageQuery pageQuery);

    /**
     * 获取文章详情
     * @param id 文章ID
     * @return 文章DTO
     */
    PostDTO getById(Long id);

    /**
     * 创建文章
     * @param post 文章DTO
     */
    void create(PostDTO post);

    /**
     * 更新文章（忽略源对象中的空值）
     * @param post 文章DTO
     */
    void update(PostDTO post);

    /**
     * 删除文章
     * @param id 文章ID
     */
    void delete(Long id);

    /**
     * 批量删除文章
     * @param ids 文章ID列表
     */
    void batchDelete(List<Long> ids);

    /**
     * 更新单个文章状态
     * @param id 文章ID
     * @param status 状态值
     */
    void updateStatus(Long id, Integer status);

    /**
     * 批量更新文章状态
     * @param ids 文章ID列表
     * @param status 状态值
     */
    void batchUpdateStatus(List<Long> ids, Integer status);
}
```

**PostServiceImpl.java**

```java
package dev.tagtag.module.system.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import dev.tagtag.common.model.PageQuery;
import dev.tagtag.common.model.PageResult;
import dev.tagtag.common.util.BeanUtil;
import dev.tagtag.contract.system.dto.PostDTO;
import dev.tagtag.contract.system.dto.PostQueryDTO;
import dev.tagtag.module.system.entity.Post;
import dev.tagtag.module.system.entity.vo.PostVO;
import dev.tagtag.module.system.mapper.PostMapper;
import dev.tagtag.module.system.service.PostService;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
@RequiredArgsConstructor
public class PostServiceImpl implements PostService {

    private final PostMapper postMapper;

    @Override
    public PageResult<PostDTO> page(PostQueryDTO query, PageQuery pageQuery) {
        IPage<PostVO> page = new Page<>(pageQuery.getPage(), pageQuery.getSize());
        IPage<PostVO> result = postMapper.selectPage(page, query);
        
        return PageResult.of(
            result.getRecords().stream()
                .map(vo -> BeanUtil.copyProperties(vo, PostDTO.class))
                .toList(),
            result.getTotal()
        );
    }

    @Override
    public PostDTO getById(Long id) {
        Post post = postMapper.selectById(id);
        if (post == null) {
            throw new RuntimeException("文章不存在");
        }
        return BeanUtil.copyProperties(post, PostDTO.class);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void create(PostDTO post) {
        Post entity = BeanUtil.copyProperties(post, Post.class);
        postMapper.insert(entity);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void update(PostDTO post) {
        Post entity = BeanUtil.copyProperties(post, Post.class);
        postMapper.updateById(entity);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void delete(Long id) {
        postMapper.deleteById(id);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void batchDelete(List<Long> ids) {
        postMapper.deleteBatchIds(ids);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void updateStatus(Long id, Integer status) {
        Post entity = new Post();
        entity.setId(id);
        entity.setStatus(status);
        postMapper.updateById(entity);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void batchUpdateStatus(List<Long> ids, Integer status) {
        ids.forEach(id -> updateStatus(id, status));
    }
}
```

### 5. 控制层实现 (Controller)

**PostController.java**

```java
package dev.tagtag.module.system.controller;

import dev.tagtag.common.model.PageQuery;
import dev.tagtag.common.model.PageResult;
import dev.tagtag.common.model.Result;
import dev.tagtag.contract.system.dto.PostDTO;
import dev.tagtag.contract.system.dto.PostQueryDTO;
import dev.tagtag.module.system.service.PostService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/posts")
@Tag(name = "文章管理")
@RequiredArgsConstructor
public class PostController {
    
    private final PostService postService;

    /**
     * 分页查询文章
     */
    @GetMapping
    @Operation(summary = "分页查询文章")
    @PreAuthorize("@ss.hasPermission('system:post:query')")
    public Result<PageResult<PostDTO>> page(PostQueryDTO query, PageQuery pageQuery) {
        return Result.ok(postService.page(query, pageQuery));
    }

    /**
     * 获取文章详情
     */
    @GetMapping("/{id}")
    @Operation(summary = "获取文章详情")
    @PreAuthorize("@ss.hasPermission('system:post:query')")
    public Result<PostDTO> getById(@PathVariable Long id) {
        return Result.ok(postService.getById(id));
    }

    /**
     * 创建文章
     */
    @PostMapping
    @Operation(summary = "创建文章")
    @PreAuthorize("@ss.hasPermission('system:post:create')")
    public Result<Void> create(@Valid @RequestBody PostDTO dto) {
        postService.create(dto);
        return Result.okMsg("创建成功");
    }

    /**
     * 更新文章
     */
    @PutMapping
    @Operation(summary = "更新文章")
    @PreAuthorize("@ss.hasPermission('system:post:update')")
    public Result<Void> update(@Valid @RequestBody PostDTO dto) {
        postService.update(dto);
        return Result.okMsg("更新成功");
    }

    /**
     * 删除文章
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "删除文章")
    @PreAuthorize("@ss.hasPermission('system:post:delete')")
    public Result<Void> delete(@PathVariable Long id) {
        postService.delete(id);
        return Result.okMsg("删除成功");
    }

    /**
     * 批量删除文章
     */
    @DeleteMapping("/batch")
    @Operation(summary = "批量删除文章")
    @PreAuthorize("@ss.hasPermission('system:post:delete')")
    public Result<Void> batchDelete(@RequestBody List<Long> ids) {
        postService.batchDelete(ids);
        return Result.okMsg("批量删除成功");
    }

    /**
     * 更新文章状态
     */
    @PutMapping("/{id}/status")
    @Operation(summary = "更新文章状态")
    @PreAuthorize("@ss.hasPermission('system:post:update')")
    public Result<Void> updateStatus(@PathVariable Long id, @RequestParam Integer status) {
        postService.updateStatus(id, status);
        return Result.okMsg("状态更新成功");
    }

    /**
     * 批量更新文章状态
     */
    @PutMapping("/status/batch")
    @Operation(summary = "批量更新文章状态")
    @PreAuthorize("@ss.hasPermission('system:post:update')")
    public Result<Void> batchUpdateStatus(@RequestBody List<Long> ids, @RequestParam Integer status) {
        postService.batchUpdateStatus(ids, status);
        return Result.okMsg("批量状态更新成功");
    }
}
```

**关键要点：**

- 使用 `@PreAuthorize` 注解进行权限控制
- 使用 `@Operation` 注解提供 API 文档说明
- 所有修改操作（创建、更新、删除）都需要事务支持
- 批量操作提供统一的入口，提高前端调用效率
- 状态管理提供单独的更新接口，便于前端实现启用/禁用功能

---

## 第二步：前端开发 (Frontend)

### 1. 定义 API

在 `frontend/apps/tagtag/src/api/modules/system/post.ts` 中定义请求。

**post.ts**

```typescript
import { request } from '@/api/request';

export interface PostDTO {
  id?: number;
  title: string;
  content?: string;
  author?: string;
  status?: number;
  categoryId?: number;
  tags?: string[];
  coverUrl?: string;
  summary?: string;
}

export interface PostQueryDTO {
  title?: string;
  author?: string;
  status?: number;
  categoryId?: number;
  startDate?: string;
  endDate?: string;
}

export interface PageResult<T> {
  records: T[];
  total: number;
  current: number;
  size: number;
}

/**
 * 分页查询文章
 */
export function getPostPage(params: PostQueryDTO & { page: number; size: number }) {
  return request.get<PageResult<PostDTO>>({ url: '/posts', params });
}

/**
 * 获取文章详情
 */
export function getPostById(id: number) {
  return request.get<PostDTO>({ url: `/posts/${id}` });
}

/**
 * 创建文章
 */
export function createPost(data: PostDTO) {
  return request.post({ url: '/posts', data });
}

/**
 * 更新文章
 */
export function updatePost(data: PostDTO) {
  return request.put({ url: '/posts', data });
}

/**
 * 删除文章
 */
export function deletePost(id: number) {
  return request.delete({ url: `/posts/${id}` });
}

/**
 * 批量删除文章
 */
export function batchDeletePost(ids: number[]) {
  return request.delete({ url: '/posts/batch', data: ids });
}

/**
 * 更新文章状态
 */
export function updatePostStatus(id: number, status: number) {
  return request.put({ url: `/posts/${id}/status`, params: { status } });
}

/**
 * 批量更新文章状态
 */
export function batchUpdatePostStatus(ids: number[], status: number) {
  return request.put({ url: '/posts/status/batch', data: ids, params: { status } });
}
```

**关键要点：**

- 定义清晰的 TypeScript 接口类型
- 所有 API 方法都有明确的类型注解
- 批量操作提供单独的接口方法
- 状态管理提供独立的更新方法

### 2. 创建列表页面

创建 `frontend/apps/tagtag/src/views/modules/system/post/index.vue`。

```vue
<script setup lang="ts">
import { ref, reactive } from 'vue';
import { useTable } from '@vben/plugins/vxe-table';
import { getPostPage, deletePost, addPost, updatePost } from '@/api/modules/system/post';
import { Button, Tag, Modal } from 'ant-design-vue';
import FormModal from './FormModal.vue';

// 表格配置
const [Grid, gridApi] = useTable({
  api: getPostPage,
  columns: [
    { type: 'checkbox', width: 50 },
    { field: 'title', title: '标题' },
    { field: 'status', title: '状态', slots: { default: 'status' } },
    { field: 'createTime', title: '创建时间', width: 180 },
    { title: '操作', slots: { default: 'action' }, width: 150 },
  ],
  formConfig: {
    items: [
      { field: 'title', label: '标题', component: 'Input' },
      { 
        field: 'status', 
        label: '状态', 
        component: 'Select',
        componentProps: {
          options: [
            { label: '已发布', value: 1 },
            { label: '草稿', value: 0 }
          ]
        }
      }
    ]
  },
  toolbarConfig: {
    buttons: [
      { code: 'add', name: '新增', status: 'primary' },
      { code: 'delete', name: '删除', status: 'danger' }
    ]
  }
});

// 弹窗配置
const modalVisible = ref(false);
const modalTitle = ref('');
const formData = reactive({});
const isEdit = ref(false);

// 打开新增弹窗
function handleAdd() {
  isEdit.value = false;
  modalTitle.value = '新增文章';
  Object.assign(formData, {});
  modalVisible.value = true;
}

// 打开编辑弹窗
function handleEdit(row) {
  isEdit.value = true;
  modalTitle.value = '编辑文章';
  Object.assign(formData, row);
  modalVisible.value = true;
}

// 删除单个文章
async function handleDelete(row) {
  Modal.confirm({
    title: '确认删除',
    content: `确定要删除文章 "${row.title}" 吗？`,
    onOk: async () => {
      await deletePost([row.id]);
      gridApi.refresh();
    }
  });
}

// 批量删除
async function handleBatchDelete(ids) {
  Modal.confirm({
    title: '确认删除',
    content: `确定要删除选中的 ${ids.length} 篇文章吗？`,
    onOk: async () => {
      await deletePost(ids);
      gridApi.refresh();
    }
  });
}

// 保存文章
async function handleSave(data) {
  if (isEdit.value) {
    await updatePost(data);
  } else {
    await addPost(data);
  }
  modalVisible.value = false;
  gridApi.refresh();
}

// 监听工具栏按钮点击
function handleToolbarClick(button) {
  if (button.code === 'add') {
    handleAdd();
  } else if (button.code === 'delete') {
    const selectedRows = gridApi.getSelectedRows();
    if (selectedRows.length === 0) {
      Modal.warning({ title: '提示', content: '请选择要删除的文章' });
      return;
    }
    handleBatchDelete(selectedRows.map(row => row.id));
  }
}
</script>

<template>
  <Grid @toolbar-click="handleToolbarClick">
    <template #status="{ row }">
      <Tag :color="row.status === 1 ? 'green' : 'red'">
        {{ row.status === 1 ? '已发布' : '草稿' }}
      </Tag>
    </template>
    <template #action="{ row }">
      <Button type="link" @click="handleEdit(row)">编辑</Button>
      <Button type="link" danger @click="handleDelete(row)">删除</Button>
    </template>
  </Grid>

  <!-- 新增/编辑弹窗 -->
  <FormModal
    v-model:visible="modalVisible"
    :title="modalTitle"
    :form-data="formData"
    @save="handleSave"
  />
</template>
```

### 3. 创建表单弹窗组件

创建 `frontend/apps/tagtag/src/views/modules/system/post/FormModal.vue`。

```vue
<script setup lang="ts">
import { ref, reactive, watch } from 'vue';
import { Modal, Form, Input, Select, Switch } from 'ant-design-vue';

// Props
const props = defineProps({
  visible: {
    type: Boolean,
    default: false
  },
  title: {
    type: String,
    default: ''
  },
  formData: {
    type: Object,
    default: () => ({})
  }
});

// Emits
const emit = defineEmits(['update:visible', 'save']);

// 表单实例
const formRef = ref();

// 表单模型
const formModel = reactive({
  id: null,
  title: '',
  content: '',
  status: 1
});

// 监听表单数据变化
watch(
  () => props.formData,
  (newData) => {
    Object.assign(formModel, newData);
  },
  { deep: true, immediate: true }
);

// 关闭弹窗
function handleCancel() {
  emit('update:visible', false);
  formRef.value?.resetFields();
}

// 提交表单
async function handleSubmit() {
  if (!formRef.value) return;
  
  try {
    await formRef.value.validate();
    emit('save', { ...formModel });
    emit('update:visible', false);
  } catch (error) {
    console.error('表单验证失败:', error);
  }
}
</script>

<template>
  <Modal
    v-model:open="visible"
    :title="title"
    ok-text="保存"
    cancel-text="取消"
    @ok="handleSubmit"
    @cancel="handleCancel"
    width="800px"
  >
    <Form
      ref="formRef"
      :model="formModel"
      layout="vertical"
      :rules="{
        title: [{ required: true, message: '请输入文章标题', trigger: 'blur' }],
        content: [{ required: true, message: '请输入文章内容', trigger: 'blur' }]
      }"
    >
      <Form.Item name="id" hidden>
        <Input v-model:value="formModel.id" />
      </Form.Item>
      
      <Form.Item label="文章标题" name="title">
        <Input v-model:value="formModel.title" placeholder="请输入文章标题" />
      </Form.Item>
      
      <Form.Item label="文章内容" name="content">
        <Input.TextArea 
          v-model:value="formModel.content" 
          placeholder="请输入文章内容"
          rows="6"
        />
      </Form.Item>
      
      <Form.Item label="发布状态" name="status">
        <Switch 
          v-model:checked="formModel.status" 
          checked-children="已发布" 
          un-checked-children="草稿"
        />
      </Form.Item>
    </Form>
  </Modal>
</template>
```

### 3. 配置菜单

1. 启动项目，登录管理员账号。
2. 进入 **系统管理 -> 菜单管理**。
3. 新增菜单 “文章管理”，路由地址填 `/system/post`，组件路径填 `modules/system/post/index.vue`。
4. 刷新页面，即可看到新功能。

---

## 第三步：测试用例编写

### 1. 后端单元测试

为了确保代码质量和功能正确性，我们需要为后端服务编写单元测试。Tagtag Starter 使用 JUnit 5 和 Mockito 进行单元测试。

#### 1.1 准备测试环境

首先，确保在 `pom.xml` 中添加了必要的测试依赖：

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>
```

#### 1.2 编写 Service 层测试

创建 `PostServiceImplTest.java` 文件，位于 `src/test/java` 目录下：

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.assertj.core.api.Assertions.assertThat;

@ExtendWith(MockitoExtension.class)
class PostServiceImplTest {

    @Mock
    private PostMapper postMapper;

    @InjectMocks
    private PostServiceImpl postService;

    @Test
    void testPage() {
        // 准备测试数据
        PostQuery query = new PostQuery();
        query.setPage(1);
        query.setSize(10);
        query.setTitle("测试");

        // 模拟分页结果
        Page<PostEntity> page = new Page<>(1, 10);
        List<PostEntity> records = new ArrayList<>();
        records.add(new PostEntity(1L, "测试文章", "内容", 1));
        page.setRecords(records);
        page.setTotal(1);

        // 设置 Mock 行为
        when(postMapper.selectPage(any(Page.class), any(LambdaQueryWrapper.class))).thenReturn(page);

        // 执行测试
        PageResult<PostEntity> result = postService.page(query);

        // 验证结果
        assertThat(result).isNotNull();
        assertThat(result.getTotal()).isEqualTo(1);
        assertThat(result.getRecords()).hasSize(1);
        assertThat(result.getRecords().get(0).getTitle()).isEqualTo("测试文章");
    }

    @Test
    void testSave() {
        // 准备测试数据
        PostDTO dto = new PostDTO();
        dto.setTitle("测试文章");
        dto.setContent("内容");
        dto.setStatus(1);

        // 设置 Mock 行为
        when(postMapper.insert(any(PostEntity.class))).thenReturn(1);

        // 执行测试
        postService.save(dto);

        // 验证结果（可以添加更多验证）
        Mockito.verify(postMapper, times(1)).insert(any(PostEntity.class));
    }

    @Test
    void testUpdate() {
        // 准备测试数据
        PostDTO dto = new PostDTO();
        dto.setId(1L);
        dto.setTitle("更新测试文章");
        dto.setContent("更新内容");
        dto.setStatus(0);

        // 设置 Mock 行为
        when(postMapper.updateById(any(PostEntity.class))).thenReturn(1);

        // 执行测试
        postService.update(dto);

        // 验证结果
        Mockito.verify(postMapper, times(1)).updateById(any(PostEntity.class));
    }

    @Test
    void testDelete() {
        // 准备测试数据
        List<Long> ids = Arrays.asList(1L, 2L, 3L);

        // 设置 Mock 行为
        when(postMapper.deleteBatchIds(ids)).thenReturn(3);

        // 执行测试
        postService.delete(ids);

        // 验证结果
        Mockito.verify(postMapper, times(1)).deleteBatchIds(ids);
    }
}
```

### 2. 前端测试

前端测试包括单元测试和集成测试，Tagtag Starter 使用 Vitest 进行单元测试，使用 Cypress 进行 E2E 测试。

#### 2.1 编写 API 测试

创建 `post.test.ts` 文件，位于 `frontend/apps/tagtag/src/api/modules/system/__tests__` 目录下：

```typescript
import { describe, it, expect, vi } from 'vitest';
import { getPostPage, addPost, updatePost, deletePost } from '../post';
import { request } from '@/api/request';

// 模拟 request 模块
vi.mock('@/api/request', () => ({
  request: {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn()
  }
}));

describe('Post API', () => {
  it('getPostPage should call request.get with correct params', async () => {
    // 准备测试数据
    const params = { page: 1, size: 10, title: 'test' };
    const mockResponse = { data: { records: [], total: 0 } };
    
    // 设置模拟返回值
    (request.get as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await getPostPage(params);
    
    // 验证结果
    expect(request.get).toHaveBeenCalledWith({ url: '/posts', params });
    expect(result).toEqual(mockResponse);
  });
  
  it('addPost should call request.post with correct data', async () => {
    // 准备测试数据
    const data = { title: 'test', content: 'test content', status: 1 };
    const mockResponse = { data: { success: true } };
    
    // 设置模拟返回值
    (request.post as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await addPost(data);
    
    // 验证结果
    expect(request.post).toHaveBeenCalledWith({ url: '/posts', data });
    expect(result).toEqual(mockResponse);
  });
  
  it('updatePost should call request.put with correct data', async () => {
    // 准备测试数据
    const data = { id: 1, title: 'updated', content: 'updated content', status: 0 };
    const mockResponse = { data: { success: true } };
    
    // 设置模拟返回值
    (request.put as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await updatePost(data);
    
    // 验证结果
    expect(request.put).toHaveBeenCalledWith({ url: '/posts', data });
    expect(result).toEqual(mockResponse);
  });
  
  it('deletePost should call request.delete with correct ids', async () => {
    // 准备测试数据
    const ids = [1, 2, 3];
    const mockResponse = { data: { success: true } };
    
    // 设置模拟返回值
    (request.delete as vi.Mock).mockResolvedValue(mockResponse);
    
    // 执行测试
    const result = await deletePost(ids);
    
    // 验证结果
    expect(request.delete).toHaveBeenCalledWith({ url: '/posts', data: ids });
    expect(result).toEqual(mockResponse);
  });
});
```

#### 2.2 编写组件测试

创建 `index.test.ts` 文件，位于 `frontend/apps/tagtag/src/views/modules/system/post/__tests__` 目录下：

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import PostIndex from '../index.vue';
import { useTable } from '@vben/plugins/vxe-table';

// 模拟依赖
vi.mock('@vben/plugins/vxe-table', () => ({
  useTable: vi.fn(() => [
    // 模拟 Grid 组件
    { template: '<div></div>' },
    // 模拟 gridApi
    {
      refresh: vi.fn(),
      getSelectedRows: vi.fn(() => [])
    }
  ])
}));

describe('PostIndex Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(PostIndex);
    expect(wrapper.exists()).toBe(true);
  });
  
  it('should call handleAdd when add button is clicked', async () => {
    // 模拟 handleAdd 方法
    const handleAdd = vi.fn();
    const wrapper = mount(PostIndex, {
      global: {
        stubs: {
          Grid: { template: '<div @toolbar-click="$emit(\'toolbar-click\', $event)"></div>' },
          FormModal: { template: '<div></div>' }
        }
      }
    });
    
    // 触发工具栏点击事件
    await wrapper.findComponent({ name: 'Grid' }).vm.$emit('toolbar-click', { code: 'add' });
    
    // 验证 handleAdd 被调用
    // 这里可以根据实际实现添加更详细的验证
    expect(wrapper.vm.modalVisible).toBe(true);
  });
});
```

## 总结

通过以上步骤，您已经成功开发了一个包含前后端交互的完整 CRUD 模块，并编写了相应的测试用例。Tagtag Starter 的模块化设计让这一切变得清晰且规范。

### 开发流程回顾

1. **后端开发**：

   - 数据库设计
   - 定义契约（DTO、Query）
   - 持久层实现（Entity、Mapper）
   - 业务层实现（Service）
   - 控制层实现（Controller）
   - 编写单元测试
2. **前端开发**：

   - 定义 API 请求
   - 创建列表页面
   - 创建表单弹窗组件
   - 配置菜单
   - 编写 API 测试和组件测试
3. **部署和验证**：

   - 启动前后端服务
   - 登录系统验证功能
   - 执行测试用例

通过遵循这个流程，您可以快速、高效地开发出高质量的 CRUD 功能模块。


# 代码规范与最佳实践

良好的代码规范是保证代码质量、提高开发效率、减少维护成本的重要手段。本文档总结了 Tagtag Starter 项目的代码规范和最佳实践，包括 Java 后端和 TypeScript 前端的编码规范、命名约定和代码审查标准。

## 1. 通用原则

无论使用哪种编程语言，以下通用原则都应遵循：

### 1.1 代码可读性优先

- 代码是写给人看的，不是写给机器看的
- 保持代码简洁、清晰、易于理解
- 使用有意义的命名，避免缩写和隐晦的名称
- 适当添加注释，但不要过度注释

### 1.2 一致性

- 遵循项目已有的代码风格
- 保持缩进、换行、空格等格式一致
- 统一使用一种命名风格

### 1.3 模块化

- 将代码拆分为可复用的模块
- 每个模块职责单一
- 模块间依赖关系清晰

### 1.4 测试优先

- 编写可测试的代码
- 为核心功能编写单元测试
- 遵循测试驱动开发（TDD）原则

### 1.5 安全性

- 避免硬编码敏感信息
- 注意 SQL 注入、XSS 攻击等安全问题
- 遵循最小权限原则

## 2. Java 代码规范

Tagtag Starter 后端使用 Java 语言开发，遵循以下代码规范：

### 2.1 命名约定

- **类名**：使用 PascalCase，例如 `UserService`、`PostController`
- **方法名**：使用 camelCase，例如 `getUserById`、`savePost`
- **变量名**：使用 camelCase，例如 `userName`、`pageSize`
- **常量名**：使用 UPPER\_CASE\_WITH\_UNDERSCORES，例如 `MAX_PAGE_SIZE`、`DEFAULT_STATUS`
- **包名**：使用小写字母，例如 `dev.tagtag.common.util`
- **接口名**：使用 PascalCase，例如 `UserService`、`PostMapper`

**实际项目示例：**

```java
// 类名示例
@Service
public class UserServiceImpl implements UserService { }

@RestController
@RequestMapping("/users")
public class UserController { }

// 方法名示例
public UserDTO getUserById(Long userId) { }
public PageResult<UserDTO> pageUsers(UserQuery query) { }
public void createUser(UserDTO user) { }
public void updateUser(UserDTO user) { }
public void deleteUser(Long userId) { }

// 常量示例
private static final int MAX_PAGE_SIZE = 100;
private static final String DEFAULT_AVATAR = "/default-avatar.png";
private static final Integer STATUS_ACTIVE = 1;
```

### 2.2 代码格式

- **缩进**：使用 4 个空格进行缩进
- **换行**：每行不超过 120 个字符
- **空行**：在方法之间、代码块之间添加适当的空行
- **括号**：左括号 `{` 与语句同一行，右括号 `}` 单独一行
- **空格**：


  - 运算符前后添加空格，例如 `a = b + c`
  - 逗号、分号后添加空格，例如 `method(a, b, c)`
  - 括号内不添加空格，例如 `method(a, b)` 而非 `method( a, b )`

### 2.3 注释规范

- **类注释**：使用 Javadoc 注释，说明类的用途、作者、创建日期等
  ```java
  /**
   * 用户服务类，负责用户相关业务逻辑
   *
   * @author Tagtag Starter Team
   * @since 2024-01-01
   */
  @Service
  public class UserService {
      // 类实现
  }
  ```
- **方法注释**：使用 Javadoc 注释，说明方法的用途、参数、返回值、异常等
  ```java
  /**
   * 根据用户 ID 获取用户信息
   *
   * @param userId 用户 ID
   * @return 用户信息
   * @throws BusinessException 如果用户不存在
   */
  public UserDTO getUserById(Long userId) {
      // 方法实现
  }
  ```
- **行注释**：使用 `//` 注释，说明复杂逻辑或特殊处理
  ```java
  // 处理特殊情况：当用户未设置头像时，使用默认头像
  if (user.getAvatar() == null) {
      user.setAvatar(DEFAULT_AVATAR);
  }
  ```

### 2.4 最佳实践

- **使用 Lombok 简化代码**：使用 `@Data`、`@NoArgsConstructor`、`@AllArgsConstructor` 等注解简化 POJO 类
  ```java
  @Data
  @NoArgsConstructor
  @AllArgsConstructor
  public class UserDTO {
      private Long id;
      private String username;
      private String email;
      private Integer status;
  }
  ```
- **避免魔法数字**：将常量定义为静态常量，例如 `private static final int MAX_RETRY = 3`
  ```java
  // 不推荐
  if (user.getStatus() == 1) { }

  // 推荐
  private static final Integer STATUS_ACTIVE = 1;
  if (user.getStatus().equals(STATUS_ACTIVE)) { }
  ```
- **使用 Optional 处理 null**：避免直接使用 null，使用 Optional 包装可能为 null 的值
  ```java
  // 不推荐
  User user = userMapper.selectById(userId);
  if (user != null) {
      return user.getName();
  }
  return null;

  // 推荐
  return Optional.ofNullable(userMapper.selectById(userId))
      .map(User::getName)
      .orElse(null);
  ```
- **使用 try-with-resources 管理资源**：自动关闭资源，避免内存泄漏
  ```java
  try (InputStream is = new FileInputStream(file)) {
      // 处理文件
  } catch (IOException e) {
      log.error("文件读取失败", e);
  }
  ```
- **遵循 SOLID 原则**：

  - 单一职责原则：一个类只负责一个功能
  - 开放封闭原则：对扩展开放，对修改封闭
  - 里氏替换原则：子类可以替换父类
  - 接口隔离原则：使用多个专门的接口，而不是一个总接口
  - 依赖倒置原则：依赖抽象，不依赖具体实现

### 2.5 Spring Boot 最佳实践

- **使用构造函数注入**：避免使用字段注入，提高可测试性
  ```java
  @Service
  @RequiredArgsConstructor
  public class UserServiceImpl implements UserService {
      private final UserMapper userMapper;
      private final RoleService roleService;
      
      @Override
      public UserDTO getUserById(Long userId) {
          User user = userMapper.selectById(userId);
          return BeanUtil.copyProperties(user, UserDTO.class);
      }
  }
  ```
- **使用 @RestController 替代 @Controller + @ResponseBody**：简化 REST 接口开发
  ```java
  @RestController
  @RequestMapping("/users")
  @RequiredArgsConstructor
  public class UserController {
      private final UserService userService;
      
      @GetMapping("/{id}")
      @Operation(summary = "获取用户详情")
      @PreAuthorize("@ss.hasPermission('system:user:query')")
      public Result<UserDTO> getById(@PathVariable Long id) {
          return Result.ok(userService.getById(id));
      }
  }
  ```
- **使用 @ExceptionHandler 处理异常**：统一处理异常，提高代码可读性
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      
      @ExceptionHandler(BusinessException.class)
      public Result<Void> handleBusinessException(BusinessException e) {
          log.error("业务异常", e);
          return Result.fail(e.getMessage());
      }
      
      @ExceptionHandler(Exception.class)
      public Result<Void> handleException(Exception e) {
          log.error("系统异常", e);
          return Result.fail("系统错误，请联系管理员");
      }
  }
  ```
- **使用 @Validated 进行参数校验**：自动校验请求参数，减少重复代码
  ```java
  @PostMapping
  @Operation(summary = "创建用户")
  public Result<Void> create(@Valid @RequestBody UserDTO dto) {
      userService.create(dto);
      return Result.okMsg("创建成功");
  }

  // DTO 定义
  @Data
  public class UserDTO {
      @NotBlank(message = "用户名不能为空")
      private String username;
      
      @Email(message = "邮箱格式不正确")
      private String email;
      
      @NotNull(message = "状态不能为空")
      private Integer status;
  }
  ```
- **使用 @Transactional 管理事务**：明确事务边界，确保数据一致性
  ```java
  @Override
  @Transactional(rollbackFor = Exception.class)
  public void createUserWithRoles(UserDTO user, List<Long> roleIds) {
      // 创建用户
      userService.create(user);
      
      // 分配角色
      if (CollectionUtils.isNotEmpty(roleIds)) {
          userRoleService.assignRoles(user.getId(), roleIds);
      }
  }
  ```

### 2.6 MyBatis-Plus 最佳实践

- **使用 LambdaQueryWrapper 避免硬编码字段名**：提高代码可维护性
  ```java
  // 不推荐
  LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
  wrapper.eq("username", username);

  // 推荐
  LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<>();
  wrapper.eq(User::getUsername, username);
  ```
- **使用分页插件**：统一分页查询
  ```java
  @Override
  public PageResult<UserDTO> page(UserQuery query, PageQuery pageQuery) {
      IPage<UserVO> page = new Page<>(pageQuery.getPage(), pageQuery.getSize());
      IPage<UserVO> result = userMapper.selectPage(page, query);
      
      return PageResult.of(
          result.getRecords().stream()
              .map(vo -> BeanUtil.copyProperties(vo, UserDTO.class))
              .toList(),
          result.getTotal()
      );
  }
  ```
- **使用 @TableLogic 实现逻辑删除**：避免物理删除数据
  ```java
  @Data
  @TableName("sys_user")
  public class User {
      @TableId
      private Long id;
      
      private String username;
      
      @TableLogic
      private Integer deleted;
  }
  ```

## 3. TypeScript 代码规范

Tagtag Starter 前端使用 TypeScript 语言开发，遵循以下代码规范：

### 3.1 命名约定

- **组件名**：使用 PascalCase，例如 `PostList`、`FormModal`
- **变量名**：使用 camelCase，例如 `userName`、`isLoading`
- **函数名**：使用 camelCase，例如 `getUserInfo`、`handleSubmit`
- **常量名**：使用 UPPER\_CASE\_WITH\_UNDERSCORES，例如 `MAX_PAGE_SIZE`、`API_BASE_URL`
- **类型名**：使用 PascalCase，例如 `UserDTO`、`PostQuery`
- **接口名**：使用 PascalCase，例如 `UserService`、`PostApi`

**实际项目示例：**

```typescript
// 组件名示例
export default defineComponent({
  name: 'UserList'
});

// 变量名示例
const userName = ref('');
const isLoading = ref(false);
const userList = ref<UserDTO[]>([]);

// 函数名示例
function getUserInfo() { }
function handleSubmit() { }
function handleDelete() { }

// 常量名示例
const MAX_PAGE_SIZE = 100;
const API_BASE_URL = '/api';
const STATUS_ACTIVE = 1;

// 类型名示例
interface UserDTO {
  id?: number;
  username: string;
  email?: string;
  status?: number;
}

interface PostQuery {
  title?: string;
  status?: number;
  page: number;
  size: number;
}
```

### 3.2 代码格式

- **缩进**：使用 2 个空格进行缩进
- **换行**：每行不超过 120 个字符
- **空行**：在函数之间、代码块之间添加适当的空行
- **括号**：左括号 `{` 与语句同一行，右括号 `}` 单独一行
- **空格**：


  - 运算符前后添加空格，例如 `a = b + c`
  - 逗号、分号后添加空格，例如 `method(a, b, c)`
  - 括号内不添加空格，例如 `method(a, b)` 而非 `method( a, b )`

### 3.3 注释规范

- **组件注释**：使用 JSDoc 注释，说明组件的用途、属性、事件等
  ```typescript
  /**
   * 文章列表组件，展示文章列表并提供筛选、排序功能
   *
   * @component
   * @param {Object} props - 组件属性
   * @param {Function} onEdit - 编辑文章回调函数
   * @param {Function} onDelete - 删除文章回调函数
   */
  export default defineComponent({
      // 组件实现
  });
  ```
- **函数注释**：使用 JSDoc 注释，说明函数的用途、参数、返回值等
  ```typescript
  /**
   * 获取文章列表
   *
   * @param {PostQuery} params - 查询参数
   * @returns {Promise<PageResult<PostDTO>>} 文章列表
   */
  export function getPostList(params: PostQuery): Promise<PageResult<PostDTO>> {
      // 函数实现
  }
  ```
- **行注释**：使用 `//` 注释，说明复杂逻辑或特殊处理
  ```typescript
  // 处理特殊情况：当文章状态为 0 时，显示为草稿
  const statusText = status === 1 ? '已发布' : '草稿';
  ```

### 3.4 最佳实践

- **使用 TypeScript 严格模式**：启用 `strict: true` 配置，提高类型安全性
  ```typescript
  // tsconfig.json
  {
    "compilerOptions": {
      "strict": true,
      "noImplicitAny": true,
      "strictNullChecks": true
    }
  }
  ```
- **避免 any 类型**：尽量使用具体类型，提高代码可靠性
  ```typescript
  // 不推荐
  function getUser(id: any): any {
    return request.get({ url: `/users/${id}` });
  }

  // 推荐
  function getUser(id: number): Promise<UserDTO> {
    return request.get<UserDTO>({ url: `/users/${id}` });
  }
  ```
- **使用接口定义数据结构**：明确数据类型，提高代码可读性
  ```typescript
  interface UserDTO {
    id?: number;
    username: string;
    email?: string;
    status?: number;
    createTime?: string;
  }

  interface PageResult<T> {
    records: T[];
    total: number;
    current: number;
    size: number;
  }

  interface UserQuery {
    username?: string;
    status?: number;
    page: number;
    size: number;
  }
  ```
- **使用 const 替代 let**：除非需要重新赋值，否则使用 const
  ```typescript
  // 不推荐
  let userName = 'admin';
  let status = 1;

  // 推荐
  const userName = 'admin';
  const status = 1;

  // 需要重新赋值时使用 let
  let currentPage = 1;
  currentPage++;
  ```
- **使用箭头函数**：简化函数定义，避免 this 指向问题
  ```typescript
  // 不推荐
  const handleClick = function() {
    console.log('clicked');
  };

  // 推荐
  const handleClick = () => {
    console.log('clicked');
  };
  ```
- **使用解构赋值**：简化变量赋值，提高代码可读性
  ```typescript
  // 不推荐
  const user = response.data;
  const id = user.id;
  const name = user.name;

  // 推荐
  const { id, name } = response.data;

  // 数组解构
  const [first, second] = [1, 2, 3];
  ```
- **使用模板字符串**：简化字符串拼接
  ```typescript
  // 不推荐
  const url = '/api/users/' + userId + '/roles/' + roleId;

  // 推荐
  const url = `/api/users/${userId}/roles/${roleId}`;
  ```
- **使用可选链操作符**：安全访问嵌套属性
  ```typescript
  // 不推荐
  const userName = user && user.profile && user.profile.name;

  // 推荐
  const userName = user?.profile?.name;
  ```
- **使用空值合并操作符**：提供默认值
  ```typescript
  // 不推荐
  const userName = user.name || 'Unknown';

  // 推荐
  const userName = user.name ?? 'Unknown';
  ```

### 3.5 Vue 3 最佳实践

- **使用 Composition API**：利用 setup 语法糖，提高代码组织性和复用性
  ```vue
  <script setup lang="ts">
  import { ref, computed, onMounted } from 'vue';
  import { getUserList } from '@/api/modules/system/user';

  const userList = ref<UserDTO[]>([]);
  const loading = ref(false);

  const activeUsers = computed(() => 
    userList.value.filter(user => user.status === 1)
  );

  async function loadData() {
    loading.value = true;
    try {
      const result = await getUserList({ page: 1, size: 10 });
      userList.value = result.records;
    } finally {
      loading.value = false;
    }
  }

  onMounted(() => {
    loadData();
  });
  </script>
  ```
- **使用 defineProps 和 defineEmits**：简化组件属性和事件定义
  ```typescript
  const props = defineProps<{
    title: string;
    visible: boolean;
    formData?: UserDTO;
  }>();

  const emit = defineEmits<{
    (e: 'update:visible', value: boolean): void;
    (e: 'save', data: UserDTO): void;
    (e: 'cancel'): void;
  }>();

  // 使用 props
  console.log(props.title);

  // 触发事件
  emit('save', formData);
  ```
- **使用 watch 和 watchEffect 监听数据变化**
  ```typescript
  // watch：监听特定数据源
  watch(
    () => props.visible,
    (newVal) => {
      if (newVal) {
        // 弹窗打开时的处理
      }
    }
  );

  // watchEffect：自动追踪依赖
  watchEffect(() => {
    console.log(`用户列表长度: ${userList.value.length}`);
  });

  // 监听多个数据源
  watch([page, size], ([newPage, newSize]) => {
    loadData();
  });
  ```
- **使用 provide/inject 进行组件间通信**：避免 props 层层传递
  ```typescript
  // 父组件
  provide('userService', {
    getUserList,
    createUser,
    updateUser
  });

  // 子组件
  const userService = inject('userService');
  await userService?.getUserList({ page: 1, size: 10 });
  ```
- **使用 Teleport 处理模态框**：优化模态框定位和样式
  ```vue
  <template>
    <Teleport to="body">
      <Modal v-model:open="visible" title="用户信息">
        <!-- 模态框内容 -->
      </Modal>
    </Teleport>
  </template>
  ```
- **使用 Suspense 处理异步组件**：提供加载状态和错误处理
  ```vue
  <template>
    <Suspense>
      <template #default>
        <AsyncComponent />
      </template>
      <template #fallback>
        <div>加载中...</div>
      </template>
    </Suspense>
  </template>
  ```
- **使用 vben-table 表格组件**：统一表格开发规范
  ```typescript
  import { useTable } from '@vben/plugins/vxe-table';

  const [Grid, gridApi] = useTable({
    api: getUserList,
    columns: [
      { type: 'checkbox', width: 50 },
      { field: 'username', title: '用户名' },
      { field: 'email', title: '邮箱' },
      { field: 'status', title: '状态', slots: { default: 'status' } },
      { title: '操作', slots: { default: 'action' }, width: 150 }
    ],
    formConfig: {
      items: [
        { field: 'username', label: '用户名', component: 'Input' },
        { field: 'status', label: '状态', component: 'Select' }
      ]
    }
  });
  ```
- **使用 Pinia 进行状态管理**：替代 Vuex，简化状态管理
  ```typescript
  // stores/user.ts
  import { defineStore } from 'pinia';

  export const useUserStore = defineStore('user', {
    state: () => ({
      currentUser: null as UserDTO | null,
      token: ''
    }),
    getters: {
      isLoggedIn: (state) => !!state.token,
      userName: (state) => state.currentUser?.username || ''
    },
    actions: {
      async login(username: string, password: string) {
        const result = await login({ username, password });
        this.token = result.token;
        this.currentUser = result.user;
      },
      logout() {
        this.token = '';
        this.currentUser = null;
      }
    }
  });

  // 使用 store
  const userStore = useUserStore();
  await userStore.login('admin', '123456');
  console.log(userStore.userName);
  ```
- **使用 composables 复用逻辑**：提取可复用的逻辑
  ```typescript
  // composables/useTableData.ts
  export function useTableData<T>(api: Function) {
    const data = ref<T[]>([]);
    const loading = ref(false);
    const total = ref(0);
    
    async function loadData(params: any) {
      loading.value = true;
      try {
        const result = await api(params);
        data.value = result.records;
        total.value = result.total;
      } finally {
        loading.value = false;
      }
    }
    
    return { data, loading, total, loadData };
  }

  // 使用 composable
  const { data, loading, total, loadData } = useTableData<UserDTO>(getUserList);
  ```

## 4. 命名约定

### 4.1 包/模块命名

- **Java 包名**：使用小写字母，例如 `dev.tagtag.common.util`
- **TypeScript 模块名**：使用小写字母，例如 `@/api/modules/system/post`
- **目录名**：使用 kebab-case，例如 `user-management`、`post-list`

### 4.2 类/接口命名

- **Java 类名**：使用 PascalCase，例如 `UserService`、`PostController`
- **TypeScript 类型名**：使用 PascalCase，例如 `UserDTO`、`PostQuery`
- **接口名**：使用 PascalCase，例如 `UserRepository`、`PostService`

### 4.3 方法命名

- **获取数据**：使用 `get` 或 `find` 前缀，例如 `getUserById`、`findPosts`
- **保存数据**：使用 `save` 或 `create` 前缀，例如 `saveUser`、`createPost`
- **更新数据**：使用 `update` 前缀，例如 `updateUser`、`updatePost`
- **删除数据**：使用 `delete` 前缀，例如 `deleteUser`、`deletePost`
- **查询列表**：使用 `list` 或 `page` 前缀，例如 `listUsers`、`pagePosts`
- **处理事件**：使用 `handle` 前缀，例如 `handleSubmit`、`handleDelete`

**实际项目示例：**

```java
// 后端方法命名示例
public interface UserService {
    UserDTO getUserById(Long userId);
    PageResult<UserDTO> pageUsers(UserQuery query);
    List<UserDTO> listActiveUsers();
    void createUser(UserDTO user);
    void updateUser(UserDTO user);
    void deleteUser(Long userId);
    void batchDeleteUsers(List<Long> ids);
    void updateUserStatus(Long userId, Integer status);
    boolean existsByUsername(String username);
}
```

```typescript
// 前端方法命名示例
export function getUserById(id: number): Promise<UserDTO> { }
export function getUserList(params: UserQuery): Promise<PageResult<UserDTO>> { }
export function createUser(data: UserDTO): Promise<void> { }
export function updateUser(data: UserDTO): Promise<void> { }
export function deleteUser(id: number): Promise<void> { }
export function batchDeleteUsers(ids: number[]): Promise<void> { }
export function updateUserStatus(id: number, status: number): Promise<void> { }

// 事件处理方法命名示例
function handleSubmit() { }
function handleEdit(row: UserDTO) { }
function handleDelete(id: number) { }
function handleBatchDelete(ids: number[]) { }
function handleStatusChange(id: number, status: number) { }
function handlePageChange(page: number) { }
function handleSearch() { }
function handleReset() { }
```

### 4.4 变量命名

- **布尔变量**：使用 `is` 或 `has` 前缀，例如 `isLoading`、`hasPermission`
- **数组变量**：使用复数形式，例如 `users`、`posts`
- **集合变量**：使用具体集合类型，例如 `userList`、`postMap`
- **常量变量**：使用 UPPER\_CASE\_WITH\_UNDERSCORES，例如 `MAX_PAGE_SIZE`、`DEFAULT_AVATAR`

**实际项目示例：**

```java
// 后端变量命名示例
private boolean isLoading;
private boolean hasPermission;
private boolean isDeleted;
private boolean isActive;

private List<UserDTO> users;
private List<PostDTO> posts;
private List<RoleDTO> roles;

private Map<Long, UserDTO> userMap;
private Map<String, RoleDTO> roleMap;

private static final int MAX_PAGE_SIZE = 100;
private static final int DEFAULT_PAGE_SIZE = 10;
private static final String DEFAULT_AVATAR = "/default-avatar.png";
private static final Integer STATUS_ACTIVE = 1;
private static final Integer STATUS_INACTIVE = 0;
```

```typescript
// 前端变量命名示例
const isLoading = ref(false);
const hasPermission = ref(false);
const isModalVisible = ref(false);
const isFormValid = ref(false);

const users = ref<UserDTO[]>([]);
const posts = ref<PostDTO[]>([]);
const roles = ref<RoleDTO[]>([]);

const selectedUserIds = ref<number[]>([]);
const currentPage = ref(1);
const pageSize = ref(10);

const MAX_PAGE_SIZE = 100;
const DEFAULT_PAGE_SIZE = 10;
const API_BASE_URL = '/api';
const STATUS_ACTIVE = 1;
const STATUS_INACTIVE = 0;
```

## 5. 代码审查标准

代码审查是保证代码质量的重要环节，以下是 Tagtag Starter 项目的代码审查标准：

### 5.1 审查内容

- **功能正确性**：代码是否实现了预期功能
- **代码规范**：是否遵循项目的代码规范
- **代码可读性**：代码是否易于理解和维护
- **性能**：是否存在性能问题，例如循环嵌套过深、不必要的计算等
- **安全性**：是否存在安全漏洞，例如 SQL 注入、XSS 攻击等
- **测试覆盖率**：是否为核心功能编写了测试用例
- **依赖关系**：模块间依赖关系是否清晰，是否存在循环依赖

### 5.2 审查流程

1. **提交代码前**：

   - 运行本地测试，确保所有测试通过
   - 运行代码格式化工具，例如 Prettier
   - 运行静态代码分析工具，例如 ESLint、SonarQube
2. **提交代码后**：

   - 创建 Pull Request (PR)
   - 指定至少一位 reviewer
   - 填写清晰的 PR 描述，包括功能、修改内容、测试情况等
3. **Reviewer 审查**：

   - 检查代码是否符合规范
   - 提出修改建议
   - 批准或拒绝 PR
4. **修改代码**：

   - 根据 reviewer 的建议修改代码
   - 重新运行测试和代码分析
   - 提交修改
5. **合并代码**：

   - 所有 reviewer 批准后，合并 PR
   - 删除临时分支

### 5.3 审查标准

- **必须修复的问题**：


  - 语法错误
  - 逻辑错误
  - 安全漏洞
  - 性能问题
  - 违反基本设计原则

**实际项目示例：**

```java
// 必须修复：SQL 注入漏洞
// 不推荐
String sql = "SELECT * FROM user WHERE username = '" + username + "'";
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(sql);

// 推荐
String sql = "SELECT * FROM user WHERE username = ?";
PreparedStatement stmt = connection.prepareStatement(sql);
stmt.setString(1, username);
ResultSet rs = stmt.executeQuery();
```

```java
// 必须修复：性能问题 - N+1 查询
// 不推荐
List<User> users = userMapper.selectList(null);
for (User user : users) {
    List<Role> roles = roleMapper.selectByUserId(user.getId());
    user.setRoles(roles);
}

// 推荐
List<UserVO> users = userMapper.selectUsersWithRoles();
```

```typescript
// 必须修复：XSS 漏洞
// 不推荐
div.innerHTML = userInput;

// 推荐
div.textContent = userInput;
// 或使用 DOMPurify 等库进行清理
div.innerHTML = DOMPurify.sanitize(userInput);
```

- **建议修复的问题**：


  - 代码可读性问题
  - 命名不规范
  - 注释不足
  - 重复代码
  - 可以优化的代码

**实际项目示例：**

```java
// 建议修复：命名不规范
// 不推荐
public class Usr { }
public void getUsrInfo() { }

// 推荐
public class User { }
public void getUserInfo() { }
```

```java
// 建议修复：重复代码
// 不推荐
public void createUser(UserDTO user) {
    if (user.getUsername() == null || user.getUsername().isEmpty()) {
        throw new BusinessException("用户名不能为空");
    }
    if (user.getEmail() == null || user.getEmail().isEmpty()) {
        throw new BusinessException("邮箱不能为空");
    }
}

public void updateUser(UserDTO user) {
    if (user.getUsername() == null || user.getUsername().isEmpty()) {
        throw new BusinessException("用户名不能为空");
    }
    if (user.getEmail() == null || user.getEmail().isEmpty()) {
        throw new BusinessException("邮箱不能为空");
    }
}

// 推荐
private void validateUser(UserDTO user) {
    if (StringUtils.isBlank(user.getUsername())) {
        throw new BusinessException("用户名不能为空");
    }
    if (StringUtils.isBlank(user.getEmail())) {
        throw new BusinessException("邮箱不能为空");
    }
}

public void createUser(UserDTO user) {
    validateUser(user);
}

public void updateUser(UserDTO user) {
    validateUser(user);
}
```

### 5.4 审查技巧

- **专注于代码逻辑**：不要纠结于排版等细节问题，使用自动化工具解决
- **提出具体建议**：不要只说 "这个地方不好"，要说明具体问题和改进方案
- **保持建设性**：使用积极的语言，避免指责
- **尊重作者**：理解作者的设计思路，不要轻易否定
- **学习他人代码**：从审查中学习好的设计和实现

## 6. Git 最佳实践

### 6.1 分支管理

- **主分支 (main)**：稳定的生产分支，只接收合并请求
- **开发分支 (develop)**：开发分支，包含最新的开发代码
- **功能分支 (feature/xxx)**：开发新功能的分支，从 develop 分支创建
- **修复分支 (fix/xxx)**：修复 bug 的分支，从 main 分支创建
- **发布分支 (release/xxx)**：准备发布的分支，从 develop 分支创建

### 6.2 提交规范

- **提交信息清晰**：使用简洁明了的提交信息，说明修改内容
- **提交信息格式**：
  ```text
  <type>(<scope>): <subject>

  <body>

  <footer>
  ```
  - **type**：提交类型，包括 feat(新功能)、fix(修复bug)、docs(文档)、style(样式)、refactor(重构)、test(测试)、chore(构建)等
  - **scope**：修改范围，例如 user、post、auth 等
  - **subject**：简短的提交描述，不超过 50 个字符
  - **body**：详细的提交描述，说明修改的原因和内容
  - **footer**：包含 breaking changes 或 issue 链接
- **示例**：
  ```text
  feat(user): 新增用户头像上传功能

  1. 添加头像上传接口
  2. 实现头像裁剪功能
  3. 更新用户信息页面

  Closes #123
  ```

### 6.3 提交频率

- **频繁提交**：每次提交一个小功能或修复一个小 bug
- **避免大提交**：不要一次提交大量代码，难以审查和回滚
- **保持提交原子性**：每个提交只包含一个逻辑变更

## 7. 总结

良好的代码规范和最佳实践是保证项目质量的重要基础。通过遵循本文档的规范和建议，我们可以：

- 提高代码的可读性和可维护性
- 减少 bug 和安全漏洞
- 提高开发效率和协作效率
- 降低项目的长期维护成本

希望所有开发者都能严格遵循这些规范和最佳实践，共同维护一个高质量的代码库。


# 测试指南

测试是保证软件质量的重要手段，Tagtag Starter 项目采用多层次的测试策略，包括单元测试、集成测试和 API 测试。本文档将详细介绍 Tagtag Starter 项目的测试方法、工具和最佳实践。

## 1. 测试概述

### 1.1 测试分层

Tagtag Starter 项目的测试分为以下几个层次：

| 测试类型   | 测试对象     | 测试范围  | 执行速度 | 依赖关系 |
| ------ | -------- | ----- | ---- | ---- |
| 单元测试   | 单个类/函数   | 最小单位  | 快    | 低    |
| 集成测试   | 多个模块     | 模块间交互 | 中    | 中    |
| API 测试 | REST API | 接口级   | 中    | 高    |
| E2E 测试 | 整个应用     | 端到端流程 | 慢    | 高    |

### 1.2 测试目标

- **保证功能正确性**：验证代码实现了预期功能
- **提高代码质量**：通过测试发现潜在的问题和缺陷
- **增强代码可维护性**：测试可以作为代码的文档，方便后续维护
- **支持持续集成**：自动化测试是持续集成的基础
- **减少回归问题**：防止修改代码时引入新的问题

## 2. 后端测试

Tagtag Starter 后端使用 Java 语言开发，采用 JUnit 5 和 Mockito 进行测试。

### 2.1 单元测试

单元测试是对单个类或函数的测试，验证其在隔离环境下的行为。

#### 2.1.1 测试工具

- **JUnit 5**：Java 单元测试框架
- **Mockito**：Java 模拟框架，用于模拟依赖对象
- **AssertJ**：流畅的断言库，提供更好的断言体验

#### 2.1.2 测试结构

单元测试文件通常与被测试类放在同一包下，位于 `src/test/java` 目录中。

```text
src
└── main
    └── java
        └── dev
            └── tagtag
                └── module
                    └── system
                        └── service
                            └── impl
                                └── PostServiceImpl.java
└── test
    └── java
        └── dev
            └── tagtag
                └── module
                    └── system
                        └── service
                            └── impl
                                └── PostServiceImplTest.java
```

#### 2.1.3 测试示例

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.assertj.core.api.Assertions.assertThat;

@ExtendWith(MockitoExtension.class)
class PostServiceImplTest {

    @Mock
    private PostMapper postMapper;

    @InjectMocks
    private PostServiceImpl postService;

    @Test
    void testPage() {
        // 准备测试数据
        PostQuery query = new PostQuery();
        query.setPage(1);
        query.setSize(10);
        query.setTitle("测试");

        // 模拟分页结果
        Page<PostEntity> page = new Page<>(1, 10);
        List<PostEntity> records = new ArrayList<>();
        records.add(new PostEntity(1L, "测试文章", "内容", 1));
        page.setRecords(records);
        page.setTotal(1);

        // 设置 Mock 行为
        when(postMapper.selectPage(any(Page.class), any(LambdaQueryWrapper.class))).thenReturn(page);

        // 执行测试
        PageResult<PostEntity> result = postService.page(query);

        // 验证结果
        assertThat(result).isNotNull();
        assertThat(result.getTotal()).isEqualTo(1);
        assertThat(result.getRecords()).hasSize(1);
        assertThat(result.getRecords().get(0).getTitle()).isEqualTo("测试文章");
    }
}
```

#### 2.1.4 测试最佳实践

- **测试单个方法**：每个测试方法只测试一个功能点
- **使用有意义的测试名称**：测试名称应描述测试的功能和预期结果
- **使用 Mock 隔离依赖**：使用 Mockito 模拟外部依赖，避免测试被外部因素影响
- **测试边界条件**：测试空值、边界值、异常情况等
- **保持测试简洁**：测试代码应简洁、清晰，易于理解

### 2.2 集成测试

集成测试是对多个模块的测试，验证模块间的交互是否正确。

#### 2.2.1 测试工具

- **Spring Boot Test**：Spring Boot 集成测试框架
- **TestContainers**：提供轻量级的容器化测试环境
- **H2 Database**：内存数据库，用于测试数据库操作

#### 2.2.2 测试结构

集成测试文件通常与单元测试放在同一目录中，但需要使用 `@SpringBootTest` 注解。

#### 2.2.3 测试示例

```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Transactional
class PostServiceIntegrationTest {

    @Autowired
    private PostService postService;

    @Autowired
    private PostMapper postMapper;

    @Test
    void testSaveAndGetPost() {
        // 准备测试数据
        PostDTO postDTO = new PostDTO();
        postDTO.setTitle("集成测试文章");
        postDTO.setContent("集成测试内容");
        postDTO.setStatus(1);

        // 保存文章
        postService.save(postDTO);

        // 验证文章已保存
        List<PostEntity> posts = postMapper.selectList(null);
        assertThat(posts).hasSize(1);
        assertThat(posts.get(0).getTitle()).isEqualTo("集成测试文章");

        // 分页查询文章
        PostQuery query = new PostQuery();
        query.setPage(1);
        query.setSize(10);
        query.setTitle("集成测试");

        PageResult<PostEntity> result = postService.page(query);
        assertThat(result).isNotNull();
        assertThat(result.getTotal()).isEqualTo(1);
        assertThat(result.getRecords()).hasSize(1);
        assertThat(result.getRecords().get(0).getTitle()).isEqualTo("集成测试文章");
    }
}
```

#### 2.2.4 测试最佳实践

- **测试真实的依赖关系**：集成测试应使用真实的依赖关系，而不是 Mock
- **使用内存数据库**：使用 H2 等内存数据库，避免影响真实数据库
- **使用事务管理**：使用 `@Transactional` 注解，确保测试数据不会污染数据库
- **测试核心业务流程**：集成测试应测试核心的业务流程，而不是单个功能点

### 2.3 API 测试

API 测试是对 REST API 的测试，验证接口的正确性和可靠性。

#### 2.3.1 测试工具

- **Spring Boot Test**：提供 `TestRestTemplate` 和 `WebTestClient` 用于 API 测试
- **JUnit 5**：测试框架
- **AssertJ**：断言库

#### 2.3.2 测试示例

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class PostControllerApiTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @Test
    void testPagePosts() {
        // 准备测试数据
        PostDTO postDTO = new PostDTO();
        postDTO.setTitle("API 测试文章");
        postDTO.setContent("API 测试内容");
        postDTO.setStatus(1);

        // 保存文章
        restTemplate.postForEntity("/posts", postDTO, Void.class);

        // 测试分页查询
        ResponseEntity<Result<PageResult<PostDTO>>> response = restTemplate.getForEntity(
                "/posts?page=1&size=10&title=API测试",
                new ParameterizedTypeReference<Result<PageResult<PostDTO>>>() {}
        );

        // 验证结果
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        Result<PageResult<PostDTO>> result = response.getBody();
        assertThat(result).isNotNull();
        assertThat(result.isSuccess()).isTrue();
        assertThat(result.getData().getTotal()).isEqualTo(1);
        assertThat(result.getData().getRecords()).hasSize(1);
        assertThat(result.getData().getRecords().get(0).getTitle()).isEqualTo("API 测试文章");
    }
}
```

#### 2.3.3 测试最佳实践

- **测试所有 HTTP 方法**：测试 GET、POST、PUT、DELETE 等所有 HTTP 方法
- **测试不同的请求参数**：测试不同的查询参数、路径参数和请求体
- **测试错误情况**：测试无效参数、权限不足等错误情况
- **验证响应格式**：验证响应的状态码、响应头和响应体格式
- **使用 JSON Schema 验证**：使用 JSON Schema 验证响应体的结构

## 3. 前端测试

Tagtag Starter 前端使用 TypeScript 语言开发，采用 Vitest 和 Cypress 进行测试。

### 3.1 单元测试

前端单元测试是对单个组件或函数的测试，验证其在隔离环境下的行为。

#### 3.1.1 测试工具

- **Vitest**：现代化的前端测试框架，基于 Vite
- **Vue Test Utils**：Vue 组件测试库
- **jsdom**：浏览器环境模拟

#### 3.1.2 测试结构

前端单元测试文件通常与被测试组件放在同一目录中，使用 `.test.ts` 或 `.spec.ts` 后缀。

```text
src
└── views
    └── modules
        └── system
            └── post
                ├── index.vue
                ├── FormModal.vue
                └── __tests__
                    ├── index.test.ts
                    └── FormModal.test.ts
```

#### 3.1.3 测试示例

```typescript
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import PostIndex from '../index.vue';
import { useTable } from '@vben/plugins/vxe-table';

// 模拟依赖
vi.mock('@vben/plugins/vxe-table', () => ({
  useTable: vi.fn(() => [
    // 模拟 Grid 组件
    { template: '<div></div>' },
    // 模拟 gridApi
    {
      refresh: vi.fn(),
      getSelectedRows: vi.fn(() => [])
    }
  ])
}));

describe('PostIndex Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(PostIndex);
    expect(wrapper.exists()).toBe(true);
  });
  
  it('should open modal when add button is clicked', async () => {
    const wrapper = mount(PostIndex, {
      global: {
        stubs: {
          Grid: { template: '<div @toolbar-click="$emit(\'toolbar-click\', $event)"></div>' },
          FormModal: { template: '<div></div>' }
        }
      }
    });
    
    // 触发工具栏点击事件
    await wrapper.findComponent({ name: 'Grid' }).vm.$emit('toolbar-click', { code: 'add' });
    
    // 验证模态框已打开
    expect(wrapper.vm.modalVisible).toBe(true);
    expect(wrapper.vm.modalTitle).toBe('新增文章');
  });
});
```

#### 3.1.4 测试最佳实践

- **测试组件渲染**：验证组件能够正确渲染
- **测试组件交互**：测试组件对用户交互的响应
- **测试 props 和 emits**：验证组件的 props 和 emits 工作正常
- **模拟外部依赖**：使用 vi.mock 模拟外部依赖
- **测试计算属性和 watch**：验证计算属性和 watch 的行为

### 3.2 集成测试

前端集成测试是对多个组件的测试，验证组件间的交互是否正确。

#### 3.2.1 测试工具

- **Vitest**：与单元测试使用相同的测试框架
- **Vue Test Utils**：Vue 组件测试库
- **Mock Service Worker (MSW)**：API 模拟库，用于模拟后端 API

#### 3.2.2 测试示例

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mount } from '@vue/test-utils';
import { setupServer } from 'msw/node';
import { rest } from 'msw';
import PostIndex from '../index.vue';
import { useTable } from '@vben/plugins/vxe-table';

// 模拟依赖
vi.mock('@vben/plugins/vxe-table', () => ({
  useTable: vi.fn(() => [
    { template: '<div @toolbar-click="$emit(\'toolbar-click\', $event)"></div>' },
    {
      refresh: vi.fn(),
      getSelectedRows: vi.fn(() => [])
    }
  ])
}));

// 设置 MSW 服务器
const server = setupServer(
  rest.get('/api/posts', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        success: true,
        data: {
          records: [
            { id: 1, title: '测试文章', content: '测试内容', status: 1, createTime: new Date().toISOString() }
          ],
          total: 1
        }
      })
    );
  }),
  rest.post('/api/posts', (req, res, ctx) => {
    return res(ctx.status(200), ctx.json({ success: true }));
  })
);

// 启动服务器
beforeAll(() => server.listen());
// 关闭服务器
afterAll(() => server.close());
// 重置请求处理器
afterEach(() => server.resetHandlers());

describe('PostIndex Integration Test', () => {
  it('should load posts correctly', async () => {
    const wrapper = mount(PostIndex, {
      global: {
        stubs: {
          Grid: { template: '<div></div>' },
          FormModal: { template: '<div></div>' }
        }
      }
    });
    
    // 模拟 gridApi.refresh() 触发数据加载
    const [_, gridApi] = useTable();
    await gridApi.refresh();
    
    // 验证数据已加载
    // 这里可以根据实际实现添加更详细的验证
    expect(gridApi.refresh).toHaveBeenCalled();
  });
});
```

#### 3.2.3 测试最佳实践

- **测试组件间交互**：验证组件间的通信和数据传递
- **模拟后端 API**：使用 MSW 模拟后端 API，避免依赖真实后端
- **测试完整的用户流程**：测试从用户输入到数据更新的完整流程
- **验证状态管理**：验证 Pinia 状态管理的行为

### 3.3 E2E 测试

E2E (End-to-End) 测试是对整个应用的测试，验证端到端的用户流程。

#### 3.3.1 测试工具

- **Cypress**：现代化的 E2E 测试框架
- **Chrome/Firefox**：真实的浏览器环境

#### 3.3.2 测试结构

E2E 测试文件通常放在 `cypress/e2e` 目录中，使用 `.cy.ts` 后缀。

#### 3.3.3 测试示例

```typescript
describe('Post Management', () => {
  beforeEach(() => {
    // 登录系统
    cy.visit('/');
    cy.get('input[name="username"]').type('admin');
    cy.get('input[name="password"]').type('admin123');
    cy.get('button[type="submit"]').click();
    
    // 导航到文章管理页面
    cy.visit('/system/post');
  });
  
  it('should add a new post', () => {
    // 点击新增按钮
    cy.get('button:contains("新增")').click();
    
    // 填写表单
    cy.get('input[placeholder="请输入文章标题"]').type('E2E 测试文章');
    cy.get('textarea[placeholder="请输入文章内容"]').type('E2E 测试内容');
    cy.get('button:contains("保存")').click();
    
    // 验证文章已添加
    cy.get('.ant-table-row').should('contain', 'E2E 测试文章');
  });
  
  it('should edit a post', () => {
    // 点击编辑按钮
    cy.get('.ant-table-row').first().find('a:contains("编辑")').click();
    
    // 修改表单
    cy.get('input[placeholder="请输入文章标题"]').clear().type('修改后的 E2E 测试文章');
    cy.get('button:contains("保存")').click();
    
    // 验证文章已修改
    cy.get('.ant-table-row').should('contain', '修改后的 E2E 测试文章');
  });
  
  it('should delete a post', () => {
    // 点击删除按钮
    cy.get('.ant-table-row').first().find('a:contains("删除")').click();
    
    // 确认删除
    cy.get('.ant-modal-confirm-btns').find('button:contains("确定")').click();
    
    // 验证文章已删除
    cy.get('.ant-table-row').should('not.contain', '修改后的 E2E 测试文章');
  });
});
```

#### 3.3.4 测试最佳实践

- **测试核心用户流程**：测试用户最常用的核心流程
- **使用真实数据**：使用真实的测试数据，避免使用硬编码的测试数据
- **保持测试独立**：每个测试应该是独立的，不依赖其他测试的结果
- **使用页面对象模式**：将页面操作封装为页面对象，提高测试的可维护性
- **设置合理的超时时间**：根据网络情况和应用性能设置合理的超时时间

### 3.4 安全测试

安全测试是前端测试的重要组成部分，主要关注 XSS、CSRF 等安全漏洞。

#### 3.4.1 XSS 防护测试

XSS（跨站脚本攻击）是前端最常见的安全漏洞之一。以下是 XSS 防护的测试示例：

```typescript
// 必须修复：XSS 漏洞
// 不推荐 - 直接渲染用户输入的内容
function renderUserContent(content: string) {
  return `<div>${content}</div>`;
}

// 推荐 - 使用 DOMPurify 进行 HTML 净化
import DOMPurify from 'dompurify';

function renderUserContent(content: string) {
  const cleanContent = DOMPurify.sanitize(content);
  return `<div>${cleanContent}</div>`;
}

// 推荐 - 使用 Vue 的 v-text 指令
<template>
  <div v-text="userContent"></div>
</template>

// 推荐 - 使用 Vue 的插值表达式（自动转义）
<template>
  <div>{{ userContent }}</div>
</template>

// 不推荐 - 使用 v-html 渲染用户输入
<template>
  <div v-html="userContent"></div>
</template>
```

```typescript
// XSS 测试用例示例
import { describe, it, expect } from 'vitest';
import { renderUserContent } from './utils';

describe('XSS Protection', () => {
  it('should sanitize malicious scripts', () => {
    const maliciousContent = '<script>alert("XSS")</script>';
    const rendered = renderUserContent(maliciousContent);
    
    // 验证 script 标签被移除
    expect(rendered).not.toContain('<script>');
    expect(rendered).not.toContain('alert("XSS")');
  });
  
  it('should sanitize img onerror', () => {
    const maliciousContent = '<img src="x" onerror="alert(1)">';
    const rendered = renderUserContent(maliciousContent);
    
    // 验证 onerror 事件被移除
    expect(rendered).not.toContain('onerror');
  });
  
  it('should sanitize javascript: protocol', () => {
    const maliciousContent = '<a href="javascript:alert(1)">Click me</a>';
    const rendered = renderUserContent(maliciousContent);
    
    // 验证 javascript: 协议被移除或转义
    expect(rendered).not.toContain('javascript:');
  });
  
  it('should allow safe HTML', () => {
    const safeContent = '<p>Safe <strong>content</strong></p>';
    const rendered = renderUserContent(safeContent);
    
    // 验证安全的 HTML 标签被保留
    expect(rendered).toContain('<p>');
    expect(rendered).toContain('<strong>');
  });
});
```

#### 3.4.2 CSRF 防护测试

CSRF（跨站请求伪造）是另一个常见的安全漏洞。以下是 CSRF 防护的测试示例：

```typescript
// 必须修复：CSRF 漏洞
// 不推荐 - 没有 CSRF Token 保护
async function updateProfile(data: any) {
  return axios.post('/api/profile', data);
}

// 推荐 - 使用 CSRF Token
async function updateProfile(data: any) {
  const csrfToken = getCsrfToken();
  return axios.post('/api/profile', data, {
    headers: {
      'X-CSRF-TOKEN': csrfToken
    }
  });
}

// 推荐 - 使用 axios 拦截器自动添加 CSRF Token
axios.interceptors.request.use(config => {
  const csrfToken = getCsrfToken();
  if (csrfToken) {
    config.headers['X-CSRF-TOKEN'] = csrfToken;
  }
  return config;
});
```

```typescript
// CSRF 测试用例示例
import { describe, it, expect, vi } from 'vitest';
import { updateProfile } from './api';

describe('CSRF Protection', () => {
  it('should include CSRF token in request headers', async () => {
    const mockAxios = vi.spyOn(axios, 'post').mockResolvedValue({ data: {} });
    
    await updateProfile({ name: 'Test' });
    
    // 验证请求头包含 CSRF Token
    expect(mockAxios).toHaveBeenCalledWith(
      '/api/profile',
      { name: 'Test' },
      expect.objectContaining({
        headers: expect.objectContaining({
          'X-CSRF-TOKEN': expect.any(String)
        })
      })
    );
  });
});
```

#### 3.4.3 敏感信息泄露测试

敏感信息泄露是前端安全的另一个重要方面。以下是敏感信息防护的测试示例：

```typescript
// 必须修复：敏感信息泄露
// 不推荐 - 在 localStorage 中存储敏感信息
function saveToken(token: string) {
  localStorage.setItem('authToken', token);
}

// 推荐 - 使用 sessionStorage 或内存存储
function saveToken(token: string) {
  sessionStorage.setItem('authToken', token);
}

// 推荐 - 使用 httpOnly Cookie
// 后端设置 Cookie: Set-Cookie: authToken=xxx; HttpOnly; Secure; SameSite=Strict

// 不推荐 - 在 URL 中传递敏感信息
function redirectToProfile(userId: string) {
  window.location.href = `/profile?userId=${userId}`;
}

// 推荐 - 使用路由参数或状态管理
function redirectToProfile(userId: string) {
  router.push({ name: 'Profile', params: { userId } });
}
```

```typescript
// 敏感信息泄露测试用例示例
import { describe, it, expect, vi } from 'vitest';
import { saveToken } from './auth';

describe('Sensitive Information Protection', () => {
  it('should not store token in localStorage', () => {
    const mockLocalStorage = vi.spyOn(Storage.prototype, 'setItem');
    
    saveToken('test-token');
    
    // 验证没有使用 localStorage
    expect(mockLocalStorage).not.toHaveBeenCalled();
  });
  
  it('should store token in sessionStorage', () => {
    const mockSessionStorage = vi.spyOn(sessionStorage, 'setItem');
    
    saveToken('test-token');
    
    // 验证使用了 sessionStorage
    expect(mockSessionStorage).toHaveBeenCalledWith('authToken', 'test-token');
  });
});
```

### 3.5 性能测试

性能测试是确保应用响应速度和用户体验的重要手段。

#### 3.5.1 渲染性能测试

```typescript
// 必须修复：性能问题 - 不必要的重新渲染
// 不推荐
<template>
  <div v-for="item in items" :key="item.id">
    <ExpensiveComponent :data="item" />
  </div>
</template>

// 推荐 - 使用虚拟滚动
<template>
  <VirtualList :items="items" :item-size="100">
    <template #default="{ item }">
      <ExpensiveComponent :data="item" />
    </template>
  </VirtualList>
</template>

// 推荐 - 使用 v-once 静态内容
<template>
  <div v-once>{{ staticContent }}</div>
  <div>{{ dynamicContent }}</div>
</template>
```

```typescript
// 渲染性能测试用例示例
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import PostList from './PostList.vue';

describe('Rendering Performance', () => {
  it('should render large list efficiently', async () => {
    const items = Array.from({ length: 1000 }, (_, i) => ({
      id: i,
      title: `Post ${i}`
    }));
    
    const wrapper = mount(PostList, {
      props: { items }
    });
    
    const startTime = performance.now();
    await wrapper.vm.$nextTick();
    const endTime = performance.now();
    
    // 验证渲染时间在合理范围内（例如 100ms）
    expect(endTime - startTime).toBeLessThan(100);
  });
});
```

#### 3.5.2 内存泄漏测试

```typescript
// 必须修复：内存泄漏
// 不推荐 - 未清理的事件监听器
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize);
  }
}

// 推荐 - 在组件销毁时清理事件监听器
export default {
  mounted() {
    window.addEventListener('resize', this.handleResize);
  },
  beforeUnmount() {
    window.removeEventListener('resize', this.handleResize);
  }
}

// 推荐 - 使用 onUnmounted 清理
import { onMounted, onUnmounted } from 'vue';

export default {
  setup() {
    const handleResize = () => {
      // 处理窗口大小变化
    };
    
    onMounted(() => {
      window.addEventListener('resize', handleResize);
    });
    
    onUnmounted(() => {
      window.removeEventListener('resize', handleResize);
    });
  }
}
```

```typescript
// 内存泄漏测试用例示例
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import MyComponent from './MyComponent.vue';

describe('Memory Leak Prevention', () => {
  it('should remove event listeners on unmount', () => {
    const addEventListenerSpy = vi.spyOn(window, 'addEventListener');
    const removeEventListenerSpy = vi.spyOn(window, 'removeEventListener');
    
    const wrapper = mount(MyComponent);
    
    // 验证事件监听器已添加
    expect(addEventListenerSpy).toHaveBeenCalled();
    
    wrapper.unmount();
    
    // 验证事件监听器已移除
    expect(removeEventListenerSpy).toHaveBeenCalled();
    expect(removeEventListenerSpy.mock.calls.length).toBe(addEventListenerSpy.mock.calls.length);
  });
});
```

## 4. 测试最佳实践

### 4.1 测试设计原则

- **AAA 原则**：Arrange（准备）、Act（执行）、Assert（断言）
- **单一职责原则**：每个测试只测试一个功能点
- **DRY 原则**：Don't Repeat Yourself，避免重复的测试代码
- **FIRST 原则**：


  - Fast：测试执行要快
  - Independent：测试之间要独立
  - Repeatable：测试结果要可重复
  - Self-validating：测试要自动验证结果
  - Timely：测试要及时编写

### 4.2 测试覆盖率

- **目标覆盖率**：核心功能的测试覆盖率应达到 80% 以上
- **覆盖率指标**：


  - 行覆盖率：测试执行的代码行数占总代码行数的比例
  - 分支覆盖率：测试执行的分支占总分支数的比例
  - 函数覆盖率：测试执行的函数占总函数数的比例
  - 语句覆盖率：测试执行的语句占总语句数的比例

### 4.3 测试执行

- **本地执行**：开发人员在本地开发过程中执行测试
- **CI 执行**：在持续集成过程中自动执行测试
- **定时执行**：定期执行完整的测试套件
- **按需执行**：根据需要执行特定的测试用例

### 4.4 测试报告

- **生成测试报告**：使用工具生成可视化的测试报告
- **分析测试结果**：定期分析测试结果，找出问题和改进点
- **分享测试报告**：将测试报告分享给团队成员
- **持续改进**：根据测试报告持续改进测试策略和代码质量

## 5. 持续集成

Tagtag Starter 项目使用 GitHub Actions 进行持续集成，自动执行测试。

### 5.1 CI 流程

1. **代码提交**：开发者将代码提交到 GitHub
2. **触发 CI**：GitHub Actions 自动触发 CI 流程
3. **安装依赖**：安装项目依赖
4. **运行测试**：执行单元测试、集成测试和 API 测试
5. **生成报告**：生成测试覆盖率报告
6. **部署应用**：如果测试通过，部署应用到测试环境

### 5.2 CI 配置示例

```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn -B package --file pom.xml
    
    - name: Run tests
      run: mvn test
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: tagtag-*/target/surefire-reports/
```

## 6. 总结

测试是保证软件质量的重要手段，Tagtag Starter 项目采用多层次的测试策略，包括单元测试、集成测试和 API 测试。通过遵循测试最佳实践，使用合适的测试工具，我们可以提高代码质量，减少回归问题，支持持续集成，确保项目的长期稳定发展。

希望本文档能够帮助开发者了解 Tagtag Starter 项目的测试方法和最佳实践，编写高质量的测试用例，共同维护一个高质量的代码库。


# 前端开发指南

Tagtag Starter 前端基于 Vue 3 + TypeScript + Vite 开发，采用组件化和模块化的设计理念。本文档将详细介绍前端开发的规范、最佳实践和常用工具，帮助开发者快速上手并保持代码质量。

## 1. 技术栈

| 技术             | 版本    | 用途                           |
| -------------- | ----- | ---------------------------- |
| Vue            | 3.3+  | 前端框架，使用 Composition API      |
| TypeScript     | 5.0+  | 类型系统，提供类型安全                  |
| Vite           | 4.3+  | 构建工具，提供快速的开发体验               |
| Pinia          | 2.0+  | 状态管理，替代 Vuex                 |
| Vue Router     | 4.2+  | 路由管理，支持动态路由                  |
| Ant Design Vue | 4.0+  | UI 组件库，提供丰富的企业级组件            |
| Axios          | 1.5+  | HTTP 客户端，封装在 @vben/request 中 |
| VXE Table      | 4.0+  | 高性能表格组件，用于复杂表格场景             |
| ESLint         | 8.40+ | 代码检查，确保代码质量                  |
| Prettier       | 2.8+  | 代码格式化，统一代码风格                 |
| Vitest         | 最新    | 单元测试框架                       |
| Cypress        | 最新    | E2E 测试框架                     |

## 2. 项目结构

前端项目采用 Monorepo 结构，位于 `frontend` 目录下。这种结构允许我们在一个仓库中管理多个应用和共享包，提高代码复用性和维护效率。

```text
frontend/
├── apps/                  # 应用目录
│   └── tagtag/            # 主应用
│       ├── src/           # 源代码
│       │   ├── adapter/   # 适配器层，封装第三方库
│       │   │   ├── component/ # 组件适配器
│       │   │   ├── form.ts    # 表单适配器
│       │   │   └── vxe-table.ts # 表格适配器
│       │   ├── api/       # API 定义
│       │   │   ├── core/  # 核心 API（登录、用户、菜单等）
│       │   │   ├── modules/ # 模块 API（iam、system、storage）
│       │   │   ├── request.ts # 请求客户端配置
│       │   │   └── index.ts
│       │   ├── assets/    # 静态资源
│       │   ├── components/# 公共组件
│       │   ├── composables/# 组合式函数
│       │   ├── hooks/     # 自定义 Hooks
│       │   │   └── web/   # Web 相关 Hooks
│       │   ├── layouts/   # 布局组件
│       │   │   ├── auth.vue    # 认证布局
│       │   │   └── basic.vue   # 基础布局
│       │   ├── locales/   # 国际化
│       │   │   └── langs/ # 语言包
│       │   ├── router/    # 路由配置
│       │   │   ├── routes/ # 路由定义
│       │   │   ├── guard.ts  # 路由守卫
│       │   │   └── access.ts # 权限控制
│       │   ├── store/     # 状态管理
│       │   │   ├── auth.ts    # 认证状态
│       │   │   └── index.ts
│       │   ├── styles/    # 样式文件
│       │   ├── types/     # 类型定义
│       │   ├── utils/     # 工具函数
│       │   ├── views/     # 页面组件
│       │   │   ├── _core/ # 核心页面（登录、404等）
│       │   │   ├── dashboard/ # 仪表盘
│       │   │   └── modules/ # 业务模块
│       │   ├── app.vue    # 根组件
│       │   ├── bootstrap.ts # 应用启动逻辑
│       │   ├── main.ts    # 入口文件
│       │   └── preferences.ts # 应用偏好设置
│       ├── public/        # 公共资源
│       ├── index.html     # HTML 模板
│       ├── vite.config.ts # Vite 配置
│       └── tsconfig.json  # TypeScript 配置
├── internal/              # 内部包
│   ├── lint-configs/      # 代码检查配置
│   ├── node-utils/        # Node 工具函数
│   ├── tailwind-config/   # Tailwind CSS 配置
│   ├── tsconfig/          # TypeScript 配置
│   └── vite-config/       # Vite 配置
├── packages/              # 公共包
│   └── @core/             # 核心包
│       ├── base/          # 基础功能（设计、图标、共享工具）
│       ├── composables/   # 组合式函数
│       └── typings/       # 类型定义
└── pnpm-workspace.yaml    # pnpm 工作区配置
```

### 2.1 目录说明

- **adapter/**: 适配器层，用于封装第三方库，降低对特定库的依赖。例如 `vxe-table.ts` 封装了 VXE Table 的配置，`form.ts` 封装了表单相关的逻辑。
- **api/**: API 层，分为核心 API 和模块 API。核心 API 包含登录、用户信息、菜单等基础接口，模块 API 按业务模块划分。
- **router/**: 路由配置，包含路由定义、路由守卫和权限控制。支持动态路由生成，根据用户权限动态加载菜单和路由。
- **store/**: 状态管理，使用 Pinia 进行状态管理。主要包含认证状态、用户信息、权限等全局状态。
- **views/**: 页面组件，按功能模块组织。`_core` 目录包含核心页面（登录、404等），`modules` 目录包含业务模块页面。

## 3. 组件开发规范

### 3.1 组件命名

- **文件名**：使用 PascalCase 命名，如 `FormModal.vue`、`UserTable.vue`
- **组件名**：与文件名保持一致，使用 PascalCase 命名
- **组件标签**：在模板中使用 kebab-case，如 `<form-modal></form-modal>`、`<user-table></user-table>`

**命名示例**：

```text
文件名: UserFormDrawer.vue
组件名: UserFormDrawer
使用: <user-form-drawer />
```

### 3.2 组件结构

组件应遵循以下结构：

```vue
<template>
  <!-- 组件模板 -->
</template>

<script setup lang="ts">
// 组件逻辑
</script>

<style scoped>
/* 组件样式 */
</style>
```

### 3.3 组件逻辑组织

使用 `script setup` 语法糖，简化组件开发。按照以下顺序组织代码：

1. 导入语句
2. 组件 Props 定义
3. Emits 定义
4. 响应式数据定义
5. 计算属性
6. 生命周期钩子
7. 方法定义
8. 事件处理

**示例**：

```vue
<template>
  <div class="form-modal">
    <a-modal
      v-model:open="visible"
      :title="title"
      @ok="handleOk"
      @cancel="handleCancel"
    >
      <a-form :model="formData" :rules="rules" ref="formRef">
        <!-- 表单内容 -->
      </a-form>
    </a-modal>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive, computed, onMounted } from 'vue';
import { FormInstance } from 'ant-design-vue';

// 1. 导入语句
import { message } from 'ant-design-vue';

// 2. Props 定义
const props = defineProps<{
  visible: boolean;
  title?: string;
  initialData?: any;
}>();

// 3. Emits 定义
const emit = defineEmits<{
  (e: 'update:visible', value: boolean): void;
  (e: 'submit', data: any): void;
}>();

// 4. 响应式数据
const formRef = ref<FormInstance | null>(null);
const formData = reactive<any>({
  // 表单字段
});

// 5. 计算属性
const rules = computed(() => ({
  // 表单规则
}));

// 6. 生命周期钩子
onMounted(() => {
  if (props.initialData) {
    Object.assign(formData, props.initialData);
  }
});

// 7. 方法定义
const handleOk = async () => {
  if (formRef.value) {
    await formRef.value.validate();
    emit('submit', formData);
    emit('update:visible', false);
  }
};

const handleCancel = () => {
  emit('update:visible', false);
};
</script>

<style scoped>
.form-modal {
  /* 组件样式 */
}
</style>
```

### 3.4 组件通信

- **Props/Emits**：父子组件通信首选 Props/Emits
- **Provide/Inject**：祖先组件向后代组件传递数据，适用于深层嵌套的场景
- **Pinia**：全局状态管理，适用于跨组件的共享状态
- **Event Bus**：不推荐使用，建议使用 Pinia 替代

**Props/Emits 示例**：

```vue
<!-- 父组件 -->
<template>
  <ChildComponent 
    :data="parentData" 
    @update="handleUpdate" 
  />
</template>

<script setup lang="ts">
import { ref } from 'vue';
import ChildComponent from './ChildComponent.vue';

const parentData = ref({ name: 'test' });

const handleUpdate = (newData: any) => {
  parentData.value = newData;
};
</script>

<!-- 子组件 -->
<template>
  <div @click="emit('update', { name: 'updated' })">
    {{ data.name }}
  </div>
</template>

<script setup lang="ts">
const props = defineProps<{
  data: any;
}>();

const emit = defineEmits<{
  (e: 'update', data: any): void;
}>();
</script>
```

### 3.5 组件样式

- 使用 `scoped` 属性确保样式作用域隔离
- 采用 BEM 命名规范：`block__element--modifier`
- 避免使用 `!important`
- 使用 CSS 变量管理主题色和通用样式

**示例**：

```css
/* BEM 命名规范 */
.post-card {
  /* 块样式 */
  padding: 16px;
  border: 1px solid #e8e8e8;
}

.post-card__title {
  /* 元素样式 */
  font-size: 18px;
  font-weight: 500;
}

.post-card--highlight {
  /* 修饰符样式 */
  background-color: #f0f9ff;
}

.post-card__content--large {
  /* 元素 + 修饰符 */
  font-size: 16px;
}
```

### 3.6 组件复用

对于可复用的组件，建议：

1. 将通用组件放在 `src/components` 目录
2. 为组件添加清晰的 Props 类型定义
3. 提供插槽（Slots）以增强灵活性
4. 编写组件文档和使用示例

**示例**：

```vue
<template>
  <div class="card">
    <div v-if="$slots.header" class="card__header">
      <slot name="header"></slot>
    </div>
    <div class="card__body">
      <slot></slot>
    </div>
    <div v-if="$slots.footer" class="card__footer">
      <slot name="footer"></slot>
    </div>
  </div>
</template>

<script setup lang="ts">
interface CardProps {
  title?: string;
  bordered?: boolean;
}

const props = withDefaults(defineProps<CardProps>(), {
  bordered: true
});
</script>
```

## 4. Hooks 使用指南

### 4.1 自定义 Hooks 命名

- 使用 `use` 前缀命名，如 `useAuth`、`useTable`、`useDict`
- 文件名与 Hook 名保持一致，使用 camelCase 命名
- Hook 应该返回响应式数据和方法，便于组件使用

### 4.2 常用内置 Hooks

| Hook          | 用途        | 示例                                               |
| ------------- | --------- | ------------------------------------------------ |
| `ref`         | 创建响应式数据   | `const count = ref(0)`                           |
| `reactive`    | 创建响应式对象   | `const state = reactive({ count: 0 })`           |
| `computed`    | 创建计算属性    | `const double = computed(() => count.value * 2)` |
| `watch`       | 监听数据变化    | `watch(count, (newVal) => console.log(newVal))`  |
| `watchEffect` | 自动监听依赖变化  | `watchEffect(() => console.log(count.value))`    |
| `onMounted`   | 组件挂载后执行   | `onMounted(() => fetchData())`                   |
| `onUpdated`   | 组件更新后执行   | `onUpdated(() => console.log('updated'))`        |
| `onUnmounted` | 组件卸载前执行   | `onUnmounted(() => clearInterval(timer))`        |
| `provide`     | 提供数据给后代组件 | `provide('key', value)`                          |
| `inject`      | 从祖先组件获取数据 | `const value = inject('key')`                    |

### 4.3 自定义 Hooks 示例

#### 4.3.1 `useAuth` Hook

用于管理用户认证状态，封装了登录、登出、权限检查等功能。

```typescript
// src/hooks/useAuth.ts
import { useAuthStore } from '@/store/auth';
import { computed } from 'vue';

export function useAuth() {
  const authStore = useAuthStore();

  const isAuthenticated = computed(() => !!authStore.token);
  const userInfo = computed(() => authStore.userInfo);
  const permissions = computed(() => authStore.permissions);

  const hasPermission = (permission: string) => {
    return permissions.value.includes(permission);
  };

  const login = async (loginData: any) => {
    return authStore.login(loginData);
  };

  const logout = async () => {
    return authStore.logout();
  };

  return {
    isAuthenticated,
    userInfo,
    permissions,
    hasPermission,
    login,
    logout
  };
}
```

**使用示例**：

```vue
<template>
  <div v-if="isAuthenticated">
    <p>欢迎，{{ userInfo?.username }}</p>
    <a-button @click="logout">退出登录</a-button>
  </div>
  <div v-else>
    <a-button @click="handleLogin">登录</a-button>
  </div>
</template>

<script setup lang="ts">
import { useAuth } from '@/hooks/useAuth';

const { isAuthenticated, userInfo, login, logout } = useAuth();

const handleLogin = async () => {
  await login({ username: 'admin', password: '123456' });
};
</script>
```

#### 4.3.2 `useTable` Hook

用于简化表格组件的开发，封装了分页、搜索、重置等功能。

```typescript
// src/hooks/useTable.ts
import { ref, reactive } from 'vue';

export function useTable<T>(fetchData: (params: any) => Promise<any>) {
  const loading = ref(false);
  const dataSource = ref<T[]>([]);
  const total = ref(0);
  
  const pagination = reactive({
    current: 1,
    pageSize: 10,
    showSizeChanger: true,
    pageSizeOptions: ['10', '20', '50', '100'],
    showTotal: (total: number) => `共 ${total} 条数据`
  });
  
  const searchParams = reactive<any>({});
  
  const fetchTableData = async () => {
    loading.value = true;
    try {
      const params = {
        page: pagination.current,
        size: pagination.pageSize,
        ...searchParams
      };
      const result = await fetchData(params);
      dataSource.value = result.records || [];
      total.value = result.total || 0;
    } catch (error) {
      console.error('获取表格数据失败:', error);
    } finally {
      loading.value = false;
    }
  };
  
  const handleSearch = () => {
    pagination.current = 1;
    fetchTableData();
  };
  
  const handleReset = () => {
    Object.keys(searchParams).forEach(key => {
      searchParams[key] = '';
    });
    pagination.current = 1;
    fetchTableData();
  };
  
  const handlePageChange = (page: number, pageSize: number) => {
    pagination.current = page;
    pagination.pageSize = pageSize;
    fetchTableData();
  };
  
  return {
    loading,
    dataSource,
    total,
    pagination,
    searchParams,
    fetchTableData,
    handleSearch,
    handleReset,
    handlePageChange
  };
}
```

#### 4.3.3 `useDict` Hook

用于加载和管理字典数据，支持多个字典类型的并行加载。

```typescript
// src/hooks/useDict.ts
import { onMounted, reactive, toRefs } from 'vue';
import { getDictDataList } from '@/api/modules/system/dict';

export function useDict(...dictTypes: string[]) {
  const dicts = reactive<Record<string, any[]>>({});

  const initDict = async () => {
    const promises = dictTypes.map(async (type) => {
      const data = await getDictDataList(type);
      dicts[type] = data.map((item) => ({
        label: item.itemName,
        value: item.itemCode,
        color: item.cssClass,
        ...item,
      }));
    });

    await Promise.all(promises);
  };

  onMounted(() => {
    initDict();
  });

  return {
    ...toRefs(dicts),
  };
}
```

**使用示例**：

```vue
<template>
  <a-form-item label="性别">
    <a-select v-model:value="form.gender">
      <a-select-option 
        v-for="item in genderDict" 
        :key="item.value" 
        :value="item.value"
      >
        {{ item.label }}
      </a-select-option>
    </a-select>
  </a-form-item>
</template>

<script setup lang="ts">
import { reactive } from 'vue';
import { useDict } from '@/hooks/useDict';

const { genderDict } = useDict('gender');

const form = reactive({
  gender: undefined
});
</script>
```

### 4.4 Hooks 最佳实践

- **单一职责**：每个 Hook 只负责一个功能，保持简洁
- **可复用性**：设计通用的 Hook，避免业务逻辑耦合
- **类型安全**：为 Hook 添加完整的 TypeScript 类型定义
- **清理副作用**：在组件卸载时清理副作用，如定时器、事件监听等
- **返回响应式数据**：使用 `toRefs` 返回响应式数据，便于解构使用
- **错误处理**：在 Hook 中添加适当的错误处理逻辑

## 5. 状态管理

### 5.1 Pinia 规范

Pinia 是 Vue 3 官方推荐的状态管理库，相比 Vuex 更轻量、更简洁。在 Tagtag Starter 中，我们使用 Pinia 进行全局状态管理。

- **Store 命名**：使用 PascalCase 命名，如 `AuthStore`、`UserStore`
- **文件结构**：每个模块对应一个 Store 文件
- **状态定义**：使用 `state` 函数定义响应式状态
- **Action 命名**：使用 camelCase 命名，异步 Action 应返回 Promise
- **Getters 命名**：使用 camelCase 命名

**示例**：

```typescript
// src/store/auth.ts
import { defineStore } from 'pinia';
import { loginApi, logoutApi } from '@/api/core/auth';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]')
  }),
  
  getters: {
    isAuthenticated: (state) => !!state.token,
    hasPermission: (state) => (permission: string) => {
      return state.permissions.includes(permission);
    }
  },
  
  actions: {
    async login(loginData: any) {
      const result = await loginApi(loginData);
      this.token = result.token;
      this.userInfo = result.user;
      this.permissions = result.user.permissions || [];
      
      localStorage.setItem('token', this.token);
      localStorage.setItem('userInfo', JSON.stringify(this.userInfo));
      localStorage.setItem('permissions', JSON.stringify(this.permissions));
      
      return result;
    },
    
    async logout() {
      await logoutApi();
      this.clearAuth();
    },
    
    clearAuth() {
      this.token = '';
      this.userInfo = null;
      this.permissions = [];
      
      localStorage.removeItem('token');
      localStorage.removeItem('userInfo');
      localStorage.removeItem('permissions');
    }
  }
});
```

### 5.2 实际项目中的 Store 实现

在 Tagtag Starter 项目中，认证 Store 的实现更加完善，包含了 token 刷新、登录状态管理等功能。

```typescript
// frontend/apps/tagtag/src/store/auth.ts
import type { Recordable, UserInfo } from '@vben/types';

import { ref } from 'vue';
import { useRouter } from 'vue-router';

import { LOGIN_PATH } from '@vben/constants';
import { preferences } from '@vben/preferences';
import { resetAllStores, useAccessStore, useUserStore } from '@vben/stores';

import { notification } from 'ant-design-vue';
import { defineStore } from 'pinia';

import { getAccessCodesApi, getUserInfoApi, loginApi, logoutApi } from '#/api';
import { $t } from '#/locales';

export const useAuthStore = defineStore('auth', () => {
  const accessStore = useAccessStore();
  const userStore = useUserStore();
  const router = useRouter();

  const loginLoading = ref(false);

  async function authLogin(
    params: Recordable<any>,
    onSuccess?: () => Promise<void> | void,
  ) {
    let userInfo: null | UserInfo = null;
    try {
      loginLoading.value = true;
      const { accessToken, refreshToken } = await loginApi(params);

      if (accessToken) {
        accessStore.setAccessToken(accessToken);
        accessStore.setRefreshToken(refreshToken ?? null);

        const [fetchUserInfoResult, accessCodes] = await Promise.all([
          fetchUserInfo(),
          getAccessCodesApi(),
        ]);

        userInfo = fetchUserInfoResult;

        userStore.setUserInfo(userInfo);
        accessStore.setAccessCodes(accessCodes);

        if (accessStore.loginExpired) {
          accessStore.setLoginExpired(false);
        } else {
          onSuccess
            ? await onSuccess?.()
            : await router.push(
                userInfo.homePath || preferences.app.defaultHomePath,
              );
        }

        if (userInfo?.realName || userInfo?.username) {
          notification.success({
            description: `${$t('authentication.loginSuccessDesc')}:${userInfo?.realName || userInfo?.username}`,
            duration: 3,
            message: $t('authentication.loginSuccess'),
          });
        }
      }
    } finally {
      loginLoading.value = false;
    }

    return {
      userInfo,
    };
  }

  async function logout(redirect: boolean = true) {
    try {
      const token = accessStore.accessToken ?? '';
      if (token) {
        await logoutApi(token);
      }
    } catch {
    }
    resetAllStores();
    accessStore.setLoginExpired(false);

    await router.replace({
      path: LOGIN_PATH,
      query: redirect
        ? {
            redirect: encodeURIComponent(router.currentRoute.value.fullPath),
          }
        : {},
    });
  }

  async function fetchUserInfo() {
    let userInfo: null | UserInfo = null;
    userInfo = await getUserInfoApi();
    userStore.setUserInfo(userInfo);
    return userInfo;
  }

  function $reset() {
    loginLoading.value = false;
  }

  return {
    $reset,
    authLogin,
    fetchUserInfo,
    loginLoading,
    logout,
  };
});
```

### 5.3 状态管理最佳实践

- **合理划分 Store**：按功能模块划分 Store，避免单一 Store 过大。例如：`auth`（认证）、`user`（用户）、`access`（权限）
- **避免过度使用全局状态**：只将需要全局共享的状态放入 Store，组件内部状态使用 `ref` 或 `reactive`
- **使用 Actions 处理异步逻辑**：所有异步操作都应放在 Actions 中，保持状态更新的可追踪性
- **持久化存储**：对于需要持久化的状态，使用 localStorage 或 cookie 存储
- **使用 Getters 计算派生状态**：避免在组件中重复计算相同的派生状态
- **类型安全**：为 State、Getters、Actions 添加完整的 TypeScript 类型定义

## 6. API 请求

### 6.1 Axios 配置

前端使用 Axios 进行 API 请求，配置位于 `src/api/index.ts`。

**示例**：

```typescript
// src/api/index.ts
import axios from 'axios';
import { useAuthStore } from '@/store/auth';

const request = axios.create({
  baseURL: import.meta.env.VITE_APP_API_BASE_URL,
  timeout: 10000
});

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore();
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    return response.data;
  },
  async (error) => {
    // 错误处理逻辑
    return Promise.reject(error);
  }
);

export default request;
```

### 6.2 API 模块化

将 API 按模块划分，每个模块对应一个文件。

**示例**：

```typescript
// src/api/modules/user.ts
import request from '../index';

export const userApi = {
  // 获取用户列表
  getList: (params: any) => {
    return request.get('/users', { params });
  },
  
  // 获取用户详情
  getDetail: (id: number) => {
    return request.get(`/users/${id}`);
  },
  
  // 创建用户
  create: (data: any) => {
    return request.post('/users', data);
  },
  
  // 更新用户
  update: (data: any) => {
    return request.put('/users', data);
  },
  
  // 删除用户
  delete: (id: number) => {
    return request.delete(`/users/${id}`);
  }
};
```

### 6.3 API 调用规范

- **使用 async/await**：统一使用 async/await 处理异步请求
- **错误处理**：在调用 API 时添加 try/catch 处理错误
- **参数验证**：在调用 API 前验证参数的合法性
- **加载状态**：显示适当的加载状态，提高用户体验

## 7. 路由管理

### 7.1 路由配置

路由配置位于 `src/router` 目录下，采用模块化设计。

**示例**：

```typescript
// src/router/index.ts
import { createRouter, createWebHistory } from 'vue-router';
import Layout from '@/layouts/main.vue';

const routes = [
  {
    path: '/',
    component: Layout,
    redirect: '/dashboard',
    children: [
      {
        path: 'dashboard',
        name: 'Dashboard',
        component: () => import('@/views/dashboard/index.vue'),
        meta: {
          title: '仪表盘',
          icon: 'dashboard',
          permission: 'sys:dashboard:view'
        }
      }
    ]
  },
  {
    path: '/auth',
    component: () => import('@/layouts/auth.vue'),
    children: [
      {
        path: 'login',
        name: 'Login',
        component: () => import('@/views/auth/login.vue'),
        meta: {
          title: '登录',
          requiresAuth: false
        }
      }
    ]
  },
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/error/404.vue')
  }
];

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes
});

export default router;
```

### 7.2 路由守卫

使用路由守卫实现权限控制和页面跳转逻辑。

**示例**：

```typescript
// src/router/guard.ts
import router from './index';
import { useAuthStore } from '@/store/auth';

router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore();
  
  // 设置页面标题
  document.title = `${to.meta.title || 'Tagtag Starter'} - 后台管理系统`;
  
  // 检查是否需要认证
  if (to.meta.requiresAuth !== false) {
    if (authStore.isAuthenticated) {
      // 已登录，检查权限
      if (to.meta.permission) {
        if (authStore.hasPermission(to.meta.permission as string)) {
          next();
        } else {
          // 无权限，跳转到403页面
          next({ path: '/403' });
        }
      } else {
        next();
      }
    } else {
      // 未登录，跳转到登录页面
      next({ path: '/auth/login', query: { redirect: to.fullPath } });
    }
  } else {
    next();
  }
});
```

## 8. 代码规范

### 8.1 ESLint 规则

前端项目使用 ESLint 进行代码检查，规则配置位于 `.eslintrc.cjs` 文件中。

主要规则：

- 缩进：使用 2 个空格
- 引号：使用单引号
- 分号：不使用分号
- 尾随逗号：使用尾随逗号
- 禁止未使用的变量
- 禁止未使用的导入

### 8.2 Prettier 配置

使用 Prettier 进行代码格式化，配置位于 `.prettierrc` 文件中。

### 8.3 提交规范

使用 Commitizen 提交代码，遵循 Angular 提交规范：

```text
<type>(<scope>): <subject>

<body>

<footer>
```

**类型**：

- `feat`：新功能
- `fix`：修复 bug
- `docs`：文档更新
- `style`：代码样式更新
- `refactor`：代码重构
- `test`：测试更新
- `chore`：构建工具或依赖更新

## 9. 测试

### 9.1 单元测试

使用 Vitest 进行单元测试，测试文件位于 `__tests__` 目录下。

**示例**：

```typescript
// src/components/Button/__tests__/Button.test.ts
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import Button from '../Button.vue';

describe('Button Component', () => {
  it('should render correctly', () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Button Text'
      }
    });
    expect(wrapper.text()).toBe('Button Text');
  });
  
  it('should emit click event', () => {
    const wrapper = mount(Button);
    wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeTruthy();
  });
});
```

### 9.2 E2E 测试

使用 Cypress 进行端到端测试，测试文件位于 `cypress/e2e` 目录下。

## 10. 性能优化

### 10.1 组件优化

- **懒加载组件**：使用 `defineAsyncComponent` 或动态 import 懒加载组件
- **使用 `v-once`**：对于静态内容使用 `v-once` 指令
- **使用 `v-memo`**：对于频繁更新的列表使用 `v-memo` 指令
- **避免不必要的渲染**：使用 `computed` 和 `watch` 优化渲染逻辑

### 10.2 网络优化

- **HTTP 缓存**：合理设置缓存策略
- **压缩资源**：启用 Gzip 或 Brotli 压缩
- **CDN 加速**：使用 CDN 加速静态资源访问
- **减少请求次数**：合并请求，使用 HTTP/2

### 10.3 构建优化

- **代码分割**：使用 Vite 的代码分割功能
- **Tree Shaking**：移除未使用的代码
- **按需加载**：按需加载第三方库
- **预构建依赖**：使用 Vite 的依赖预构建功能

## 11. 开发工具

### 11.1 VS Code 插件

- **Volar**：Vue 3 官方扩展
- **TypeScript Vue Plugin**：TypeScript Vue 支持
- **ESLint**：代码检查
- **Prettier**：代码格式化
- **GitLens**：Git 增强
- **Ant Design Vue Helper**：Ant Design Vue 组件辅助

### 11.2 命令行工具

```bash
# 安装依赖
pnpm install

# 启动开发服务器
pnpm dev

# 构建生产版本
pnpm build

# 预览生产版本
pnpm preview

# 运行 ESLint
pnpm lint

# 运行 Prettier
pnpm format

# 运行单元测试
pnpm test:unit

# 运行 E2E 测试
pnpm test:e2e
```

## 12. 最佳实践

### 12.1 代码可读性

- **注释**：为复杂逻辑添加注释
- **命名规范**：使用有意义的变量名和函数名
- **代码结构**：合理组织代码结构，使用空行分隔不同逻辑块
- **缩进**：保持一致的缩进风格

### 12.2 可维护性

- **模块化设计**：将代码拆分为可复用的模块
- **文档**：为公共组件和函数编写文档
- **测试**：为核心功能编写测试用例
- **版本控制**：合理使用 Git，提交粒度适中

### 12.3 用户体验

- **响应式设计**：适配不同屏幕尺寸
- **加载状态**：显示适当的加载状态
- **错误处理**：友好的错误提示
- **动画效果**：适当的动画效果，提升用户体验
- **性能优化**：确保页面加载和交互流畅

## 13. 总结

本文档介绍了 Tagtag Starter 前端开发的规范、最佳实践和常用工具。遵循这些规范可以提高代码质量、可维护性和开发效率，确保团队协作顺畅。

前端开发是一个不断演进的领域，建议开发者持续关注 Vue 3、TypeScript 等技术的最新发展，不断学习和实践新的技术和最佳实践。


# AI 辅助开发

Tagtag Starter 框架全面支持 AI 辅助开发，通过集成 Model Context Protocol (MCP) 和提供 AI 友好的文档，让您能够充分利用 AI 工具来加速开发流程。

## 什么是 MCP？

Model Context Protocol (MCP) 是一个开放标准，用于将 AI 助手（如 Claude、ChatGPT 等）连接到外部数据源和工具。通过 MCP，AI 可以直接访问您的项目文档、代码库和其他资源，从而提供更准确、更相关的帮助。

## Tagtag Starter 的 AI 支持特性

### 1. AI 友好的文档

Tagtag Starter 官方文档已经集成了 `nuxt-llms` 模块，自动生成 AI 可读的文档文件：

- **llms.txt**: 简洁的结构化文档，适合 AI 快速理解项目
- **llms-full.txt**: 完整的详细文档，提供深度的项目信息

访问地址：

- <http://tagtag.dev/llms.txt>{rel="nofollow"}
- <http://tagtag.dev/llms-full.txt>{rel="nofollow"}

这些文档遵循 llms.txt 标准，可以被各种 AI 工具和 MCP 服务器直接读取和解析。

### 2. MCP 工具集成

Tagtag Starter 文档站点已经配置了 `@nuxtjs/mcp-toolkit`，提供了标准的 MCP 工具接口，允许 AI 助手直接访问和查询文档内容。

## 如何在 Trae 中使用 AI 辅助开发

### 步骤 1: 配置 MCP 服务器

在 Trae 中，您需要配置 MCP 服务器来连接到 Tagtag Starter 的文档资源。

#### MCP 配置示例

创建或编辑您的 MCP 配置文件（通常在用户配置目录）：

```json
{
  "mcpServers": {
    "tagtag-docs": {
      "command": "npx",
      "args": [
        "-y",
        "@modelcontextprotocol/server-filesystem",
        "http://tagtag.dev/llms.txt"
      ],
      "env": {}
    }
  }
}
```

### 步骤 2: 在 Trae 中启用 MCP

1. 打开 Trae 的设置
2. 导航到 "AI" 或 "MCP" 配置部分
3. 添加 Tagtag Starter 文档的 MCP 服务器配置
4. 保存并重启 Trae

### 步骤 3: 使用 AI 助手

配置完成后，您就可以在 Trae 中使用 AI 助手了：

```typescript
// 示例：询问 AI 如何创建新的 CRUD 模块
"请帮我创建一个用户管理模块，包含增删改查功能"
```

AI 会自动访问 Tagtag Starter 文档，理解框架结构，并为您提供准确的代码示例和指导。

## 实际应用场景

### 1. 快速生成 CRUD 代码

```typescript
// 向 AI 提问
"基于 Tagtag Starter 框架，帮我生成一个产品管理的 CRUD 模块，包括：
- 实体类 Product
- Mapper 接口
- Service 层
- Controller 层
- 前端页面"
```

AI 会参考 Tagtag Starter 的代码规范和最佳实践，生成符合框架标准的代码。

#### 详细示例：生成产品管理模块

**步骤 1：生成实体类**

```typescript
// 向 AI 提问
"生成 Product 实体类，包含以下字段：
- id (Long, 主键)
- name (String, 产品名称，非空)
- code (String, 产品编码，唯一)
- price (BigDecimal, 价格，非空)
- stock (Integer, 库存数量)
- status (Integer, 状态：0-禁用，1-启用)
- description (String, 产品描述)
- createTime (LocalDateTime, 创建时间)
- updateTime (LocalDateTime, 更新时间)
- createBy (String, 创建人)
- updateBy (String, 更新人)
- deleted (Integer, 逻辑删除标记)

参考 Tagtag Starter 的 User 实体类实现"
```

AI 生成的代码：

```java
package dev.tagtag.module.product.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.math.BigDecimal;
import java.time.LocalDateTime;

@Data
@TableName("sys_product")
public class Product {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    private String name;
    
    private String code;
    
    private BigDecimal price;
    
    private Integer stock;
    
    private Integer status;
    
    private String description;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    @TableField(fill = FieldFill.INSERT)
    private String createBy;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private String updateBy;
    
    @TableLogic
    private Integer deleted;
}
```

**步骤 2：生成 DTO 类**

```typescript
// 向 AI 提问
"生成 ProductDTO 和 ProductQuery 类，用于数据传输和查询
参考 Tagtag Starter 的 UserDTO 和 UserQuery 实现"
```

AI 生成的代码：

```java
package dev.tagtag.module.product.dto;

import lombok.Data;
import jakarta.validation.constraints.*;
import java.math.BigDecimal;

@Data
public class ProductDTO {
    
    private Long id;
    
    @NotBlank(message = "产品名称不能为空")
    private String name;
    
    @NotBlank(message = "产品编码不能为空")
    private String code;
    
    @NotNull(message = "价格不能为空")
    @DecimalMin(value = "0.01", message = "价格必须大于 0")
    private BigDecimal price;
    
    @NotNull(message = "库存数量不能为空")
    @Min(value = 0, message = "库存数量不能为负数")
    private Integer stock;
    
    @NotNull(message = "状态不能为空")
    private Integer status;
    
    private String description;
}
```

```java
package dev.tagtag.module.product.dto;

import lombok.Data;

@Data
public class ProductQuery {
    
    private String name;
    
    private String code;
    
    private Integer status;
    
    private Integer pageNum = 1;
    
    private Integer pageSize = 10;
}
```

**步骤 3：生成 Mapper 接口**

```typescript
// 向 AI 提问
"生成 ProductMapper 接口，继承 BaseMapper
参考 Tagtag Starter 的 UserMapper 实现"
```

AI 生成的代码：

```java
package dev.tagtag.module.product.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import dev.tagtag.module.product.entity.Product;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface ProductMapper extends BaseMapper<Product> {
}
```

**步骤 4：生成 Service 层**

```typescript
// 向 AI 提问
"生成 ProductService 接口和 ProductServiceImpl 实现类
包含以下方法：
- pageProducts(ProductQuery query): 分页查询产品
- getProductById(Long id): 根据 ID 查询产品
- createProduct(ProductDTO productDTO): 创建产品
- updateProduct(ProductDTO productDTO): 更新产品
- deleteProduct(Long id): 删除产品
- batchDeleteProducts(List<Long> ids): 批量删除产品
- updateProductStatus(Long id, Integer status): 更新产品状态

参考 Tagtag Starter 的 UserService 实现"
```

AI 生成的代码：

```java
package dev.tagtag.module.product.service;

import dev.tagtag.module.product.dto.ProductDTO;
import dev.tagtag.module.product.dto.ProductQuery;
import dev.tagtag.common.core.page.PageResult;

public interface ProductService {
    
    PageResult<ProductDTO> pageProducts(ProductQuery query);
    
    ProductDTO getProductById(Long id);
    
    void createProduct(ProductDTO productDTO);
    
    void updateProduct(ProductDTO productDTO);
    
    void deleteProduct(Long id);
    
    void batchDeleteProducts(java.util.List<Long> ids);
    
    void updateProductStatus(Long id, Integer status);
}
```

```java
package dev.tagtag.module.product.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import dev.tagtag.module.product.dto.ProductDTO;
import dev.tagtag.module.product.dto.ProductQuery;
import dev.tagtag.module.product.entity.Product;
import dev.tagtag.module.product.mapper.ProductMapper;
import dev.tagtag.module.product.service.ProductService;
import dev.tagtag.common.core.page.PageResult;
import dev.tagtag.common.core.exception.BusinessException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class ProductServiceImpl implements ProductService {
    
    private final ProductMapper productMapper;
    
    @Override
    public PageResult<ProductDTO> pageProducts(ProductQuery query) {
        LambdaQueryWrapper<Product> wrapper = new LambdaQueryWrapper<>();
        wrapper.like(query.getName() != null, Product::getName, query.getName())
               .eq(query.getCode() != null, Product::getCode, query.getCode())
               .eq(query.getStatus() != null, Product::getStatus, query.getStatus())
               .orderByDesc(Product::getCreateTime);
        
        Page<Product> page = productMapper.selectPage(
            new Page<>(query.getPageNum(), query.getPageSize()), 
            wrapper
        );
        
        return PageResult.of(page, this::convertToDTO);
    }
    
    @Override
    public ProductDTO getProductById(Long id) {
        Product product = productMapper.selectById(id);
        if (product == null) {
            throw new BusinessException("产品不存在");
        }
        return convertToDTO(product);
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void createProduct(ProductDTO productDTO) {
        Product product = convertToEntity(productDTO);
        productMapper.insert(product);
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void updateProduct(ProductDTO productDTO) {
        Product product = productMapper.selectById(productDTO.getId());
        if (product == null) {
            throw new BusinessException("产品不存在");
        }
        BeanUtils.copyProperties(productDTO, product);
        productMapper.updateById(product);
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void deleteProduct(Long id) {
        productMapper.deleteById(id);
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void batchDeleteProducts(java.util.List<Long> ids) {
        ids.forEach(this::deleteProduct);
    }
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public void updateProductStatus(Long id, Integer status) {
        Product product = productMapper.selectById(id);
        if (product == null) {
            throw new BusinessException("产品不存在");
        }
        product.setStatus(status);
        productMapper.updateById(product);
    }
    
    private ProductDTO convertToDTO(Product product) {
        ProductDTO dto = new ProductDTO();
        BeanUtils.copyProperties(product, dto);
        return dto;
    }
    
    private Product convertToEntity(ProductDTO dto) {
        Product product = new Product();
        BeanUtils.copyProperties(dto, product);
        return product;
    }
}
```

**步骤 5：生成 Controller 层**

```typescript
// 向 AI 提问
"生成 ProductController，提供 RESTful API
参考 Tagtag Starter 的 UserController 实现"
```

AI 生成的代码：

```java
package dev.tagtag.module.product.controller;

import dev.tagtag.common.core.page.PageResult;
import dev.tagtag.common.core.result.Result;
import dev.tagtag.module.product.dto.ProductDTO;
import dev.tagtag.module.product.dto.ProductQuery;
import dev.tagtag.module.product.service.ProductService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/products")
@RequiredArgsConstructor
public class ProductController {
    
    private final ProductService productService;
    
    @GetMapping
    public Result<PageResult<ProductDTO>> pageProducts(ProductQuery query) {
        PageResult<ProductDTO> result = productService.pageProducts(query);
        return Result.success(result);
    }
    
    @GetMapping("/{id}")
    public Result<ProductDTO> getProductById(@PathVariable Long id) {
        ProductDTO product = productService.getProductById(id);
        return Result.success(product);
    }
    
    @PostMapping
    public Result<Void> createProduct(@RequestBody ProductDTO productDTO) {
        productService.createProduct(productDTO);
        return Result.success();
    }
    
    @PutMapping
    public Result<Void> updateProduct(@RequestBody ProductDTO productDTO) {
        productService.updateProduct(productDTO);
        return Result.success();
    }
    
    @DeleteMapping("/{id}")
    public Result<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return Result.success();
    }
    
    @DeleteMapping("/batch")
    public Result<Void> batchDeleteProducts(@RequestBody java.util.List<Long> ids) {
        productService.batchDeleteProducts(ids);
        return Result.success();
    }
    
    @PutMapping("/{id}/status")
    public Result<Void> updateProductStatus(@PathVariable Long id, @RequestParam Integer status) {
        productService.updateProductStatus(id, status);
        return Result.success();
    }
}
```

**步骤 6：生成前端页面**

```typescript
// 向 AI 提问
"生成产品管理的前端页面，包括：
- 产品列表页面（index.vue）
- 产品表单组件（FormModal.vue）

参考 Tagtag Starter 的用户管理页面实现
使用 Vue 3 Composition API、TypeScript、VXE Table"
```

AI 生成的代码：

```vue
<template>
  <div class="product-container">
    <Grid
      ref="gridRef"
      :columns="columns"
      :data="products"
      :toolbar-config="toolbarConfig"
      :checkbox-config="{ checkField: 'checked' }"
      @toolbar-click="handleToolbarClick"
    >
      <template #toolbar_buttons>
        <a-button type="primary" @click="handleAdd">
          <template #icon><PlusOutlined /></template>
          新增
        </a-button>
        <a-button 
          :disabled="!hasSelection"
          @click="handleBatchDelete"
        >
          <template #icon><DeleteOutlined /></template>
          批量删除
        </a-button>
      </template>
      
      <template #action="{ row }">
        <a-space>
          <a-button type="link" @click="handleEdit(row)">编辑</a-button>
          <a-button type="link" danger @click="handleDelete(row)">删除</a-button>
          <a-switch
            :checked="row.status === 1"
            @change="(checked) => handleStatusChange(row, checked)"
          />
        </a-space>
      </template>
    </Grid>
    
    <FormModal
      v-model:visible="modalVisible"
      :title="modalTitle"
      :form-data="formData"
      @submit="handleSubmit"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue';
import { message, Modal } from 'ant-design-vue';
import { PlusOutlined, DeleteOutlined } from '@ant-design/icons-vue';
import { useTable } from '@vben/plugins/vxe-table';
import { 
  pageProducts, 
  createProduct, 
  updateProduct, 
  deleteProduct,
  batchDeleteProducts,
  updateProductStatus 
} from '@/api/product';
import type { ProductDTO, ProductQuery } from '@/api/product';

const [Grid, gridApi] = useTable();

const columns = [
  { field: 'id', title: 'ID', width: 80 },
  { field: 'name', title: '产品名称', minWidth: 150 },
  { field: 'code', title: '产品编码', width: 120 },
  { field: 'price', title: '价格', width: 100, formatter: ({ cellValue }) => `¥${cellValue}` },
  { field: 'stock', title: '库存', width: 80 },
  { field: 'status', title: '状态', width: 80, formatter: ({ cellValue }) => cellValue === 1 ? '启用' : '禁用' },
  { field: 'createTime', title: '创建时间', width: 160 },
  { title: '操作', slots: { default: 'action' }, width: 200, fixed: 'right' }
];

const products = ref<ProductDTO[]>([]);
const modalVisible = ref(false);
const modalTitle = ref('');
const formData = ref<Partial<ProductDTO>>({});

const toolbarConfig = {
  buttons: [
    { code: 'add', name: '新增' }
  ]
};

const hasSelection = computed(() => {
  return gridApi.value?.getSelectedRows().length > 0;
});

const loadData = async () => {
  const query: ProductQuery = { pageNum: 1, pageSize: 10 };
  const result = await pageProducts(query);
  products.value = result.records;
};

const handleAdd = () => {
  modalTitle.value = '新增产品';
  formData.value = {};
  modalVisible.value = true;
};

const handleEdit = (row: ProductDTO) => {
  modalTitle.value = '编辑产品';
  formData.value = { ...row };
  modalVisible.value = true;
};

const handleDelete = (row: ProductDTO) => {
  Modal.confirm({
    title: '确认删除',
    content: `确定要删除产品"${row.name}"吗？`,
    onOk: async () => {
      await deleteProduct(row.id!);
      message.success('删除成功');
      loadData();
    }
  });
};

const handleBatchDelete = async () => {
  const selectedRows = gridApi.value?.getSelectedRows() || [];
  Modal.confirm({
    title: '确认删除',
    content: `确定要删除选中的 ${selectedRows.length} 个产品吗？`,
    onOk: async () => {
      const ids = selectedRows.map(row => row.id);
      await batchDeleteProducts(ids);
      message.success('批量删除成功');
      loadData();
    }
  });
};

const handleStatusChange = async (row: ProductDTO, checked: boolean) => {
  await updateProductStatus(row.id!, checked ? 1 : 0);
  message.success('状态更新成功');
  loadData();
};

const handleSubmit = async (data: ProductDTO) => {
  if (data.id) {
    await updateProduct(data);
    message.success('更新成功');
  } else {
    await createProduct(data);
    message.success('创建成功');
  }
  modalVisible.value = false;
  loadData();
};

loadData();
</script>
```

```vue
<template>
  <a-modal
    :visible="visible"
    :title="title"
    :confirm-loading="loading"
    @ok="handleSubmit"
    @cancel="handleCancel"
  >
    <a-form
      ref="formRef"
      :model="formState"
      :rules="rules"
      :label-col="{ span: 6 }"
      :wrapper-col="{ span: 16 }"
    >
      <a-form-item label="产品名称" name="name">
        <a-input v-model:value="formState.name" placeholder="请输入产品名称" />
      </a-form-item>
      
      <a-form-item label="产品编码" name="code">
        <a-input v-model:value="formState.code" placeholder="请输入产品编码" />
      </a-form-item>
      
      <a-form-item label="价格" name="price">
        <a-input-number 
          v-model:value="formState.price" 
          :min="0.01"
          :precision="2"
          style="width: 100%"
          placeholder="请输入价格"
        />
      </a-form-item>
      
      <a-form-item label="库存数量" name="stock">
        <a-input-number 
          v-model:value="formState.stock" 
          :min="0"
          style="width: 100%"
          placeholder="请输入库存数量"
        />
      </a-form-item>
      
      <a-form-item label="状态" name="status">
        <a-radio-group v-model:value="formState.status">
          <a-radio :value="1">启用</a-radio>
          <a-radio :value="0">禁用</a-radio>
        </a-radio-group>
      </a-form-item>
      
      <a-form-item label="产品描述" name="description">
        <a-textarea 
          v-model:value="formState.description" 
          :rows="4"
          placeholder="请输入产品描述"
        />
      </a-form-item>
    </a-form>
  </a-modal>
</template>

<script setup lang="ts">
import { ref, watch, reactive } from 'vue';
import type { FormInstance } from 'ant-design-vue';
import type { ProductDTO } from '@/api/product';

interface Props {
  visible: boolean;
  title: string;
  formData: Partial<ProductDTO>;
}

interface Emits {
  (e: 'update:visible', value: boolean): void;
  (e: 'submit', data: ProductDTO): void;
}

const props = defineProps<Props>();
const emit = defineEmits<Emits>();

const formRef = ref<FormInstance>();
const loading = ref(false);
const formState = reactive<Partial<ProductDTO>>({});

const rules = {
  name: [{ required: true, message: '请输入产品名称', trigger: 'blur' }],
  code: [{ required: true, message: '请输入产品编码', trigger: 'blur' }],
  price: [{ required: true, message: '请输入价格', trigger: 'blur' }],
  stock: [{ required: true, message: '请输入库存数量', trigger: 'blur' }],
  status: [{ required: true, message: '请选择状态', trigger: 'change' }]
};

watch(() => props.formData, (data) => {
  Object.assign(formState, data);
}, { immediate: true });

const handleSubmit = async () => {
  try {
    loading.value = true;
    await formRef.value?.validate();
    emit('submit', formState as ProductDTO);
  } catch (error) {
    console.error('表单验证失败:', error);
  } finally {
    loading.value = false;
  }
};

const handleCancel = () => {
  emit('update:visible', false);
  formRef.value?.resetFields();
};
</script>
```

### 2. 查询 API 文档

```typescript
// 向 AI 提问
"Tagtag Starter 中的 RBAC 权限系统是如何实现的？"
```

AI 会从文档中提取相关信息，为您提供详细的解释和代码示例。

#### 详细示例：查询 RBAC 权限系统

```typescript
// 向 AI 提问
"请详细解释 Tagtag Starter 中的 RBAC 权限系统，包括：
1. 权限模型设计（用户、角色、权限的关系）
2. 数据库表结构
3. 权限验证的实现方式
4. 前端权限控制
5. 后端权限注解使用

请提供相关代码示例"
```

AI 提供的详细解答：

**1. 权限模型设计**

Tagtag Starter 采用基于 RBAC（Role-Based Access Control）的权限模型，包含以下核心概念：

- **用户（User）**：系统的使用者
- **角色（Role）**：权限的集合，用户通过角色获得权限
- **权限（Permission）**：对资源的操作权限
- **菜单（Menu）**：前端菜单和按钮的权限控制

**2. 数据库表结构**

```sql
-- 用户表
CREATE TABLE sys_user (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(100) NOT NULL,
    real_name VARCHAR(50),
    email VARCHAR(100),
    phone VARCHAR(20),
    status TINYINT DEFAULT 1,
    create_time DATETIME,
    update_time DATETIME,
    create_by VARCHAR(50),
    update_by VARCHAR(50),
    deleted TINYINT DEFAULT 0
);

-- 角色表
CREATE TABLE sys_role (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_name VARCHAR(50) NOT NULL,
    role_code VARCHAR(50) NOT NULL UNIQUE,
    description VARCHAR(200),
    status TINYINT DEFAULT 1,
    create_time DATETIME,
    update_time DATETIME,
    create_by VARCHAR(50),
    update_by VARCHAR(50),
    deleted TINYINT DEFAULT 0
);

-- 权限表
CREATE TABLE sys_permission (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    permission_name VARCHAR(50) NOT NULL,
    permission_code VARCHAR(100) NOT NULL UNIQUE,
    resource_type VARCHAR(20),
    resource_url VARCHAR(200),
    description VARCHAR(200),
    create_time DATETIME,
    update_time DATETIME,
    create_by VARCHAR(50),
    update_by VARCHAR(50),
    deleted TINYINT DEFAULT 0
);

-- 菜单表
CREATE TABLE sys_menu (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    menu_name VARCHAR(50) NOT NULL,
    menu_code VARCHAR(50) NOT NULL UNIQUE,
    parent_id BIGINT DEFAULT 0,
    menu_type VARCHAR(20),
    icon VARCHAR(50),
    path VARCHAR(200),
    component VARCHAR(200),
    sort_order INT DEFAULT 0,
    status TINYINT DEFAULT 1,
    create_time DATETIME,
    update_time DATETIME,
    create_by VARCHAR(50),
    update_by VARCHAR(50),
    deleted TINYINT DEFAULT 0
);

-- 用户角色关联表
CREATE TABLE sys_user_role (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,
    role_id BIGINT NOT NULL,
    create_time DATETIME,
    UNIQUE KEY uk_user_role (user_id, role_id)
);

-- 角色权限关联表
CREATE TABLE sys_role_permission (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_id BIGINT NOT NULL,
    permission_id BIGINT NOT NULL,
    create_time DATETIME,
    UNIQUE KEY uk_role_permission (role_id, permission_id)
);

-- 角色菜单关联表
CREATE TABLE sys_role_menu (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    role_id BIGINT NOT NULL,
    menu_id BIGINT NOT NULL,
    create_time DATETIME,
    UNIQUE KEY uk_role_menu (role_id, menu_id)
);
```

**3. 权限验证的实现方式**

```java
// 权限验证注解
package dev.tagtag.common.security.annotation;

import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RequiresPermissions {
    
    String[] value() default {};
    
    Logical logical() default Logical.AND;
    
    enum Logical {
        AND, OR
    }
}

// 权限验证切面
package dev.tagtag.common.security.aspect;

import dev.tagtag.common.security.annotation.RequiresPermissions;
import dev.tagtag.common.security.service.PermissionService;
import dev.tagtag.common.core.exception.ForbiddenException;
import lombok.RequiredArgsConstructor;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

@Aspect
@Component
@RequiredArgsConstructor
public class PermissionAspect {
    
    private final PermissionService permissionService;
    
    @Before("@annotation(dev.tagtag.common.security.annotation.RequiresPermissions)")
    public void checkPermission(JoinPoint joinPoint) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        RequiresPermissions requiresPermissions = signature.getMethod()
            .getAnnotation(RequiresPermissions.class);
        
        String[] permissions = requiresPermissions.value();
        RequiresPermissions.Logical logical = requiresPermissions.logical();
        
        boolean hasPermission = permissionService.hasPermissions(permissions, logical);
        
        if (!hasPermission) {
            throw new ForbiddenException("权限不足");
        }
    }
}

// 权限服务
package dev.tagtag.common.security.service;

import dev.tagtag.common.security.utils.SecurityUtils;
import dev.tagtag.module.iam.mapper.UserMapper;
import dev.tagtag.module.iam.mapper.RoleMapper;
import dev.tagtag.module.iam.mapper.PermissionMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class PermissionService {
    
    private final UserMapper userMapper;
    private final RoleMapper roleMapper;
    private final PermissionMapper permissionMapper;
    
    public boolean hasPermissions(String[] permissions, RequiresPermissions.Logical logical) {
        Long userId = SecurityUtils.getUserId();
        Set<String> userPermissions = getUserPermissions(userId);
        
        if (logical == RequiresPermissions.Logical.AND) {
            return userPermissions.containsAll(List.of(permissions));
        } else {
            return List.of(permissions).stream()
                .anyMatch(userPermissions::contains);
        }
    }
    
    private Set<String> getUserPermissions(Long userId) {
        List<Long> roleIds = userMapper.getRoleIdsByUserId(userId);
        return roleIds.stream()
            .flatMap(roleId -> permissionMapper.getPermissionCodesByRoleId(roleId).stream())
            .collect(Collectors.toSet());
    }
}
```

**4. 前端权限控制**

```typescript
// 权限指令
import type { Directive, DirectiveBinding } from 'vue';

const permission: Directive = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const { value } = binding;
    const permissions = useUserStore().permissions;
    
    if (value && !permissions.includes(value)) {
      el.parentNode?.removeChild(el);
    }
  }
};

export default permission;

// 权限组合式函数
import { computed } from 'vue';
import { useUserStore } from '@/store/user';

export function usePermission() {
  const userStore = useUserStore();
  
  const hasPermission = (permission: string | string[]): boolean => {
    const permissions = userStore.permissions;
    if (Array.isArray(permission)) {
      return permission.some(p => permissions.includes(p));
    }
    return permissions.includes(permission);
  };
  
  const hasAllPermissions = (permissions: string[]): boolean => {
    const userPermissions = userStore.permissions;
    return permissions.every(p => userPermissions.includes(p));
  };
  
  const hasAnyPermission = (permissions: string[]): boolean => {
    const userPermissions = userStore.permissions;
    return permissions.some(p => userPermissions.includes(p));
  };
  
  return {
    hasPermission,
    hasAllPermissions,
    hasAnyPermission
  };
}

// 使用示例
<template>
  <div>
    <!-- 使用指令 -->
    <a-button v-permission="'user:create'">新增用户</a-button>
    
    <!-- 使用组合式函数 -->
    <a-button v-if="hasPermission('user:update')">编辑</a-button>
    
    <!-- 批量权限检查 -->
    <a-button v-if="hasAllPermissions(['user:delete', 'user:export'])">
      批量操作
    </a-button>
  </div>
</template>

<script setup lang="ts">
import { usePermission } from '@/hooks/usePermission';

const { hasPermission, hasAllPermissions } = usePermission();
</script>
```

**5. 后端权限注解使用**

```java
// Controller 中使用权限注解
package dev.tagtag.module.iam.controller;

import dev.tagtag.common.security.annotation.RequiresPermissions;
import dev.tagtag.common.core.result.Result;
import dev.tagtag.module.iam.dto.UserDTO;
import dev.tagtag.module.iam.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {
    
    private final UserService userService;
    
    @GetMapping
    @RequiresPermissions("user:list")
    public Result<PageResult<UserDTO>> pageUsers(UserQuery query) {
        PageResult<UserDTO> result = userService.pageUsers(query);
        return Result.success(result);
    }
    
    @GetMapping("/{id}")
    @RequiresPermissions("user:query")
    public Result<UserDTO> getUserById(@PathVariable Long id) {
        UserDTO user = userService.getUserById(id);
        return Result.success(user);
    }
    
    @PostMapping
    @RequiresPermissions("user:create")
    public Result<Void> createUser(@RequestBody UserDTO userDTO) {
        userService.createUser(userDTO);
        return Result.success();
    }
    
    @PutMapping
    @RequiresPermissions("user:update")
    public Result<Void> updateUser(@RequestBody UserDTO userDTO) {
        userService.updateUser(userDTO);
        return Result.success();
    }
    
    @DeleteMapping("/{id}")
    @RequiresPermissions("user:delete")
    public Result<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return Result.success();
    }
    
    @PutMapping("/{id}/status")
    @RequiresPermissions(value = {"user:update", "user:status"}, logical = Logical.OR)
    public Result<Void> updateUserStatus(@PathVariable Long id, @RequestParam Integer status) {
        userService.updateUserStatus(id, status);
        return Result.success();
    }
}
```

### 3. 代码审查和优化

```typescript
// 向 AI 提问
"请审查这段代码，看是否符合 Tagtag Starter 的开发规范"
```

AI 会根据 Tagtag 的代码风格指南，提供改进建议。

### 4. 问题排查

```typescript
// 向 AI 提问
"我在使用 Tagtag Starter 的文件存储功能时遇到了问题，错误信息是..."
```

AI 会结合文档和常见问题，帮助您快速定位和解决问题。

## 最佳实践

### 1. 提供清晰的上下文

当向 AI 提问时，提供足够的上下文信息：

```typescript
// 好的提问
"在 Tagtag Starter 框架中，我需要创建一个新的模块 'order'，包含订单管理功能。
请参考现有的 'user' 模块结构，生成相应的代码。"

// 不好的提问
"帮我写个订单模块"
```

### 2. 分步骤提问

对于复杂的任务，将其分解为多个小步骤：

```typescript
// 第一步
"帮我创建订单实体类 Order，包含 id、userId、amount、status 等字段"

// 第二步
"基于 Order 实体，创建对应的 Mapper 接口"

// 第三步
"创建 OrderService 接口和实现类"
```

### 3. 验证生成的代码

AI 生成的代码需要人工审查和测试：

- 检查是否符合项目规范
- 运行单元测试
- 进行集成测试
- 代码审查

### 4. 持续学习

通过 AI 辅助开发，您可以：

- 学习框架的最佳实践
- 理解复杂的架构设计
- 掌握新的开发技巧
- 提高代码质量

## 高级用法

### 自定义 MCP 工具

如果您需要扩展 MCP 功能，可以在 Tagtag Starter 项目中添加自定义工具：

```typescript
// server/mcp/tools/custom-tools.ts
export default defineMCPTool({
  name: 'tagtag-code-generator',
  description: 'Generate Tagtag Starter module code',
  inputSchema: {
    type: 'object',
    properties: {
      moduleName: {
        type: 'string',
        description: 'Module name'
      }
    }
  },
  handler: async (input) => {
    // 自定义代码生成逻辑
    return {
      success: true,
      data: 'Generated code...'
    }
  }
})
```

### 集成到 CI/CD

将 AI 辅助开发集成到您的 CI/CD 流程中：

```yaml
# .github/workflows/ai-review.yml
name: AI Code Review
on: [pull_request]
jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: AI Review
        run: |
          npx @modelcontextprotocol/cli review \
            --docs http://tagtag.dev/llms.txt
```

## 常见问题

### Q: AI 生成的代码可以直接使用吗？

A: 不建议直接使用。AI 生成的代码需要经过人工审查、测试和优化，确保符合项目规范和业务需求。

### Q: 如何提高 AI 的回答质量？

A: 提供清晰、具体的上下文信息，参考 Tagtag Starter 的文档结构，使用框架术语，这样 AI 能提供更准确的回答。

### Q: MCP 服务器连接失败怎么办？

A: 检查网络连接，确认文档地址可访问，查看 MCP 服务器日志，确保配置正确。

### Q: 可以离线使用 AI 辅助开发吗？

A: 可以。您可以下载 llms.txt 文件到本地，配置本地 MCP 服务器，实现离线访问。

## 总结

Tagtag Starter 框架通过以下方式支持 AI 辅助开发：

1. **AI 友好的文档**：提供标准的 llms.txt 和 llms-full.txt 文档
2. **MCP 集成**：支持 Model Context Protocol，方便 AI 工具访问
3. **清晰的代码结构**：便于 AI 理解和生成代码
4. **完善的文档**：覆盖所有核心功能和最佳实践

通过合理使用 AI 辅助开发，您可以：

- 提高开发效率
- 减少重复工作
- 学习最佳实践
- 加速项目交付

开始使用 AI 辅助开发，让 Tagtag Starter 成为您开发路上的得力助手！

## 相关资源

- [llms.txt 标准](https://llmstxt.org/){rel="nofollow"}
- [MCP 官方文档](https://modelcontextprotocol.io/){rel="nofollow"}
- [Tagtag 文档](http://tagtag.dev){rel="nofollow"}
- [Trae AI](https://trae.ai){rel="nofollow"}

---

需要帮助？欢迎在 [GitHub Issues](https://github.com/tagtag-dev/tagtag-starter/issues){rel="nofollow"} 中提问。


# 身份管理 (IAM)

**IAM (Identity and Access Management)** 模块负责系统的用户认证、授权以及组织架构管理。

## 1. RBAC 权限模型

IAM 模块基于 &#x2A;*RBAC (Role-Based Access Control)** 模型设计，实现了细粒度的权限控制。

![Tagtag Starter - profile](https://tagtag.dev/images/docs/profile.png)

### 1.1 RBAC 模型概述

RBAC 是一种基于角色的访问控制模型，通过将权限分配给角色，再将角色分配给用户，实现了权限的集中管理和灵活分配。

**核心思想**：

- 用户 (User) 与角色 (Role) 多对多关联
- 角色 (Role) 与权限 (Permission) 多对多关联
- 权限 (Permission) 与资源 (Resource) 一一对应

### 1.2 权限类型

Tagtag Starter 的 RBAC 模型支持两种类型的权限：

#### 1.2.1 功能权限

控制用户是否可以访问系统的某个功能或操作，包括：

- 菜单访问权限
- 按钮操作权限
- API 接口权限

功能权限的标识格式为：`{模块}:{资源}:{操作}`，例如：

- `sys:user:view` - 查看用户
- `sys:user:add` - 新增用户
- `sys:user:update` - 更新用户
- `sys:user:delete` - 删除用户

#### 1.2.2 数据权限

控制用户可以访问的数据范围，包括：

- 全部数据：可以访问所有数据
- 本部门数据：只能访问所属部门的数据
- 本部门及子部门数据：可以访问所属部门及其子部门的数据
- 自定义数据：根据自定义规则过滤数据

### 1.3 权限继承

权限支持继承关系：

- 目录权限继承：如果用户拥有某个目录的访问权限，默认拥有该目录下所有子菜单的访问权限
- 角色权限继承：可以创建角色层级，子角色继承父角色的权限

## 2. 数据模型

### 2.1 用户 (User)

代表系统的操作员。

**属性**:

- 用户名 (username)
- 密码 (password，BCrypt加密)
- 姓名 (name)
- 邮箱 (email)
- 电话 (phone)
- 状态 (status: 1-启用, 0-禁用)
- 归属部门 (dept\_id)
- 创建时间 (create\_time)
- 更新时间 (update\_time)

**关联**:

- 一个用户可以拥有多个角色 (多对多关系)
- 一个用户属于一个部门 (多对一关系)

### 2.2 角色 (Role)

代表一组权限的集合。

**属性**:

- 角色名称 (name)
- 角色编码 (code)
- 状态 (status: 1-启用, 0-禁用)
- 数据权限类型 (data\_scope\_type)
- 描述 (description)

**功能**:

- 用于批量分配权限给用户
- 可以配置角色的数据访问范围
- 支持角色层级，实现权限继承

### 2.3 权限/菜单 (Permission/Menu)

代表系统中的功能资源。

**属性**:

- 权限名称 (name)
- 权限编码 (code)
- 权限类型 (type: 1-目录, 2-菜单, 3-按钮)
- 父级ID (parent\_id)
- 路由路径 (path)
- 组件路径 (component)
- 图标 (icon)
- 排序 (sort)
- 状态 (status: 1-启用, 0-禁用)

**类型**:

- **目录 (Directory)**: 左侧菜单栏的分组，不对应具体页面
- **菜单 (Menu)**: 具体的页面入口，对应一个路由
- **按钮 (Button)**: 页面内的功能操作，对应一个权限标识

**标识**: 如 `sys:user:add`，用于后端接口权限校验和前端按钮显示控制。

### 2.4 部门 (Dept)

代表企业的组织层级结构。

**属性**:

- 部门名称 (name)
- 部门编码 (code)
- 父级ID (parent\_id)
- 排序 (sort)
- 状态 (status: 1-启用, 0-禁用)

**结构**: 树形结构，支持无限层级。

**用途**: 用于构建组织架构树，以及作为数据权限的判定依据。

### 2.5 关系表

- **user\_role**: 用户与角色的多对多关系表
- **role\_permission**: 角色与权限的多对多关系表

## 3. 核心功能实现

### 3.1 用户管理

**功能**: 用户的增删改查、密码重置、状态变更、角色分配。

![Tagtag Starter - user](https://tagtag.dev/images/docs/user.png)

**实现细节**:

- 密码加密：使用 BCrypt 算法进行密码加密，确保密码安全
- 用户状态控制：禁用用户无法登录系统
- 角色分配：支持为用户分配多个角色
- 数据权限：根据用户所属部门和角色数据权限配置，控制用户可访问的数据范围

### 3.2 角色管理

**功能**: 角色的创建与维护、权限分配、数据权限配置。

![Tagtag Starter - role](https://tagtag.dev/images/docs/role.png)

**实现细节**:

- 权限分配：通过树形选择器勾选菜单和按钮权限
- 数据权限配置：支持配置角色的数据访问范围
- 角色状态控制：禁用角色的权限对用户无效

### 3.3 菜单管理

**功能**: 可视化管理系统的菜单结构、配置菜单属性、定义按钮权限。

![Tagtag Starter - menu](https://tagtag.dev/images/docs/menu.png)

**实现细节**:

- 树形结构：支持无限层级菜单
- 路由配置：自动生成前端路由配置
- 组件路径：配置页面组件路径
- 权限标识：定义按钮权限标识，用于前端按钮控制

### 3.4 部门管理

**功能**: 维护企业的组织架构树。

![Tagtag Starter - dept](https://tagtag.dev/images/docs/dept.png)

**实现细节**:

- 树形结构：支持无限层级部门
- 部门编码：自动生成部门编码，支持自定义编码规则
- 部门状态：禁用部门下的用户无法登录系统

## 4. 权限校验流程

### 4.1 后端权限校验

**流程**:

1. 用户登录系统，获取 JWT 令牌
2. 请求 API 时，在请求头中携带 JWT 令牌
3. 后端拦截器验证 JWT 令牌的有效性
4. 权限守卫 `@PreAuthorize` 检查用户是否拥有该 API 的访问权限
5. 如果用户没有权限，返回 403 Forbidden 响应

**实现方式**:

```java
@RestController
@RequestMapping("/users")
public class UserController {
    
    @PostMapping
    @PreAuthorize("@ss.hasPermission('sys:user:add')")
    public Result<Void> addUser(@RequestBody @Validated UserDTO userDTO) {
        // 新增用户逻辑
    }
    
    @PutMapping
    @PreAuthorize("@ss.hasPermission('sys:user:update')")
    public Result<Void> updateUser(@RequestBody @Validated UserDTO userDTO) {
        // 更新用户逻辑
    }
}
```

**权限守卫实现**:

```java
@Component("ss")
public class PermissionGuard {
    
    public boolean hasPermission(String permission) {
        // 1. 获取当前用户
        UserPrincipal user = AuthContext.getCurrentUser();
        
        // 2. 检查用户是否为超级管理员
        if (user.isSuperAdmin()) {
            return true;
        }
        
        // 3. 检查用户是否拥有该权限
        return user.getPermissions().contains(permission);
    }
}
```

### 4.2 前端权限控制

**流程**:

1. 用户登录成功后，获取用户的菜单列表和权限列表
2. 根据菜单列表动态生成左侧菜单栏
3. 根据权限列表控制页面按钮的显示/隐藏

**实现方式**:

#### 4.2.1 菜单权限控制

```typescript
// 获取用户菜单
const menuList = await getMenuList();
// 动态生成路由
const routes = generateRoutes(menuList);
// 添加到路由表
routes.forEach(route => router.addRoute(route));
```

#### 4.2.2 按钮权限控制

使用 `v-auth` 指令控制按钮显示：

```vue
<template>
  <button v-auth="'sys:user:add'">新增用户</button>
  <button v-auth="'sys:user:delete'">删除用户</button>
</template>
```

或者使用 `AccessControl` 组件：

```vue
<template>
  <AccessControl :access="'sys:user:add'">
    <button>新增用户</button>
  </AccessControl>
</template>
```

**权限指令实现**:

```typescript
export const AuthDirective = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const permission = binding.value;
    // 检查用户是否拥有该权限
    if (!useAccess().hasPermission(permission)) {
      el.style.display = 'none';
    }
  }
};
```

## 5. 核心代码结构

### 5.1 后端代码结构

```text
tagtag-module-iam
└── src
    └── main
        ├── java
        │   └── dev
        │       └── tagtag
        │           └── module
        │               └── iam
        │                   ├── controller
        │                   │   ├── DeptController.java
        │                   │   ├── MenuController.java
        │                   │   ├── RoleController.java
        │                   │   └── UserController.java
        │                   ├── entity
        │                   │   ├── DeptEntity.java
        │                   │   ├── MenuEntity.java
        │                   │   ├── RoleEntity.java
        │                   │   ├── UserEntity.java
        │                   │   ├── UserRoleEntity.java
        │                   │   └── RolePermissionEntity.java
        │                   ├── mapper
        │                   │   ├── DeptMapper.java
        │                   │   ├── MenuMapper.java
        │                   │   ├── RoleMapper.java
        │                   │   ├── UserMapper.java
        │                   │   ├── UserRoleMapper.java
        │                   │   └── RolePermissionMapper.java
        │                   ├── service
        │                   │   ├── DeptService.java
        │                   │   ├── MenuService.java
        │                   │   ├── RoleService.java
        │                   │   └── UserService.java
        │                   └── util
        │                       └── DataPermissionUtil.java
        └── resources
            ├── db
            │   ├── schema.sql
            │   └── data
            │       ├── 00_iam_dept.sql
            │       ├── 01_iam_role.sql
            │       ├── 02_iam_user.sql
            │       ├── 03_iam_menu.sql
            │       ├── 04_iam_user_role.sql
            │       └── 05_iam_role_menu.sql
            └── mapper
                └── iam
                    ├── DeptMapper.xml
                    ├── MenuMapper.xml
                    ├── RoleMapper.xml
                    └── UserMapper.xml
```

### 5.2 前端代码结构

```text
frontend/apps/tagtag/src/views/modules/iam
├── dept
│   ├── data.ts
│   └── index.vue
├── menu
│   ├── FormModal.vue
│   ├── data.ts
│   └── index.vue
├── role
│   ├── data.ts
│   └── index.vue
└── user
    ├── DeptTree.vue
    ├── data.ts
    └── index.vue
```

## 6. 前端实现

前端相关代码位于 `frontend/apps/tagtag/src/views/modules/iam`。

| 功能   | 页面路径        | 描述           |
| :--- | :---------- | :----------- |
| 用户管理 | `/iam/user` | 用户列表、新增/编辑弹窗 |
| 角色管理 | `/iam/role` | 角色列表、权限分配抽屉  |
| 菜单管理 | `/iam/menu` | 菜单树形表格、图标选择  |
| 部门管理 | `/iam/dept` | 部门树形维护       |

## 7. API 参考

| 方法     | 端点                   | 描述            |
| :----- | :------------------- | :------------ |
| POST   | `/auth/login`        | 用户登录 (返回 JWT) |
| GET    | `/menus/routes`      | 获取当前用户的动态路由   |
| GET    | `/menus/tree`        | 获取菜单树形结构      |
| GET    | `/users`             | 获取用户列表        |
| POST   | `/users`             | 创建新用户         |
| PUT    | `/users`             | 更新用户信息        |
| DELETE | `/users`             | 删除用户          |
| GET    | `/roles`             | 获取角色列表        |
| POST   | `/roles`             | 创建新角色         |
| PUT    | `/roles`             | 更新角色信息        |
| DELETE | `/roles`             | 删除角色          |
| GET    | `/roles/permissions` | 获取角色权限        |
| POST   | `/roles/permissions` | 分配角色权限        |
| GET    | `/depts/tree`        | 获取部门树形结构      |
| POST   | `/depts`             | 创建新部门         |
| PUT    | `/depts`             | 更新部门信息        |
| DELETE | `/depts`             | 删除部门          |

## 8. 最佳实践

### 8.1 权限设计

- **最小权限原则**: 只授予用户完成工作所需的最小权限
- **权限分组**: 按功能模块分组权限，便于管理和分配
- **命名规范**: 权限标识使用统一的命名规范，如 `{模块}:{资源}:{操作}`
- **数据权限**: 根据业务需求合理配置角色的数据权限

### 8.2 角色设计

- **角色分层**: 创建不同层级的角色，如超级管理员、管理员、普通用户
- **职责分离**: 不同角色负责不同的功能模块
- **角色复用**: 避免为每个用户创建专用角色，尽量复用现有角色

### 8.3 菜单设计

- **合理分类**: 按功能模块分类菜单，便于用户导航
- **层级适中**: 菜单层级不宜过深，建议不超过 3 层
- **权限关联**: 每个菜单和按钮都应关联相应的权限标识
- **默认展开**: 合理设置默认展开的菜单，提高用户体验

### 8.4 部门设计

- **清晰层级**: 部门层级应清晰反映企业的组织架构
- **编码规范**: 使用统一的部门编码规则
- **状态管理**: 及时更新部门状态，禁用不需要的部门

## 9. 扩展建议

### 9.1 支持多租户

如果系统需要支持多租户，可以在 IAM 模块中添加租户管理功能：

- 新增租户实体
- 为用户和部门添加租户属性
- 实现租户隔离

### 9.2 支持第三方登录

集成第三方登录，如 OAuth 2.0、LDAP 等：

- 添加第三方登录配置
- 实现第三方登录回调处理
- 关联第三方用户与系统用户

### 9.3 支持细粒度数据权限

实现更细粒度的数据权限控制：

- 支持基于字段的数据权限
- 支持基于条件的数据权限
- 支持自定义数据权限规则

### 9.4 支持权限审计

添加权限审计功能，记录用户的权限变更历史：

- 记录用户角色变更
- 记录角色权限变更
- 生成权限审计报告

## 10. 总结

IAM 模块是 Tagtag Starter 系统的核心模块之一，负责系统的用户认证、授权以及组织架构管理。基于 RBAC 模型设计，实现了细粒度的权限控制，包括功能权限和数据权限。

通过 IAM 模块，管理员可以方便地管理用户、角色、菜单和部门，实现了权限的集中管理和灵活分配。同时，系统提供了完善的权限校验机制，确保只有授权用户才能访问系统资源。

IAM 模块的设计和实现遵循了模块化、可扩展的原则，便于后续功能扩展和定制化开发。


# 系统模块

系统模块是 Tagtag Starter 框架的基础模块之一，提供系统配置、数据字典、操作日志等基础功能支持。

## 1. 字典管理 (Dict)

字典管理用于动态管理系统范围内的常量和枚举值，减少前端硬编码，提高系统的灵活性和可维护性。

### 1.1 数据模型

#### 1.1.1 字典类型 (DictType)

**属性**:

- 类型编码 (type\_code): 唯一标识，如 `sys_user_sex`
- 类型名称 (type\_name): 显示名称，如 "用户性别"
- 状态 (status): 启用/禁用
- 描述 (description): 类型描述
- 排序 (sort): 显示顺序
- 创建时间 (create\_time): 创建时间
- 更新时间 (update\_time): 更新时间

#### 1.1.2 字典数据 (DictData)

**属性**:

- 字典类型编码 (type\_code): 关联字典类型
- 数据值 (value): 字典值，如 `1`
- 标签 (label): 显示标签，如 "男"
- 状态 (status): 启用/禁用
- 排序 (sort): 显示顺序
- 描述 (description): 数据描述
- 创建时间 (create\_time): 创建时间
- 更新时间 (update\_time): 更新时间

### 1.2 核心功能

**功能**:

- 字典类型的增删改查
- 字典数据的增删改查
- 字典缓存管理
- 字典导入导出

**实现细节**:

#### 1.2.1 字典缓存机制

- 使用 Redis 缓存字典数据，提高读取性能
- 支持缓存自动刷新
- 字典更新时自动清除缓存
- 缓存键格式: `dict:{type_code}`

**缓存配置**:

```yaml
# 字典缓存配置
dict:
  cache:
    enabled: true
    expire: 3600 # 缓存过期时间（秒）
```

#### 1.2.2 字典使用方式

**前端最佳实践 (Frontend Best Practice)**:

使用 `useDict` 组合式函数，优雅地管理字典数据与响应式状态。

```typescript
<script setup lang="ts">
// 优雅解构，支持多个字典同时获取
const { sys_user_sex, sys_notice_type } = useDict('sys_user_sex', 'sys_notice_type');
</script>

<template>
  <!-- 直接绑定 options -->
  <Select v-model="form.sex" :options="sys_user_sex" />
</template>
```

**后端最佳实践 (Backend Best Practice)**:

后端通过&#x2A;*契约层 (Contract Layer)** 提供的接口来获取字典数据，实现模块间的解耦。

1. **定义契约接口**: 在 `tagtag-contract-system` 中定义 `DictApi` 接口。

```java
public interface DictApi {
    /**
     * 根据字典类型获取数据列表
     */
    List<DictItemDTO> getDictData(String typeCode);

    /**
     * 获取字典标签（翻译）
     */
    String getDictLabel(String typeCode, String itemValue);
}
```

2. **注入并使用**: 在其他模块（如 User 模块）中注入 `DictApi`，直接调用接口获取值。

```java
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {

    private final DictApi dictApi;

    public UserVO getUser(Long id) {
        User user = userMapper.selectById(id);
        UserVO vo = toVO(user);
        
        // 使用契约接口获取字典标签（仅需取值）
        vo.setSexLabel(dictApi.getDictLabel("sys_user_sex", user.getSex()));
        
        return vo;
    }
}
```

### 1.3 最佳实践

- **命名规范**: 字典类型编码使用 `{模块}_{功能}_{字段}` 格式，如 `sys_user_sex`
- **缓存管理**: 定期清理过期字典缓存
- **数据维护**: 定期审核字典数据，及时清理无用数据
- **权限控制**: 严格控制字典管理权限，避免误操作

## 2. 消息管理 (Message)

消息管理用于系统内的消息通知，支持多种消息类型和发送方式。

### 2.1 数据模型

#### 2.1.1 消息模板 (MessageTemplate)

**属性**:

- 模板编码 (template\_code): 唯一标识
- 模板名称 (template\_name): 模板名称
- 模板类型 (template\_type): 消息类型，如短信、邮件、站内信
- 模板内容 (content): 消息模板内容，支持变量替换
- 状态 (status): 启用/禁用
- 描述 (description): 模板描述

#### 2.1.2 消息记录 (MessageRecord)

**属性**:

- 消息类型 (type): 消息类型
- 发送人 (sender\_id): 发送人ID
- 接收人 (receiver\_id): 接收人ID
- 消息标题 (title): 消息标题
- 消息内容 (content): 消息内容
- 发送状态 (send\_status): 发送状态，如待发送、已发送、发送失败
- 阅读状态 (read\_status): 阅读状态，如未读、已读
- 发送时间 (send\_time): 发送时间
- 阅读时间 (read\_time): 阅读时间

### 2.2 核心功能

**功能**:

- 消息模板管理
- 消息发送
- 消息接收
- 消息阅读
- 消息统计

**实现细节**:

#### 2.2.1 消息发送机制

- **同步发送**: 即时发送消息
- **异步发送**: 通过消息队列异步发送，提高系统性能
- **定时发送**: 支持定时发送消息

**消息发送流程**:

1. 构建消息对象
2. 根据消息类型选择发送方式
3. 发送消息
4. 记录消息发送状态
5. 通知接收人

#### 2.2.2 消息接收方式

- **站内信**: 系统内消息通知
- **邮件**: 邮件通知
- **短信**: 短信通知
- **Webhook**: 第三方系统通知

#### 2.2.3 消息使用方式

**发送消息**:

```java
// 注入消息服务
@Autowired
private MessageService messageService;

// 发送消息
MessageDTO messageDTO = new MessageDTO();
messageDTO.setTemplateCode("sys_user_register");
messageDTO.setReceiverId(userId);
messageDTO.setVariables(Collections.singletonMap("username", username));
messageService.send(messageDTO);
```

**接收消息**:

```typescript
// 获取未读消息数量
import { useMessage } from '@/hooks/useMessage';

const { unreadCount, getUnreadCount } = useMessage();

// 获取消息列表
const messageList = await messageService.getMessageList({ page: 1, size: 10 });
```

### 2.3 最佳实践

- **模板设计**: 合理设计消息模板，支持变量替换
- **消息分类**: 根据业务需求分类管理消息
- **权限控制**: 严格控制消息发送权限
- **性能优化**: 批量发送消息，避免频繁调用
- **消息清理**: 定期清理过期消息，释放存储空间

## 3. 操作日志 (Operation Logs)

记录关键的用户操作行为，用于审计和追踪。

### 3.1 数据模型

**属性**:

- 操作人 (user\_id): 操作人ID
- 操作人姓名 (username): 操作人姓名
- 模块名称 (module): 操作模块
- 操作方法 (method): 操作方法
- 操作类型 (type): 操作类型，如新增、修改、删除
- 操作IP (ip): 操作IP地址
- 操作时间 (create\_time): 操作时间
- 执行结果 (status): 执行结果，成功/失败
- 错误信息 (error\_msg): 错误信息（如果失败）
- 耗时 (cost\_time): 执行耗时（毫秒）
- 请求参数 (params): 请求参数
- 返回结果 (result): 返回结果

### 3.2 核心功能

**功能**:

- 操作日志自动记录
- 操作日志查询
- 操作日志导出
- 操作日志分析

**实现细节**:

#### 3.2.1 日志记录机制

- 使用 `@OperationLog` 注解自动捕获操作日志
- 支持自定义日志内容
- 支持排除特定方法

**使用方式**:

```java
@OperationLog(module = "用户管理", name = "新增用户", type = OperationType.ADD)
@PostMapping
public Result<Void> addUser(@RequestBody @Validated UserDTO userDTO) {
    // 新增用户逻辑
}
```

#### 3.2.2 日志查询

- 支持按时间范围查询
- 支持按模块查询
- 支持按用户查询
- 支持按操作类型查询
- 支持按执行结果查询

### 3.3 最佳实践

- **日志级别**: 只记录关键操作，避免日志过多
- **日志内容**: 记录足够的上下文信息，便于问题追踪
- **性能优化**: 异步记录日志，避免影响主业务流程
- **日志保存**: 合理设置日志保存期限，定期归档

## 4. 系统配置 (Config)

管理系统运行时的动态参数，提高系统的灵活性和可配置性。

### 4.1 数据模型

**属性**:

- 配置键 (config\_key): 唯一标识
- 配置值 (config\_value): 配置值
- 配置名称 (config\_name): 配置名称
- 配置类型 (config\_type): 配置类型，如字符串、数字、布尔值、枚举
- 状态 (status): 启用/禁用
- 描述 (description): 配置描述
- 排序 (sort): 显示顺序

### 4.2 核心功能

**功能**:

- 配置项的增删改查
- 配置项分组管理
- 配置项导入导出
- 配置项缓存管理

**实现细节**:

#### 4.2.1 配置缓存机制

- 使用 Redis 缓存配置数据
- 配置更新时自动刷新缓存
- 支持配置热加载

**使用方式**:

```java
// 获取配置值
ConfigService configService = SpringContextHolder.getBean(ConfigService.class);
String siteTitle = configService.getConfigValue("site_title");

// 或使用注解
@Value("${config.site_title}")
private String siteTitle;
```

### 4.3 最佳实践

- **命名规范**: 配置键使用 `{模块}_{功能}` 格式，如 `site_title`
- **默认值**: 为配置项设置合理的默认值
- **类型检查**: 严格验证配置值的类型
- **权限控制**: 严格控制配置管理权限

## 5. 文件存储 (Storage)

提供统一的文件上传和管理能力，支持多种存储模式。

### 5.1 支持模式

- **本地存储**: 文件保存在服务器磁盘
- **对象存储 (OSS)**: 集成阿里云、腾讯云、MinIO 等

### 5.2 核心功能

**功能**:

- 文件上传
- 文件下载
- 文件预览
- 文件删除
- 文件管理

**实现细节**:

#### 5.2.1 本地存储配置

```yaml
# 本地存储配置
storage:
  type: local
  local:
    base-path: uploads
    domain: http://localhost:8080
```

#### 5.2.2 对象存储配置

```yaml
# MinIO 配置
storage:
  type: minio
  minio:
    endpoint: http://minio:9000
    access-key: minioadmin
    secret-key: minioadmin
    bucket-name: tagtag
    domain: http://minio:9000
```

#### 5.2.3 文件使用方式

**上传文件**:

```java
// 注入存储服务
@Autowired
private StorageService storageService;

// 上传文件
MultipartFile file = request.getFile("file");
StorageResult result = storageService.upload(file, "image/");
```

**下载文件**:

```java
// 下载文件
String fileId = request.getParameter("fileId");
storageService.download(fileId, response);
```

### 5.3 最佳实践

- **文件命名**: 使用唯一标识符命名文件，避免文件名冲突
- **文件类型**: 限制允许上传的文件类型
- **文件大小**: 设置合理的文件大小限制
- **安全措施**: 对上传文件进行病毒扫描
- **备份策略**: 定期备份重要文件

## 6. 核心代码结构

### 6.1 后端代码结构

```text
tagtag-module-system
└── src
    └── main
        ├── java
        │   └── dev
        │       └── tagtag
        │           └── module
        │               └── system
        │                   ├── controller
        │                   │   ├── DictController.java
        │                   │   ├── MessageController.java
        │                   │   ├── OperationLogController.java
        │                   │   └── StorageController.java
        │                   ├── entity
        │                   │   ├── DictType.java
        │                   │   ├── DictData.java
        │                   │   ├── MessageTemplate.java
        │                   │   ├── MessageRecord.java
        │                   │   └── OperationLog.java
        │                   ├── mapper
        │                   │   ├── DictMapper.java
        │                   │   ├── MessageMapper.java
        │                   │   └── OperationLogMapper.java
        │                   ├── service
        │                   │   ├── DictService.java
        │                   │   ├── MessageService.java
        │                   │   ├── OperationLogService.java
        │                   │   └── StorageService.java
        │                   └── util
        │                       └── StorageUtil.java
        └── resources
            ├── db
            │   ├── schema.sql
            │   └── data
            │       ├── 01_sys_message.sql
            │       ├── 02_sys_message_menu.sql
            │       └── 03_sys_dict_menu.sql
            └── mapper
                └── system
                    ├── DictMapper.xml
                    ├── MessageMapper.xml
                    └── OperationLogMapper.xml
```

### 6.2 前端代码结构

```text
frontend/apps/tagtag/src/views/modules/system
├── dict
│   ├── data.ts
│   └── index.vue
├── message
│   ├── data.ts
│   └── index.vue
├── log
│   ├── data.ts
│   └── index.vue
└── storage
    ├── file
    │   ├── data.ts
    │   └── index.vue
    └── config
        ├── data.ts
        └── index.vue
```

## 7. 前端实现

前端相关代码位于 `frontend/apps/tagtag/src/views/modules/system`。

| 功能   | 页面路径              | 描述         |
| :--- | :---------------- | :--------- |
| 字典管理 | `/system/dict`    | 字典类型和数据的维护 |
| 消息管理 | `/system/message` | 消息模板和记录的管理 |
| 操作日志 | `/system/log`     | 日志查询与详情查看  |
| 文件管理 | `/storage/file`   | 文件上传与列表管理  |
| 存储配置 | `/storage/config` | 存储服务配置     |

## 8. API 参考

| 方法     | 端点                           | 描述         |
| :----- | :--------------------------- | :--------- |
| GET    | `/dict/types`                | 获取字典类型列表   |
| GET    | `/dict/data/{type}`          | 根据类型获取字典数据 |
| POST   | `/dict/types`                | 创建字典类型     |
| PUT    | `/dict/types`                | 更新字典类型     |
| DELETE | `/dict/types`                | 删除字典类型     |
| POST   | `/dict/data`                 | 创建字典数据     |
| PUT    | `/dict/data`                 | 更新字典数据     |
| DELETE | `/dict/data`                 | 删除字典数据     |
| GET    | `/messages`                  | 获取消息列表     |
| POST   | `/messages`                  | 发送消息       |
| PUT    | `/messages/read`             | 标记消息为已读    |
| DELETE | `/messages`                  | 删除消息       |
| GET    | `/logs`                      | 分页查询操作日志   |
| POST   | `/storage/upload`            | 上传文件       |
| GET    | `/storage/download/{fileId}` | 下载文件       |
| GET    | `/storage/preview/{fileId}`  | 预览文件       |
| DELETE | `/storage/{fileId}`          | 删除文件       |

## 9. 最佳实践

### 9.1 系统设计

- **模块化设计**: 各功能模块独立，便于扩展和维护
- **可配置性**: 核心参数支持动态配置
- **高性能**: 使用缓存提高系统性能
- **高可用性**: 关键功能支持容错处理

### 9.2 开发规范

- **命名规范**: 统一的命名规范，提高代码可读性
- **注释规范**: 完善的代码注释，便于后续维护
- **测试规范**: 为核心功能编写单元测试
- **文档规范**: 完善的接口文档和使用文档

### 9.3 部署建议

- **环境隔离**: 开发、测试、生产环境隔离
- **配置隔离**: 不同环境使用不同的配置文件
- **监控告警**: 配置完善的监控和告警机制
- **备份策略**: 定期备份数据和配置

## 10. 扩展建议

### 10.1 支持多租户

为系统模块添加多租户支持，实现租户间数据隔离。

### 10.2 增强消息功能

- 支持更多消息类型，如推送通知
- 支持消息模板变量验证
- 支持消息发送失败重试机制

### 10.3 增强日志功能

- 支持日志实时分析
- 支持日志可视化展示
- 支持日志告警

### 10.4 增强存储功能

- 支持文件版本管理
- 支持文件分享
- 支持文件加密
- 支持断点续传

## 11. 总结

系统模块是 Tagtag Starter 系统的核心模块之一，负责管理全局配置、字典数据、消息管理、日志监控以及文件存储服务。

通过系统模块，管理员可以方便地管理系统配置、维护字典数据、发送消息通知、查看操作日志以及管理文件存储。同时，系统模块提供了完善的 API 接口，便于其他模块调用。

系统模块的设计和实现遵循了模块化、可扩展的原则，便于后续功能扩展和定制化开发。


# 认证模块

**认证 (Auth)** 模块负责系统的用户认证、授权以及会话管理，基于 JWT (JSON Web Token) 实现无状态认证。

## 1. 认证模块概述

认证模块是系统的安全核心，负责验证用户身份并授予访问权限。Tagtag Starter 认证模块采用现代化的 JWT 认证机制，实现了无状态认证，提高了系统的可扩展性和性能。

### 1.1 核心功能

- 用户登录与登出
- JWT 令牌生成与验证
- 令牌刷新机制
- 权限校验
- 会话管理

### 1.2 技术栈

- **JWT**: JSON Web Token，用于无状态认证
- **BCrypt**: 密码加密算法，确保密码安全
- **Spring Security**: 安全框架，提供认证和授权功能
- **Redis**: 用于缓存令牌黑名单和会话信息

## 2. JWT 认证原理

### 2.1 JWT 基本概念

JWT (JSON Web Token) 是一种开放标准 (RFC 7519)，用于在各方之间安全地传输信息作为 JSON 对象。JWT 可以被验证和信任，因为它是数字签名的。

### 2.2 JWT 结构

JWT 由三部分组成，用点 (.) 分隔：

- **Header**: 包含令牌类型和签名算法
- **Payload**: 包含声明（claims），如用户ID、角色、过期时间等
- **Signature**: 用于验证令牌的完整性

**格式**: `header.payload.signature`

### 2.3 JWT 工作流程

1. 用户使用用户名和密码登录系统
2. 服务器验证用户名和密码的正确性
3. 服务器生成 JWT 令牌并返回给客户端
4. 客户端存储 JWT 令牌
5. 客户端在后续请求中携带 JWT 令牌
6. 服务器验证 JWT 令牌的有效性
7. 服务器处理请求并返回响应

### 2.4 JWT 优势

- **无状态**: 服务器不需要存储会话信息，提高了系统的可扩展性
- **跨域支持**: JWT 支持跨域认证，便于构建分布式系统
- **自包含**: 令牌包含了所有必要的用户信息，减少了数据库查询
- **易于集成**: 可以与各种客户端兼容

## 3. 认证流程

### 3.1 登录流程

```text
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌────────────┐
│  客户端    │     │  服务器    │     │  数据库    │     │  Redis     │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │                  │
      │ 1. 登录请求      │                  │                  │
      │────────────────▶│                  │                  │
      │                  │                  │                  │
      │                  │ 2. 验证用户名密码 │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 3. 生成 JWT 令牌 │                  │
      │                  │◀────────────────│                  │
      │                  │                  │                  │
      │                  │ 4. 存储令牌信息  │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │ 5. 返回 JWT 令牌 │                  │                  │
      │◀────────────────│                  │                  │
      │                  │                  │                  │
      │                  │                  │                  │
```

### 3.2 请求认证流程

```text
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌────────────┐
│  客户端    │     │  服务器    │     │  数据库    │     │  Redis     │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │                  │
      │ 1. 请求携带 JWT   │                  │                  │
      │────────────────▶│                  │                  │
      │                  │                  │                  │
      │                  │ 2. 验证 JWT 有效性│                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 3. 检查令牌黑名单│                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 4. 解析用户信息  │                  │
      │                  │◀────────────────│                  │
      │                  │                  │                  │
      │                  │ 5. 权限校验      │                  │
      │                  │                  │                  │
      │                  │ 6. 处理请求      │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │ 7. 返回响应      │◀────────────────│                  │
      │◀────────────────│                  │                  │
      │                  │                  │                  │
```

### 3.3 令牌刷新流程

```text
┌────────────┐     ┌────────────┐     ┌────────────┐     ┌────────────┐
│  客户端    │     │  服务器    │     │  数据库    │     │  Redis     │
└─────┬──────┘     └─────┬──────┘     └─────┬──────┘     └─────┬──────┘
      │                  │                  │                  │
      │ 1. 刷新令牌请求   │                  │                  │
      │────────────────▶│                  │                  │
      │                  │                  │                  │
      │                  │ 2. 验证刷新令牌  │                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │                  │ 3. 生成新 JWT   │                  │
      │                  │◀────────────────│                  │
      │                  │                  │                  │
      │                  │ 4. 存储新令牌信息│                  │
      │                  │────────────────▶│                  │
      │                  │                  │                  │
      │ 5. 返回新 JWT     │                  │                  │
      │◀────────────────│                  │                  │
      │                  │                  │                  │
```

## 4. 核心功能实现

### 4.1 用户登录

**功能**: 验证用户身份并生成 JWT 令牌。

**实现细节**:

- 密码验证：使用 BCrypt 算法验证密码
- 令牌生成：生成访问令牌和刷新令牌
- 令牌存储：将令牌信息存储到 Redis
- 响应格式：返回令牌、用户信息和权限列表

**登录请求**:

```json
POST /auth/login
Content-Type: application/json

{
  "username": "admin",
  "password": "admin123"
}
```

**登录响应**:

```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "tokenType": "Bearer",
    "expiresIn": 3600
  }
}
```

### 4.2 令牌验证

**功能**: 验证 JWT 令牌的有效性。

**实现细节**:

- 签名验证：验证令牌的签名是否有效
- 过期验证：检查令牌是否过期
- 黑名单验证：检查令牌是否在黑名单中
- 权限验证：验证用户是否拥有访问权限

**实现代码**:

```java
@Component
public class JwtProvider {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private long expiration;
    
    public Claims getClaimsFromToken(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(secret.getBytes(StandardCharsets.UTF_8))
                .build()
                .parseClaimsJws(token)
                .getBody();
    }
    
    public boolean validateToken(String token) {
        try {
            getClaimsFromToken(token);
            return !isTokenExpired(token);
        } catch (SignatureException | MalformedJwtException | ExpiredJwtException | UnsupportedJwtException | IllegalArgumentException ex) {
            return false;
        }
    }
    
    private boolean isTokenExpired(String token) {
        Claims claims = getClaimsFromToken(token);
        Date expirationDate = claims.getExpiration();
        return expirationDate.before(new Date());
    }
}
```

### 4.3 令牌刷新

**功能**: 使用刷新令牌生成新的访问令牌。

**实现细节**:

- 刷新令牌验证：验证刷新令牌的有效性
- 生成新令牌：生成新的访问令牌
- 更新令牌信息：更新 Redis 中的令牌信息
- 过期旧令牌：将旧令牌加入黑名单

**刷新请求**:

```json
POST /auth/refresh
Content-Type: application/json

{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

### 4.4 用户登出

**功能**: 退出登录并使令牌失效。

**实现细节**:

- 令牌黑名单：将令牌加入黑名单
- 清除缓存：清除用户相关缓存
- 会话失效：使当前会话失效

**登出请求**:

```json
POST /auth/logout
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

## 5. 核心代码结构

### 5.1 后端代码结构

```text
tagtag-module-auth
└── src
    └── main
        ├── java
        │   └── dev
        │       └── tagtag
        │           └── module
        │               └── auth
        │                   ├── controller
        │                   │   └── AuthController.java
        │                   ├── entity
        │                   │   └── AuthUser.java
        │                   ├── service
        │                   │   ├── AuthService.java
        │                   │   └── impl
        │                   │       └── AuthServiceImpl.java
        │                   ├── util
        │                   │   ├── JwtUtil.java
        │                   │   └── PasswordUtil.java
        │                   └── vo
        │                       ├── LoginRequest.java
        │                       ├── LoginResponse.java
        │                       └── RefreshTokenRequest.java
        └── resources
            └── db
                ├── schema.sql
                └── data
                    └── init.sql
```

### 5.2 前端代码结构

```text
frontend/apps/tagtag/src/api/core
├── auth.ts       # 认证相关 API
├── captcha.ts    # 验证码相关 API
└── index.ts      # API 入口
```

## 6. 前端实现

### 6.1 登录页面

**功能**: 提供用户登录界面，支持用户名密码登录和验证码登录。

**实现细节**:

- 表单验证：验证用户名和密码格式
- 验证码支持：防止暴力破解
- 记住密码：可选功能，使用 localStorage 存储
- 登录状态管理：使用 Pinia 管理登录状态

**代码示例**:

```vue
<script setup lang="ts">
import { ref, reactive } from 'vue';
import { useRouter } from 'vue-router';
import { useAuthStore } from '@/store/auth';
import { loginApi } from '@/api/core/auth';

const router = useRouter();
const authStore = useAuthStore();

const formData = reactive({
  username: '',
  password: '',
  captcha: '',
  rememberMe: false
});

const loading = ref(false);

async function handleLogin() {
  try {
    loading.value = true;
    const result = await loginApi(formData);
    authStore.setToken(result.accessToken);
    router.push('/');
  } catch (error) {
    console.error('登录失败:', error);
  } finally {
    loading.value = false;
  }
}
</script>

<template>
  <div class="login-container">
    <div class="login-form">
      <h2>Tagtag Starter 登录</h2>
      <Form :model="formData" @submit.prevent="handleLogin">
        <FormItem label="用户名" required>
          <Input v-model:value="formData.username" placeholder="请输入用户名" />
        </FormItem>
        <FormItem label="密码" required>
          <Input.Password v-model:value="formData.password" placeholder="请输入密码" />
        </FormItem>
        <FormItem label="验证码" required>
          <Input v-model:value="formData.captcha" placeholder="请输入验证码" />
          <img class="captcha-img" src="/api/captcha" @click="refreshCaptcha" />
        </FormItem>
        <FormItem>
          <Checkbox v-model:checked="formData.rememberMe">记住密码</Checkbox>
        </FormItem>
        <FormItem>
          <Button type="primary" html-type="submit" :loading="loading" block>
            登录
          </Button>
        </FormItem>
      </Form>
    </div>
  </div>
</template>
```

### 6.2 认证状态管理

**功能**: 管理用户登录状态，包括令牌存储、用户信息存储和权限管理。

**实现细节**:

- 令牌存储：使用 localStorage 或 cookie 存储令牌
- 用户信息缓存：缓存用户信息，减少请求次数
- 权限管理：根据用户权限控制菜单和按钮显示
- 自动刷新令牌：在令牌过期前自动刷新

**代码示例**:

```typescript
import { defineStore } from 'pinia';
import { loginApi, logoutApi, refreshTokenApi } from '@/api/core/auth';

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    refreshToken: localStorage.getItem('refreshToken') || '',
    userInfo: JSON.parse(localStorage.getItem('userInfo') || 'null'),
    permissions: JSON.parse(localStorage.getItem('permissions') || '[]'),
    roles: JSON.parse(localStorage.getItem('roles') || '[]')
  }),
  actions: {
    setToken(token: string) {
      this.token = token;
      localStorage.setItem('token', token);
    },
    setRefreshToken(refreshToken: string) {
      this.refreshToken = refreshToken;
      localStorage.setItem('refreshToken', refreshToken);
    },
    setUserInfo(userInfo: any) {
      this.userInfo = userInfo;
      this.permissions = userInfo.permissions || [];
      this.roles = userInfo.roles || [];
      localStorage.setItem('userInfo', JSON.stringify(userInfo));
      localStorage.setItem('permissions', JSON.stringify(this.permissions));
      localStorage.setItem('roles', JSON.stringify(this.roles));
    },
    async login(loginData: any) {
      const result = await loginApi(loginData);
      this.setToken(result.accessToken);
      this.setRefreshToken(result.refreshToken);
      return result;
    },
    async logout() {
      await logoutApi();
      this.clearAuth();
    },
    async refreshToken() {
      const result = await refreshTokenApi({ refreshToken: this.refreshToken });
      this.setToken(result.accessToken);
      this.setRefreshToken(result.refreshToken);
      return result;
    },
    clearAuth() {
      this.token = '';
      this.refreshToken = '';
      this.userInfo = null;
      this.permissions = [];
      this.roles = [];
      localStorage.removeItem('token');
      localStorage.removeItem('refreshToken');
      localStorage.removeItem('userInfo');
      localStorage.removeItem('permissions');
      localStorage.removeItem('roles');
    }
  }
});
```

### 6.3 请求拦截器

**功能**: 在请求中自动携带 JWT 令牌，处理令牌过期和刷新。

**实现细节**:

- 自动添加令牌：在请求头中添加 Authorization 头
- 令牌过期处理：捕获 401 错误，尝试刷新令牌
- 刷新令牌失败：跳转到登录页面

**代码示例**:

```typescript
import axios from 'axios';
import { useAuthStore } from '@/store/auth';

const request = axios.create({
  baseURL: import.meta.env.VITE_APP_API_BASE_URL,
  timeout: 10000
});

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore();
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    return response.data;
  },
  async (error) => {
    const authStore = useAuthStore();
    const originalRequest = error.config;
    
    // 处理 401 错误
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        // 尝试刷新令牌
        await authStore.refreshToken();
        // 使用新令牌重试请求
        originalRequest.headers.Authorization = `Bearer ${authStore.token}`;
        return request(originalRequest);
      } catch (refreshError) {
        // 刷新令牌失败，跳转到登录页面
        authStore.clearAuth();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    
    return Promise.reject(error);
  }
);

export default request;
```

## 7. API 参考

| 方法   | 端点                  | 描述       |
| :--- | :------------------ | :------- |
| POST | `/auth/login`       | 用户登录     |
| POST | `/auth/logout`      | 用户登出     |
| POST | `/auth/refresh`     | 刷新令牌     |
| GET  | `/auth/me`          | 获取当前用户信息 |
| GET  | `/auth/permissions` | 获取当前用户权限 |
| GET  | `/auth/roles`       | 获取当前用户角色 |
| GET  | `/captcha`          | 获取验证码    |

## 8. 最佳实践

### 8.1 安全建议

- **使用 HTTPS**: 在生产环境中使用 HTTPS 协议，确保数据传输安全
- **强密码策略**: 强制用户使用强密码，定期更换密码
- **令牌过期时间**: 设置合理的令牌过期时间，减少风险
- **刷新令牌机制**: 实现刷新令牌机制，提高用户体验
- **令牌黑名单**: 实现令牌黑名单，支持主动使令牌失效
- **防止 CSRF 攻击**: 实现 CSRF 防护机制
- **防止 XSS 攻击**: 对用户输入进行转义，防止 XSS 攻击

### 8.2 性能优化

- **令牌缓存**: 缓存令牌，减少数据库查询
- **减少令牌大小**: 只在令牌中包含必要的信息
- **异步验证**: 异步验证令牌，提高系统性能
- **批量权限检查**: 批量检查权限，减少请求次数

### 8.3 可扩展性

- **模块化设计**: 认证模块与业务模块分离，便于扩展
- **支持多种认证方式**: 支持用户名密码登录、短信登录、第三方登录等
- **支持多租户**: 支持多租户认证
- **支持 OAuth 2.0**: 支持 OAuth 2.0 协议

## 9. 扩展建议

### 9.1 支持多种登录方式

- **短信登录**: 支持短信验证码登录
- **邮箱登录**: 支持邮箱验证码登录
- **第三方登录**: 支持微信、QQ、GitHub 等第三方登录
- **生物识别登录**: 支持指纹、面部识别等生物识别登录

### 9.2 增强安全机制

- **多因素认证**: 支持多因素认证，提高安全性
- **风险控制**: 实现登录风险控制，防止暴力破解
- **审计日志**: 记录认证相关的审计日志
- **异常检测**: 检测异常登录行为

### 9.3 支持 SSO

实现单点登录 (SSO)，支持多系统间的无缝登录。

### 9.4 支持 JWT 扩展

- **支持 JWT 扩展声明**: 支持自定义声明
- **支持 JWT 加密**: 支持 JWT 加密，提高安全性
- **支持 JWT 吊销**: 支持 JWT 吊销机制

## 10. 总结

认证模块是 Tagtag Starter 系统的安全核心，基于 JWT 实现了无状态认证机制。该模块提供了完整的认证功能，包括用户登录、令牌验证、令牌刷新和用户登出等。

通过认证模块，系统实现了统一的身份验证和授权机制，确保只有授权用户才能访问系统资源。同时，认证模块支持多种扩展方式，可以根据业务需求灵活扩展。

认证模块的设计和实现遵循了安全性、性能和可扩展性原则，为系统提供了可靠的安全保障。


# 存储模块

**存储 (Storage)** 模块负责系统的文件上传、下载、预览和管理，支持多种存储模式，提供统一的文件操作接口。

## 1. 存储概述

存储模块采用抽象设计，支持多种存储模式，通过配置可以灵活切换，无需修改业务代码。

### 1.1 设计理念

- **抽象统一接口**: 定义统一的存储接口，屏蔽不同存储模式的实现差异
- **模块化设计**: 不同存储模式作为独立模块，便于扩展和维护
- **配置驱动**: 通过配置文件动态切换存储模式
- **高性能**: 支持文件缓存和异步操作
- **高可靠性**: 支持文件备份和恢复

### 1.2 支持的存储模式

| 存储模式 | 描述                                  | 适用场景       |
| ---- | ----------------------------------- | ---------- |
| 本地存储 | 文件保存在服务器本地磁盘                        | 开发环境、小型应用  |
| 对象存储 | 使用云厂商对象存储服务（如阿里云 OSS、腾讯云 COS、MinIO） | 生产环境、高并发应用 |

## 2. 数据模型

### 2.1 文件信息 (FileInfo)

**属性**:

- 文件ID (file\_id): 唯一标识符，使用 UUID 生成
- 文件名 (file\_name): 原始文件名
- 文件大小 (file\_size): 文件大小（字节）
- 文件类型 (content\_type): MIME 类型
- 文件路径 (file\_path): 存储路径
- 访问URL (url): 文件访问地址
- 存储模式 (storage\_type): 存储模式，如 `local`、`minio`
- 上传人 (uploader\_id): 上传人ID
- 上传时间 (upload\_time): 上传时间
- 状态 (status): 文件状态，如正常、删除

### 2.2 存储配置 (StorageConfig)

**属性**:

- 存储类型 (storage\_type): 存储模式类型
- 存储配置 (config): 具体存储模式的配置参数，JSON 格式
- 状态 (status): 启用/禁用
- 描述 (description): 配置描述

## 3. 核心功能

### 3.1 文件上传

支持多种文件上传方式，包括：

- 单文件上传
- 多文件上传
- 分片上传
- 断点续传

**上传流程**:

1. 接收文件上传请求
2. 验证文件类型和大小
3. 生成唯一文件名
4. 根据存储模式选择上传策略
5. 执行文件上传
6. 记录文件信息到数据库
7. 返回上传结果（文件ID、访问URL等）

### 3.2 文件下载

支持文件下载功能，包括：

- 直接下载
- 预览下载
- 批量下载

**下载流程**:

1. 接收文件下载请求
2. 验证文件存在性和访问权限
3. 根据存储模式选择下载策略
4. 执行文件下载
5. 返回文件流给客户端

### 3.3 文件预览

支持常见文件类型的在线预览，包括：

- 图片预览（JPG、PNG、GIF等）
- 文档预览（PDF、Word、Excel、PPT等）
- 音频视频预览

**预览流程**:

1. 接收文件预览请求
2. 验证文件存在性和访问权限
3. 检查文件类型是否支持预览
4. 根据文件类型选择预览方式
5. 返回预览结果

### 3.4 文件管理

提供完整的文件管理功能，包括：

- 文件列表查询
- 文件详情查询
- 文件删除
- 文件重命名
- 文件移动
- 文件复制

### 3.5 存储配置管理

支持动态管理存储配置，包括：

- 新增存储配置
- 修改存储配置
- 删除存储配置
- 切换默认存储配置

## 4. 实现细节

### 4.1 抽象存储接口

定义统一的存储接口，所有存储模式都实现该接口：

```java
public interface StorageService {
    
    /**
     * 上传文件
     * @param file 上传的文件
     * @param prefix 文件前缀
     * @return 存储结果
     */
    StorageResult upload(MultipartFile file, String prefix);
    
    /**
     * 下载文件
     * @param fileId 文件ID
     * @param response 响应对象
     */
    void download(String fileId, HttpServletResponse response);
    
    /**
     * 预览文件
     * @param fileId 文件ID
     * @param response 响应对象
     */
    void preview(String fileId, HttpServletResponse response);
    
    /**
     * 删除文件
     * @param fileId 文件ID
     */
    void delete(String fileId);
    
    /**
     * 获取文件信息
     * @param fileId 文件ID
     * @return 文件信息
     */
    FileInfo getFileInfo(String fileId);
}
```

### 4.2 存储模式实现

#### 4.2.1 本地存储实现

```java
@Service
@ConditionalOnProperty(name = "storage.type", havingValue = "local")
public class LocalStorageServiceImpl implements StorageService {
    
    @Value("${storage.local.base-path}")
    private String basePath;
    
    @Value("${storage.local.domain}")
    private String domain;
    
    @Override
    public StorageResult upload(MultipartFile file, String prefix) {
        // 本地存储上传实现
        // 1. 生成唯一文件名
        // 2. 创建存储目录
        // 3. 保存文件到本地磁盘
        // 4. 记录文件信息
        // 5. 返回存储结果
    }
    
    // 其他方法实现...
}
```

#### 4.2.2 对象存储实现

```java
@Service
@ConditionalOnProperty(name = "storage.type", havingValue = "minio")
public class MinioStorageServiceImpl implements StorageService {
    
    @Autowired
    private MinioClient minioClient;
    
    @Value("${storage.minio.bucket-name}")
    private String bucketName;
    
    @Value("${storage.minio.domain}")
    private String domain;
    
    @Override
    public StorageResult upload(MultipartFile file, String prefix) {
        // MinIO 上传实现
        // 1. 生成唯一文件名
        // 2. 上传文件到 MinIO
        // 3. 记录文件信息
        // 4. 返回存储结果
    }
    
    // 其他方法实现...
}
```

### 4.3 配置示例

#### 4.3.1 本地存储配置

```yaml
# 本地存储配置
storage:
  type: local
  local:
    base-path: uploads       # 文件存储根目录
    domain: http://localhost:8080  # 文件访问域名
    max-size: 104857600      # 最大文件大小（100MB）
    allowed-types:           # 允许上传的文件类型
      - image/*
      - application/pdf
      - application/msword
```

#### 4.3.2 MinIO 配置

```yaml
# MinIO 配置
storage:
  type: minio
  minio:
    endpoint: http://minio:9000  # MinIO 服务地址
    access-key: minioadmin        # 访问密钥
    secret-key: minioadmin        # 秘密密钥
    bucket-name: tagtag           # 存储桶名称
    domain: http://minio:9000     # 文件访问域名
    max-size: 104857600           # 最大文件大小（100MB）
    allowed-types:                # 允许上传的文件类型
      - image/*
      - application/pdf
```

## 5. 核心代码结构

### 5.1 后端代码结构

```text
tagtag-module-storage
└── src
    └── main
        ├── java
        │   └── dev
        │       └── tagtag
        │           └── module
        │               └── storage
        │                   ├── config
        │                   │   ├── LocalStorageConfig.java
        │                   │   ├── MinioStorageConfig.java
        │                   │   └── StorageAutoConfiguration.java
        │                   ├── controller
        │                   │   └── StorageController.java
        │                   ├── entity
        │                   │   ├── FileInfoEntity.java
        │                   │   └── StorageConfigEntity.java
        │                   ├── mapper
        │                   │   ├── FileInfoMapper.java
        │                   │   └── StorageConfigMapper.java
        │                   ├── service
        │                   │   ├── StorageService.java
        │                   │   ├── impl
        │                   │   │   ├── LocalStorageServiceImpl.java
        │                   │   │   └── MinioStorageServiceImpl.java
        │                   │   └── FileInfoService.java
        │                   └── util
        │                       ├── FileUtil.java
        │                       └── StorageUtil.java
        └── resources
            ├── db
            │   ├── schema.sql
            │   └── data
            │       └── 01_storage_config.sql
            └── mapper
                └── storage
                    ├── FileInfoMapper.xml
                    └── StorageConfigMapper.xml
```

### 5.2 前端代码结构

```text
frontend/apps/tagtag/src/views/modules/storage
├── file
│   ├── data.ts
│   └── index.vue
└── config
    ├── data.ts
    └── index.vue
```

## 6. 前端实现

前端相关代码位于 `frontend/apps/tagtag/src/views/modules/storage`。

| 功能   | 页面路径              | 描述               |
| :--- | :---------------- | :--------------- |
| 文件管理 | `/storage/file`   | 文件列表、上传、下载、预览、删除 |
| 存储配置 | `/storage/config` | 存储模式配置、切换        |

### 6.1 文件上传组件

```vue
<template>
  <div class="file-uploader">
    <a-upload
      :action="uploadUrl"
      :headers="headers"
      :before-upload="beforeUpload"
      :on-success="handleSuccess"
      :on-error="handleError"
    >
      <a-button>
        <UploadOutlined /> 选择文件
      </a-button>
    </a-upload>
  </div>
</template>

<script setup lang="ts">
import { UploadOutlined } from '@ant-design/icons-vue';
import { message } from 'ant-design-vue';
import { useToken } from '@/hooks/useToken';

const emit = defineEmits<{
  (e: 'success', file: any): void;
  (e: 'error', error: any): void;
}>();

const { token } = useToken();
const uploadUrl = import.meta.env.VITE_API_BASE_URL + '/storage/upload';

const headers = {
  'Authorization': `Bearer ${token.value}`
};

const beforeUpload = (file: File) => {
  // 验证文件类型和大小
  const isImage = file.type.startsWith('image/');
  const isLt10M = file.size / 1024 / 1024 < 10;
  
  if (!isImage) {
    message.error('只允许上传图片文件！');
    return false;
  }
  if (!isLt10M) {
    message.error('文件大小不能超过 10MB！');
    return false;
  }
  return true;
};

const handleSuccess = (response: any) => {
  if (response.success) {
    message.success('文件上传成功！');
    emit('success', response.data);
  } else {
    message.error('文件上传失败：' + response.message);
    emit('error', response);
  }
};

const handleError = (error: any) => {
  message.error('文件上传失败：' + error.message);
  emit('error', error);
};
</script>
```

## 7. API 参考

| 方法     | 端点                                       | 描述       |
| :----- | :--------------------------------------- | :------- |
| POST   | `/storage/upload`                        | 上传文件     |
| GET    | `/storage/download/{fileId}`             | 下载文件     |
| GET    | `/storage/preview/{fileId}`              | 预览文件     |
| DELETE | `/storage/{fileId}`                      | 删除文件     |
| GET    | `/storage/list`                          | 获取文件列表   |
| GET    | `/storage/{fileId}`                      | 获取文件详情   |
| GET    | `/storage/config`                        | 获取存储配置   |
| POST   | `/storage/config`                        | 新增存储配置   |
| PUT    | `/storage/config`                        | 更新存储配置   |
| DELETE | `/storage/config/{configId}`             | 删除存储配置   |
| PUT    | `/storage/config/set-default/{configId}` | 设置默认存储配置 |

## 8. 最佳实践

### 8.1 文件命名

- 使用 UUID 生成唯一文件名，避免文件名冲突
- 保留原始文件名，存储在数据库中
- 使用目录分级存储，避免单个目录文件过多

### 8.2 文件大小限制

- 根据业务需求设置合理的文件大小限制
- 在前端和后端同时进行文件大小验证
- 对于大文件，使用分片上传和断点续传

### 8.3 文件类型验证

- 限制允许上传的文件类型
- 在前端和后端同时进行文件类型验证
- 对于可执行文件和脚本文件，进行特殊处理

### 8.4 安全措施

- 对上传文件进行病毒扫描
- 设置合理的文件访问权限
- 对于敏感文件，使用加密存储
- 定期备份重要文件

### 8.5 性能优化

- 使用 CDN 加速文件访问
- 对热点文件进行缓存
- 异步处理文件上传和下载
- 定期清理过期文件

## 9. 扩展建议

### 9.1 支持更多存储模式

- 添加对更多云厂商对象存储的支持
- 支持分布式文件系统（如 FastDFS、GlusterFS）

### 9.2 增强文件管理功能

- 支持文件版本管理
- 支持文件分享功能
- 支持文件评论和标签
- 支持文件搜索功能

### 9.3 增强安全功能

- 支持文件加密存储
- 支持文件访问日志
- 支持文件访问权限控制
- 支持文件水印功能

### 9.4 增强性能功能

- 支持文件压缩和转码
- 支持智能缓存策略
- 支持文件预加载
- 支持文件分片下载

## 10. 总结

存储模块是 Tagtag Starter 系统的核心模块之一，负责系统的文件上传、下载、预览和管理。

通过存储模块，系统可以灵活支持多种存储模式，提供统一的文件操作接口，满足不同场景的需求。存储模块的设计和实现遵循了模块化、可扩展的原则，便于后续功能扩展和定制化开发。

存储模块的核心功能包括文件上传、下载、预览和管理，支持本地存储和对象存储两种模式。通过合理的配置和最佳实践，可以提高系统的性能、可靠性和安全性。


# 生产环境部署

本文档详细介绍 Tagtag Starter 项目在生产环境的部署配置，包括服务器选型、后端部署、前端部署、数据库优化和安全配置等内容。

## 1. 服务器选型与配置

### 1.1 服务器架构

Tagtag Starter 采用前后端分离架构，生产环境建议使用以下服务器配置：

| 服务类型  | 推荐配置   | 数量   | 用途                          |
| ----- | ------ | ---- | --------------------------- |
| 负载均衡  | 4核8G   | 1    | 流量分发、SSL 终止                 |
| 后端应用  | 8核16G  | 2+   | 运行 Spring Boot 应用           |
| 前端应用  | 4核8G   | 2    | 运行 Nginx 服务，部署静态资源          |
| 数据库   | 16核32G | 1主1从 | 运行 MySQL 数据库                |
| Redis | 4核8G   | 1主1从 | 缓存、会话存储                     |
| 监控    | 4核8G   | 1    | 运行 Prometheus、Grafana 等监控工具 |

### 1.2 操作系统配置

建议使用 CentOS 7.9 或 Ubuntu 20.04 LTS 作为服务器操作系统。

**系统优化建议**：

```bash
# 关闭不必要的服务
systemctl stop firewalld
systemctl disable firewalld
systemctl stop postfix
systemctl disable postfix

# 设置系统时区
timedatectl set-timezone Asia/Shanghai

# 关闭 SELinux
sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config
setenforce 0

# 优化文件描述符限制
cat >> /etc/security/limits.conf << EOF
* soft nofile 65535
* hard nofile 65535
EOF

# 优化内核参数
cat >> /etc/sysctl.conf << EOF
# 网络优化
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.ip_local_port_range = 1024 65535

# 内存优化
vm.swappiness = 10
vm.overcommit_memory = 1
EOF

# 应用内核参数
sysctl -p
```

## 2. 后端部署

### 2.1 构建打包

**步骤**：

1. 克隆代码仓库
2. 配置环境变量
3. 构建 Maven 项目
4. 生成 Docker 镜像（可选）

**命令示例**：

```bash
# 克隆代码
git clone https://github.com/your-org/tagtag.git
cd tagtag

# 配置环境变量
export MAVEN_OPTS="-Xmx2g -Xms1g"

# 构建项目
mvn clean package -DskipTests

# 生成 Docker 镜像（可选）
docker build -t tagtag/backend:latest .
```

### 2.2 部署方式

#### 2.2.1 传统部署

**步骤**：

1. 将构建好的 JAR 文件上传到服务器
2. 创建启动脚本
3. 配置 Systemd 服务
4. 启动服务

**示例**：

```bash
# 创建部署目录
mkdir -p /opt/tagtag/backend
cd /opt/tagtag/backend

# 上传 JAR 文件
scp target/tagtag-backend.jar root@server:/opt/tagtag/backend/

# 创建启动脚本
cat > start.sh << EOF
#!/bin/bash
java -jar -Xmx8g -Xms4g -Dspring.profiles.active=prod tagtag-backend.jar
EOF

chmod +x start.sh

# 配置 Systemd 服务
cat > /etc/systemd/system/tagtag-backend.service << EOF
[Unit]
Description=Tagtag Starter Backend Service
After=network.target

[Service]
User=root
WorkingDirectory=/opt/tagtag/backend
ExecStart=/opt/tagtag/backend/start.sh
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

# 启动服务
systemctl daemon-reload
systemctl start tagtag-backend
systemctl enable tagtag-backend
```

#### 2.2.2 Docker 部署

**步骤**：

1. 安装 Docker
2. 拉取或构建 Docker 镜像
3. 创建 Docker Compose 文件
4. 启动服务

**Docker Compose 示例**：

```yaml
version: '3.8'

services:
  tagtag-backend:
    image: tagtag/backend:latest
    container_name: tagtag-backend
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=mysql
      - DB_PORT=3306
      - DB_USERNAME=root
      - DB_PASSWORD=password
      - REDIS_HOST=redis
      - REDIS_PORT=6379
    depends_on:
      - mysql
      - redis
    restart: always
    volumes:
      - ./logs:/opt/tagtag/logs

  mysql:
    image: mysql:8.0
    container_name: mysql
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=tagtag
    restart: always
    volumes:
      - ./mysql/data:/var/lib/mysql
      - ./mysql/conf:/etc/mysql/conf.d

  redis:
    image: redis:7.0
    container_name: redis
    ports:
      - "6379:6379"
    restart: always
    volumes:
      - ./redis/data:/data
```

### 2.3 配置文件管理

**生产环境配置文件**：`application-prod.yml`

**核心配置项**：

```yaml
# 服务器配置
server:
  port: 8080
  servlet:
    context-path: /api
  tomcat:
    threads:
      max: 200
      min-spare: 10
    connection-timeout: 30000

# 数据库配置
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/tagtag?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: password
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

# Redis 配置
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    timeout: 3000ms
    lettuce:
      pool:
        max-active: 100
        max-idle: 20
        min-idle: 5
        max-wait: -1ms

# JWT 配置
jwt:
  secret: your-secret-key
  expiration: 3600
  refresh-expiration: 86400

# 日志配置
logging:
  level:
    root: info
    com.tagtag: debug
  file:
    name: /opt/tagtag/logs/tagtag.log
    max-size: 100MB
    max-history: 30
```

## 3. 前端部署

### 3.1 构建打包

**步骤**：

1. 克隆代码仓库
2. 安装依赖
3. 构建生产版本
4. 生成 Docker 镜像（可选）

**命令示例**：

```bash
# 克隆代码
git clone https://github.com/your-org/tagtag.git
cd tagtag/tagtag-ui

# 安装依赖
pnpm install

# 构建生产版本
pnpm build

# 生成 Docker 镜像（可选）
docker build -t tagtag/frontend:latest .
```

### 3.2 Nginx 部署

**步骤**：

1. 安装 Nginx
2. 配置 Nginx 虚拟主机
3. 将构建好的静态文件复制到 Nginx 目录
4. 启动 Nginx 服务

**示例**：

```bash
# 安装 Nginx
yum install -y nginx

# 创建部署目录
mkdir -p /usr/share/nginx/html/tagtag

# 复制静态文件
cp -r dist/* /usr/share/nginx/html/tagtag/

# 配置 Nginx
cat > /etc/nginx/conf.d/tagtag.conf << EOF
server {
    listen 80;
    server_name tagtag.your-domain.com;
    
    # 静态资源配置
    location / {
        root /usr/share/nginx/html/tagtag;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
    
    # API 代理配置
    location /api {
        proxy_pass http://backend-server:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket 支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
    
    # 日志配置
    access_log /var/log/nginx/tagtag.access.log main;
    error_log /var/log/nginx/tagtag.error.log error;
}
EOF

# 检查 Nginx 配置
nginx -t

# 重启 Nginx
systemctl restart nginx
systemctl enable nginx
```

### 3.3 SSL 配置

**步骤**：

1. 申请 SSL 证书（推荐使用 Let's Encrypt）
2. 配置 Nginx SSL
3. 强制 HTTPS 跳转

**示例**：

```bash
# 安装 Certbot
yum install -y epel-release
yum install -y certbot python3-certbot-nginx

# 申请 SSL 证书
certbot --nginx -d tagtag.your-domain.com

# 自动续约
echo "0 3 * * * certbot renew --quiet" >> /var/spool/cron/root
```

**Nginx SSL 配置**：

```nginx
server {
    listen 443 ssl http2;
    server_name tagtag.your-domain.com;
    
    # SSL 配置
    ssl_certificate /etc/letsencrypt/live/tagtag.your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/tagtag.your-domain.com/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:MozSSL:10m;
    ssl_session_tickets off;
    
    # TLS 配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # HSTS 配置
    add_header Strict-Transport-Security "max-age=63072000" always;
    
    # 其他配置...
}

# 强制 HTTPS 跳转
server {
    listen 80;
    server_name tagtag.your-domain.com;
    return 301 https://$server_name$request_uri;
}
```

## 4. 数据库优化

### 4.1 MySQL 配置优化

**核心配置项**：

```ini
# /etc/my.cnf

[mysqld]
# 基础配置
user = mysql
datadir = /var/lib/mysql
socket = /var/lib/mysql/mysql.sock
pid-file = /var/run/mysqld/mysqld.pid

# 字符集配置
character-set-server = utf8mb4
collation-server = utf8mb4_unicode_ci
init_connect = 'SET NAMES utf8mb4'

# 内存配置
innodb_buffer_pool_size = 20G  # 建议为服务器内存的 50%-70%
innodb_log_buffer_size = 128M
key_buffer_size = 256M
query_cache_size = 0
query_cache_type = 0

# 连接配置
max_connections = 2000
max_connect_errors = 10000
wait_timeout = 600
interactive_timeout = 600

# InnoDB 配置
innodb_file_per_table = 1
innodb_flush_log_at_trx_commit = 2  # 生产环境建议设置为 2
innodb_log_file_size = 2G
innodb_log_files_in_group = 2
innodb_io_capacity = 4000
innodb_io_capacity_max = 8000
innodb_doublewrite = 1
innodb_thread_concurrency = 0

# 日志配置
slow_query_log = 1
slow_query_log_file = /var/lib/mysql/slow.log
long_query_time = 2
log_queries_not_using_indexes = 0

# 其他配置
skip-name-resolve
lower_case_table_names = 1
```

### 4.2 索引优化

**索引设计原则**：

- 为经常查询的字段创建索引
- 为 JOIN 条件字段创建索引
- 为 ORDER BY 和 GROUP BY 字段创建索引
- 避免创建过多索引
- 使用复合索引时，将最常用的字段放在前面
- 定期优化表和重建索引

**示例**：

```sql
-- 创建复合索引
CREATE INDEX idx_user_name_email ON sys_user(username, email);

-- 重建索引
ALTER TABLE sys_user ENGINE=InnoDB;

-- 分析表
ANALYZE TABLE sys_user;
```

### 4.3 查询优化

**优化建议**：

- 使用 EXPLAIN 分析查询计划
- 避免 SELECT \*，只查询需要的字段
- 避免在 WHERE 子句中使用函数
- 避免在 WHERE 子句中对字段进行运算
- 使用 LIMIT 限制返回结果数量
- 合理使用 JOIN，避免笛卡尔积

**示例**：

```sql
-- 不好的查询
SELECT * FROM sys_user WHERE DATE(create_time) = '2023-01-01';

-- 优化后的查询
SELECT id, username, email FROM sys_user WHERE create_time BETWEEN '2023-01-01 00:00:00' AND '2023-01-01 23:59:59';
```

### 4.4 分库分表

当数据量达到一定规模时，建议考虑分库分表：

- **水平分表**：将同一张表的数据按照一定规则分散到多个表中
- **垂直分表**：将一张表的字段按照访问频率和大小分散到多个表中
- **分库**：将不同业务的数据分散到不同的数据库中

**分表策略**：

- 按时间分表（如按月份）
- 按 ID 分表（如哈希分表）
- 按业务字段分表（如按用户 ID）

## 5. Redis 优化

### 5.1 配置优化

**核心配置项**：

```ini
# /etc/redis.conf

# 基础配置
bind 0.0.0.0
protected-mode yes
port 6379
daemonize yes
pidfile /var/run/redis_6379.pid
logfile /var/log/redis/redis.log

# 内存配置
maxmemory 6G  # 建议为服务器内存的 50%-70%
maxmemory-policy allkeys-lru  # 内存不足时的淘汰策略

# 持久化配置
save 900 1
save 300 10
save 60 10000
dbfilename dump.rdb
dir /var/lib/redis
appendonly yes
appendfilename "appendonly.aof"
appendfsync everysec  # 生产环境建议设置为 everysec

# 连接配置
timeout 300
maxclients 10000

# 其他配置
tcp-keepalive 300
```

### 5.2 缓存优化

**优化建议**：

- 设置合理的缓存过期时间
- 避免缓存雪崩、缓存击穿和缓存穿透
- 使用缓存预热
- 定期清理过期缓存
- 合理使用 Redis 数据结构

**缓存雪崩解决方案**：

- 设置随机过期时间
- 使用 Redis 集群
- 实现缓存降级

**缓存穿透解决方案**：

- 使用布隆过滤器
- 缓存空值
- 限流和熔断

## 6. 安全配置

### 6.1 网络安全

- 使用防火墙限制访问端口
- 配置 VPN 或专线连接
- 使用 SSL/TLS 加密传输
- 定期进行安全扫描
- 配置入侵检测系统（IDS）

### 6.2 服务器安全

- 定期更新系统和软件包
- 使用强密码和密钥认证
- 禁用 root 远程登录
- 配置 sudo 权限
- 启用日志审计
- 定期备份服务器配置

### 6.3 应用安全

- 实现细粒度的权限控制
- 对敏感数据进行加密存储
- 防止 SQL 注入
- 防止 XSS 攻击
- 防止 CSRF 攻击
- 实现 API 限流和熔断
- 定期进行代码审计

### 6.4 数据安全

- 定期备份数据库
- 实现数据加密
- 配置访问控制列表（ACL）
- 数据脱敏处理
- 实现数据恢复机制
- 定期进行数据完整性检查

## 7. 监控与日志

### 7.1 监控系统

推荐使用 Prometheus + Grafana 搭建监控系统：

- **Prometheus**：收集监控数据
- **Grafana**：可视化监控数据
- **Node Exporter**：监控服务器指标
- **JMX Exporter**：监控 Java 应用
- **MySQL Exporter**：监控 MySQL 数据库
- **Redis Exporter**：监控 Redis

### 7.2 日志管理

- **ELK Stack**：Elasticsearch + Logstash + Kibana
- **Loki**：轻量级日志聚合系统
- **Filebeat**：日志采集器

**日志配置建议**：

- 统一日志格式
- 包含必要的上下文信息
- 实现日志分级
- 定期清理过期日志
- 配置日志告警

## 8. 备份与恢复

### 8.1 数据库备份

**全量备份**：

```bash
# 使用 mysqldump 进行全量备份
mysqldump -u root -p --all-databases --single-transaction --routines --triggers --events > /backup/mysql/full_backup_$(date +%Y%m%d_%H%M%S).sql

# 使用 xtrabackup 进行全量备份
xtrabackup --backup --target-dir=/backup/mysql/full_backup_$(date +%Y%m%d_%H%M%S)
```

**增量备份**：

```bash
# 使用 xtrabackup 进行增量备份
xtrabackup --backup --target-dir=/backup/mysql/incremental_$(date +%Y%m%d_%H%M%S) --incremental-basedir=/backup/mysql/full_backup_20230101_000000
```

**定时备份脚本**：

```bash
cat > /usr/local/bin/mysql_backup.sh << EOF
#!/bin/bash

BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d_%H%M%S)
FULL_BACKUP_DIR="$BACKUP_DIR/full_$DATE"

# 创建备份目录
mkdir -p $FULL_BACKUP_DIR

# 执行全量备份
mysqldump -u root -p"password" --all-databases --single-transaction --routines --triggers --events > $FULL_BACKUP_DIR/full_backup.sql

# 压缩备份文件
tar -czf $BACKUP_DIR/full_backup_$DATE.tar.gz -C $BACKUP_DIR full_$DATE

# 删除临时目录
rm -rf $FULL_BACKUP_DIR

# 删除 7 天前的备份
find $BACKUP_DIR -name "full_backup_*.tar.gz" -mtime +7 -delete
EOF

# 添加到定时任务
chmod +x /usr/local/bin/mysql_backup.sh
echo "0 2 * * * /usr/local/bin/mysql_backup.sh" >> /var/spool/cron/root
```

### 8.2 应用备份

**示例**：

```bash
# 备份应用配置和数据
BACKUP_DIR="/backup/app"
DATE=$(date +%Y%m%d_%H%M%S)
mkdir -p $BACKUP_DIR/$DATE

# 备份配置文件
cp -r /opt/tagtag/backend/config $BACKUP_DIR/$DATE/

# 备份日志（可选）
cp -r /opt/tagtag/backend/logs $BACKUP_DIR/$DATE/

# 备份静态资源
cp -r /usr/share/nginx/html/tagtag $BACKUP_DIR/$DATE/

# 压缩备份文件
tar -czf $BACKUP_DIR/app_backup_$DATE.tar.gz -C $BACKUP_DIR $DATE

# 删除临时目录
rm -rf $BACKUP_DIR/$DATE

# 删除 7 天前的备份
find $BACKUP_DIR -name "app_backup_*.tar.gz" -mtime +7 -delete
```

## 9. 性能测试

### 9.1 负载测试工具

- **JMeter**：功能强大的负载测试工具
- **Gatling**：基于 Scala 的高性能负载测试工具
- **k6**：现代化的负载测试工具
- **Apache Benchmark (ab)**：简单易用的 HTTP 负载测试工具

### 9.2 测试场景

- **并发测试**：测试系统在不同并发数下的性能
- **压力测试**：测试系统的极限性能
- **稳定性测试**：长时间运行测试，检查系统稳定性
- **容量测试**：测试系统的最大容量

**JMeter 测试示例**：

1. 创建测试计划
2. 添加线程组
3. 添加 HTTP 请求
4. 添加监听器（如聚合报告、图表结果）
5. 运行测试
6. 分析结果

## 10. 常见问题与解决方案

### 10.1 应用启动失败

**问题**：应用启动后立即退出

**解决方案**：

```bash
# 查看日志
cat /opt/tagtag/backend/logs/application.log

# 检查端口占用
netstat -tlnp | grep 8080

# 检查数据库连接
telnet mysql-server 3306

# 检查 Redis 连接
telnet redis-server 6379
```

### 10.2 数据库连接失败

**问题**：应用无法连接到数据库

**解决方案**：

```bash
# 检查数据库服务状态
systemctl status mysqld

# 检查数据库用户权限
mysql -u root -p -e "SHOW GRANTS FOR 'tagtag'@'%';"

# 检查防火墙设置
firewall-cmd --list-ports

# 检查 SELinux 设置
getenforce
```

### 10.3 前端页面无法访问

**问题**：访问前端页面显示 404 或空白页

**解决方案**：

```bash
# 检查 Nginx 配置
nginx -t

# 检查 Nginx 日志
cat /var/log/nginx/tagtag.error.log

# 检查静态文件权限
ls -la /usr/share/nginx/html/tagtag/

# 检查前端路由配置
# 确保 Nginx 配置了 try_files $uri $uri/ /index.html;
```

## 11. 总结

生产环境部署是一个复杂的过程，需要考虑服务器配置、应用部署、数据库优化、安全配置、监控日志和备份恢复等多个方面。本文档提供了 Tagtag Starter 项目在生产环境部署的详细指南，希望能帮助您顺利完成部署工作。

在实际部署过程中，建议根据您的业务需求和服务器资源情况，灵活调整配置参数，确保系统的高性能、高可用性和高安全性。


# 容器化部署

容器化是现代应用部署的趋势，Tagtag Starter 项目支持 Docker 和 Kubernetes 部署，本文档将详细介绍容器化部署的方案和最佳实践。

## 1. 容器化概述

### 1.1 为什么选择容器化

- **一致性**：容器确保应用在不同环境中运行一致
- **轻量级**：容器比虚拟机更轻量，启动更快
- **可移植性**：容器可以在任何支持 Docker 的环境中运行
- **可扩展性**：容器易于横向扩展，支持自动化运维
- **资源隔离**：容器提供了良好的资源隔离机制
- **版本控制**：容器镜像支持版本控制，便于回滚和管理

### 1.2 技术栈

| 技术             | 用途               |
| -------------- | ---------------- |
| Docker         | 容器运行时和镜像构建       |
| Docker Compose | 本地开发和测试环境部署      |
| Kubernetes     | 生产环境容器编排         |
| Helm           | Kubernetes 应用包管理 |
| GitHub Actions | CI/CD 自动化部署      |
| Harbor         | 私有 Docker 镜像仓库   |

## 2. Docker 部署

### 2.1 Dockerfile 编写

#### 2.1.1 后端 Dockerfile

```dockerfile
# 使用 Java 17 作为基础镜像
FROM openjdk:17-jdk-slim as builder

# 设置工作目录
WORKDIR /app

# 复制 Maven 配置文件
COPY pom.xml .
COPY .mvn .mvn

# 下载依赖
RUN ./mvnw dependency:go-offline

# 复制源代码
COPY src src

# 构建项目
RUN ./mvnw package -DskipTests

# 使用轻量级基础镜像
FROM openjdk:17-jdk-slim

# 设置工作目录
WORKDIR /app

# 从构建阶段复制 JAR 文件
COPY --from=builder /app/target/tagtag-backend.jar .

# 设置环境变量
ENV JAVA_OPTS="-Xmx8g -Xms4g"
ENV SPRING_PROFILES_ACTIVE=prod

# 暴露端口
EXPOSE 8080

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar tagtag-backend.jar"]
```

#### 2.1.2 前端 Dockerfile

```dockerfile
# 使用 Node.js 18 作为基础镜像
FROM node:18-alpine as builder

# 设置工作目录
WORKDIR /app

# 复制 package.json 和 pnpm-lock.yaml
COPY package.json pnpm-lock.yaml ./

# 安装 pnpm
RUN npm install -g pnpm

# 安装依赖
RUN pnpm install

# 复制源代码
COPY . .

# 构建生产版本
RUN pnpm build

# 使用 Nginx 作为基础镜像
FROM nginx:alpine

# 复制构建好的静态文件到 Nginx 目录
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制 Nginx 配置文件
COPY nginx.conf /etc/nginx/conf.d/default.conf

# 暴露端口
EXPOSE 80

# 启动 Nginx
ENTRYPOINT ["nginx", "-g", "daemon off;"]
```

#### 2.1.3 Nginx 配置

```nginx
server {
    listen 80;
    server_name localhost;
    
    location / {
        root /usr/share/nginx/html;
        index index.html;
        try_files $uri $uri/ /index.html;
    }
    
    location /api {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

### 2.2 Docker Compose 配置

```yaml
version: '3.8'

networks:
  tagtag-network:
    driver: bridge

volumes:
  mysql-data:
  redis-data:
  logs:

services:
  # MySQL 数据库
  mysql:
    image: mysql:8.0
    container_name: tagtag-mysql
    restart: always
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=tagtag
      - MYSQL_CHARSET=utf8mb4
      - MYSQL_COLLATION=utf8mb4_unicode_ci
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./mysql/conf:/etc/mysql/conf.d
      - ./mysql/init:/docker-entrypoint-initdb.d
    networks:
      - tagtag-network
    command: --default-authentication-plugin=mysql_native_password

  # Redis 缓存
  redis:
    image: redis:7.0-alpine
    container_name: tagtag-redis
    restart: always
    environment:
      - REDIS_PASSWORD=password
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - tagtag-network
    command: redis-server --requirepass password --appendonly yes

  # 后端应用
  backend:
    build:
      context: ../backend
      dockerfile: Dockerfile
    container_name: tagtag-backend
    restart: always
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/tagtag?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
      - SPRING_DATASOURCE_USERNAME=root
      - SPRING_DATASOURCE_PASSWORD=password
      - SPRING_REDIS_HOST=redis
      - SPRING_REDIS_PORT=6379
      - SPRING_REDIS_PASSWORD=password
      - JWT_SECRET=your-secret-key
    ports:
      - "8080:8080"
    volumes:
      - logs:/app/logs
    networks:
      - tagtag-network
    depends_on:
      - mysql
      - redis

  # 前端应用
  frontend:
    build:
      context: ../frontend
      dockerfile: Dockerfile
    container_name: tagtag-frontend
    restart: always
    ports:
      - "80:80"
    networks:
      - tagtag-network
    depends_on:
      - backend

  # 可选：phpMyAdmin（用于管理数据库）
  phpmyadmin:
    image: phpmyadmin/phpmyadmin
    container_name: tagtag-phpmyadmin
    restart: always
    environment:
      - PMA_HOST=mysql
      - PMA_PORT=3306
      - MYSQL_ROOT_PASSWORD=password
    ports:
      - "8081:80"
    networks:
      - tagtag-network
    depends_on:
      - mysql

  # 可选：Redis Commander（用于管理 Redis）
  redis-commander:
    image: rediscommander/redis-commander:latest
    container_name: tagtag-redis-commander
    restart: always
    environment:
      - REDIS_HOSTS=local:redis:6379:0:password
    ports:
      - "8082:8081"
    networks:
      - tagtag-network
    depends_on:
      - redis
```

### 2.3 构建和运行

**命令示例**：

```bash
# 进入 Docker Compose 目录
cd docker

# 构建所有服务
docker-compose build

# 运行所有服务
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down

# 停止服务并删除数据卷
docker-compose down -v

# 仅构建特定服务
docker-compose build frontend

# 仅运行特定服务
docker-compose up -d backend mysql redis
```

## 3. Kubernetes 部署

### 3.1 Kubernetes 集群搭建

#### 3.1.1 本地开发环境

**使用 Minikube**：

```bash
# 安装 Minikube
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# 启动 Minikube
minikube start --cpus 4 --memory 8g --disk-size 40g

# 安装 kubectl
sudo apt-get update && sudo apt-get install -y kubectl

# 验证集群
kubectl cluster-info
kubectl get nodes
```

**使用 Kind**：

```bash
# 安装 Kind
go install sigs.k8s.io/kind@v0.20.0

# 创建集群配置
cat > kind-config.yaml << EOF
kind: Cluster
apiVersion: kind.x-k8s.io/v1alpha4
nodes:
- role: control-plane
  extraPortMappings:
  - containerPort: 30080
    hostPort: 80
    protocol: TCP
  - containerPort: 30443
    hostPort: 443
    protocol: TCP
EOF

# 创建集群
kind create cluster --config kind-config.yaml

# 验证集群
kubectl cluster-info
kubectl get nodes
```

#### 3.1.2 生产环境

- **云厂商托管集群**：推荐使用 AWS EKS、Azure AKS、Google GKE 或阿里云 ACK
- **自建集群**：使用 kubeadm 或 Rancher 搭建

### 3.2 Kubernetes 资源配置

#### 3.2.1 命名空间

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: tagtag
  labels:
    name: tagtag
```

#### 3.2.2 配置文件（ConfigMap）

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: tagtag-config
  namespace: tagtag
data:
  application-prod.yaml: |
    server:
      port: 8080
      servlet:
        context-path: /api
    spring:
      datasource:
        url: jdbc:mysql://mysql.tagtag:3306/tagtag?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai
        username: root
        password: ${MYSQL_PASSWORD}
      redis:
        host: redis.tagtag
        port: 6379
        password: ${REDIS_PASSWORD}
    jwt:
      secret: ${JWT_SECRET}
      expiration: 3600
```

#### 3.2.3 密钥（Secret）

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: tagtag-secrets
  namespace: tagtag
type: Opaque
stringData:
  mysql-password: password
  redis-password: password
  jwt-secret: your-secret-key
```

#### 3.2.4 MySQL 部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: tagtag
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: mysql-password
        - name: MYSQL_DATABASE
          value: tagtag
        ports:
        - containerPort: 3306
        volumeMounts:
        - name: mysql-data
          mountPath: /var/lib/mysql
        - name: mysql-conf
          mountPath: /etc/mysql/conf.d
      volumes:
      - name: mysql-data
        persistentVolumeClaim:
          claimName: mysql-pvc
      - name: mysql-conf
        configMap:
          name: mysql-config
---
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: tagtag
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
    targetPort: 3306
  clusterIP: None  # 使用 Headless Service
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pvc
  namespace: tagtag
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

#### 3.2.5 Redis 部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: tagtag
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
  template:
    metadata:
      labels:
        app: redis
    spec:
      containers:
      - name: redis
        image: redis:7.0-alpine
        env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: redis-password
        ports:
        - containerPort: 6379
        volumeMounts:
        - name: redis-data
          mountPath: /data
        command:
        - redis-server
        - --requirepass
        - $(REDIS_PASSWORD)
        - --appendonly
        - "yes"
      volumes:
      - name: redis-data
        persistentVolumeClaim:
          claimName: redis-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: tagtag
spec:
  selector:
    app: redis
  ports:
  - port: 6379
    targetPort: 6379
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-pvc
  namespace: tagtag
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

#### 3.2.6 后端应用部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: tagtag
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: tagtag/backend:latest
        env:
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: mysql-password
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: redis-password
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: tagtag-secrets
              key: jwt-secret
        ports:
        - containerPort: 8080
        livenessProbe:
          httpGet:
            path: /api/actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /api/actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        resources:
          requests:
            memory: "4Gi"
            cpu: "2"
          limits:
            memory: "8Gi"
            cpu: "4"
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: config
          mountPath: /app/config
      volumes:
      - name: logs
        emptyDir: {}
      - name: config
        configMap:
          name: tagtag-config
---
apiVersion: v1
kind: Service
metadata:
  name: backend
  namespace: tagtag
spec:
  selector:
    app: backend
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
```

#### 3.2.7 前端应用部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: tagtag
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: frontend
        image: tagtag/frontend:latest
        ports:
        - containerPort: 80
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: tagtag
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
  type: ClusterIP
```

#### 3.2.8 Ingress 配置

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tagtag-ingress
  namespace: tagtag
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"
spec:
  ingressClassName: nginx
  rules:
  - host: tagtag.your-domain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend
            port:
              number: 80
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: backend
            port:
              number: 8080
```

### 3.3 Helm Chart 配置

#### 3.3.1 Chart 目录结构

```text
tagtag-chart/
├── Chart.yaml          # Chart 元数据
├── values.yaml         # 默认配置值
├── templates/          # 模板文件
│   ├── _helpers.tpl    # 辅助函数
│   ├── configmap.yaml  # ConfigMap 模板
│   ├── secret.yaml     # Secret 模板
│   ├── mysql/          # MySQL 相关模板
│   ├── redis/          # Redis 相关模板
│   ├── backend/        # 后端应用模板
│   ├── frontend/       # 前端应用模板
│   └── ingress.yaml    # Ingress 模板
└── charts/             # 依赖 Chart
```

#### 3.3.2 Chart.yaml

```yaml
apiVersion: v2
name: tagtag
description: A Helm chart for Tagtag Starter application
type: application
version: 1.0.0
appVersion: "1.0.0"
dependencies:
  - name: mysql
    version: "8.8.2"
    repository: "https://charts.bitnami.com/bitnami"
    condition: mysql.enabled
  - name: redis
    version: "17.10.2"
    repository: "https://charts.bitnami.com/bitnami"
    condition: redis.enabled
```

#### 3.3.3 values.yaml

```yaml
# 全局配置
global:
  namespace: tagtag
  imageRegistry: ""

# 前端配置
frontend:
  replicaCount: 3
  image:
    repository: tagtag/frontend
    tag: latest
    pullPolicy: IfNotPresent
  resources:
    requests:
      memory: "512Mi"
      cpu: "250m"
    limits:
      memory: "1Gi"
      cpu: "500m"

# 后端配置
backend:
  replicaCount: 3
  image:
    repository: tagtag/backend
    tag: latest
    pullPolicy: IfNotPresent
  resources:
    requests:
      memory: "4Gi"
      cpu: "2"
    limits:
      memory: "8Gi"
      cpu: "4"

# MySQL 配置
mysql:
  enabled: true
  auth:
    rootPassword: password
    database: tagtag
  primary:
    persistence:
      size: 20Gi

# Redis 配置
redis:
  enabled: true
  auth:
    password: password
  master:
    persistence:
      size: 10Gi

# Ingress 配置
ingress:
  enabled: true
  className: nginx
  hosts:
    - host: tagtag.your-domain.com
      paths:
        - path: /
          pathType: Prefix
        - path: /api
          pathType: Prefix
```

#### 3.3.4 使用 Helm 部署

```bash
# 安装 Helm
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

# 添加 Helm 仓库
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# 安装 Chart
helm install tagtag ./tagtag-chart -n tagtag --create-namespace

# 更新 Chart
helm upgrade tagtag ./tagtag-chart -n tagtag

# 卸载 Chart
helm uninstall tagtag -n tagtag

# 查看已安装的 Chart
helm list -n tagtag

# 查看 Chart 状态
helm status tagtag -n tagtag

# 查看 Pod 状态
kubectl get pods -n tagtag

# 查看日志
kubectl logs -f <pod-name> -n tagtag
```

### 3.4 CI/CD 集成

#### 3.4.1 GitHub Actions 配置

```yaml
name: CI/CD

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  # 构建后端
  build-backend:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn -B package -DskipTests --file backend/pom.xml
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}
    
    - name: Build and push backend image
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-backend:${{ github.sha }},${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-backend:latest

  # 构建前端
  build-frontend:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js 18
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'pnpm'
    
    - name: Install pnpm
      run: npm install -g pnpm
    
    - name: Install dependencies
      run: pnpm install
      working-directory: ./frontend
    
    - name: Build frontend
      run: pnpm build
      working-directory: ./frontend
    
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-frontend:${{ github.sha }},${{ secrets.DOCKER_HUB_USERNAME }}/tagtag-frontend:latest

  # 部署到 Kubernetes
  deploy:
    needs: [ build-backend, build-frontend ]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.25.0'
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Update kubeconfig
      run: aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }}
    
    - name: Deploy to Kubernetes
      run: |
        # 更新 Helm Chart 中的镜像版本
        sed -i 's|tag: latest|tag: ${{ github.sha }}|g' ./helm/values.yaml
        
        # 部署应用
        helm upgrade --install tagtag ./helm -n tagtag --create-namespace
    
    - name: Verify deployment
      run: |
        kubectl wait --for=condition=available deployment/backend -n tagtag --timeout=300s
        kubectl wait --for=condition=available deployment/frontend -n tagtag --timeout=300s
        kubectl get pods -n tagtag
```

## 4. 最佳实践

### 4.1 Docker 最佳实践

- **使用轻量级基础镜像**：如 alpine 或 slim 版本
- **最小化镜像层数**：合并 RUN 指令，使用多阶段构建
- **使用 .dockerignore 文件**：排除不必要的文件和目录
- **非 root 用户运行容器**：提高安全性
- **设置合理的健康检查**：使用 HEALTHCHECK 指令
- **合理设置资源限制**：避免容器占用过多资源
- **使用标签管理镜像**：包括版本号、提交哈希等
- **避免在容器中存储数据**：使用 volumes 或外部存储

### 4.2 Kubernetes 最佳实践

- **使用命名空间**：按环境或团队划分资源
- **合理设置资源请求和限制**：确保集群稳定性
- **使用健康检查和就绪探针**：提高应用可用性
- **使用滚动更新**：确保零 downtime 部署
- **使用 StatefulSet 部署有状态应用**：如数据库
- **使用 ConfigMap 和 Secret 管理配置**：避免硬编码
- **使用 Horizontal Pod Autoscaler**：自动扩缩容
- **使用 NetworkPolicy 限制网络访问**：提高安全性
- **定期备份数据**：使用 CronJob 或外部工具
- **监控和日志收集**：使用 Prometheus 和 ELK Stack

### 4.3 CI/CD 最佳实践

- **自动化测试**：在构建前运行单元测试和集成测试
- **代码质量检查**：使用 ESLint、SonarQube 等工具
- **镜像安全扫描**：使用 Trivy 或 Clair 扫描镜像漏洞
- **多环境部署**：开发、测试、预发布、生产环境
- **手动审批**：生产环境部署需要手动审批
- **回滚机制**：支持快速回滚到之前的版本
- **监控部署状态**：实时监控部署进度和状态
- **日志收集**：收集 CI/CD 流程的日志

## 5. 常见问题与解决方案

### 5.1 Docker 相关问题

#### 5.1.1 镜像构建失败

**问题**：构建镜像时出现依赖安装失败

**解决方案**：

- 检查网络连接
- 检查 Dockerfile 中的依赖源
- 使用国内镜像源加速依赖下载
- 清理缓存后重新构建

#### 5.1.2 容器启动失败

**问题**：容器启动后立即退出

**解决方案**：

- 查看容器日志：`docker logs <container-name>`
- 检查环境变量配置
- 检查端口占用情况
- 检查挂载的卷和配置文件

### 5.2 Kubernetes 相关问题

#### 5.2.1 Pod 处于 Pending 状态

**问题**：Pod 一直处于 Pending 状态

**解决方案**：

- 检查集群资源是否充足
- 检查 PersistentVolumeClaim 是否绑定成功
- 检查 NodeSelector 和 Toleration 配置
- 查看事件：`kubectl describe pod <pod-name> -n <namespace>`

#### 5.2.2 Pod 处于 CrashLoopBackOff 状态

**问题**：Pod 反复重启

**解决方案**：

- 查看容器日志：`kubectl logs <pod-name> -n <namespace>`
- 检查应用配置
- 检查健康检查配置
- 检查资源限制是否合理

#### 5.2.3 Ingress 无法访问

**问题**：通过 Ingress 无法访问应用

**解决方案**：

- 检查 Ingress Controller 是否正常运行
- 检查 Ingress 规则配置
- 检查 Service 是否正常
- 检查 Pod 是否正常运行
- 查看 Ingress 日志

## 6. 总结

容器化部署是现代应用部署的趋势，Tagtag Starter 项目支持 Docker 和 Kubernetes 部署，提供了灵活的部署方案。通过 Docker Compose 可以快速搭建本地开发和测试环境，通过 Kubernetes 和 Helm 可以实现生产环境的自动化部署和管理。

本文档详细介绍了 Tagtag Starter 项目的容器化部署方案，包括 Dockerfile 编写、Docker Compose 配置、Kubernetes 资源配置、Helm Chart 配置和 CI/CD 集成。遵循本文档的最佳实践，可以提高应用的可用性、可扩展性和安全性。

在实际部署过程中，建议根据业务需求和集群规模，灵活调整配置参数，确保系统的高性能和可靠性。


# 监控与维护

监控与维护是确保系统稳定运行的重要环节，本文档将详细介绍 Tagtag Starter 项目的监控系统、日志管理、性能优化和系统维护方案。

## 1. 监控系统架构

### 1.1 监控目标

- **可用性监控**：确保系统服务正常运行
- **性能监控**：监控系统性能指标，如 CPU、内存、磁盘、网络等
- **业务监控**：监控核心业务指标，如用户访问量、接口响应时间、错误率等
- **安全监控**：监控系统安全事件，如入侵尝试、异常登录等

### 1.2 技术栈

| 技术             | 用途           |
| -------------- | ------------ |
| Prometheus     | 时间序列数据采集和存储  |
| Grafana        | 监控数据可视化      |
| Node Exporter  | 服务器指标监控      |
| JMX Exporter   | Java 应用性能监控  |
| MySQL Exporter | MySQL 数据库监控  |
| Redis Exporter | Redis 缓存监控   |
| Loki           | 日志聚合和查询      |
| Promtail       | 日志采集         |
| Alertmanager   | 告警管理         |
| ELK Stack      | 日志分析和可视化（可选） |
| Jaeger         | 分布式链路追踪      |

### 1.3 监控架构图

```text
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  应用服务       │     │  数据库服务     │     │  缓存服务       │
│  (Spring Boot)  │     │  (MySQL)        │     │  (Redis)        │
└──────┬──────────┘     └──────┬──────────┘     └──────┬──────────┘
       │                       │                       │
       ▼                       ▼                       ▼
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│  JMX Exporter   │     │ MySQL Exporter  │     │ Redis Exporter  │
└──────┬──────────┘     └──────┬──────────┘     └──────┬──────────┘
       │                       │                       │
       └───────────┬───────────┴───────────┬───────────┘
                   │                       │
                   ▼                       ▼
┌─────────────────────────────────────────────────────────┐
│                       Prometheus                        │
└───────────────────┬─────────────────────────────────────┘
                   │
                   ├─────────────────────────────┐
                   ▼                             ▼
┌─────────────────────────┐     ┌─────────────────────────┐
│       Alertmanager      │     │        Grafana          │
└─────────────────────────┘     └─────────────────────────┘
```

## 2. 日志管理

### 2.1 日志类型

- **应用日志**：应用程序运行时产生的日志，包括业务日志、错误日志等
- **系统日志**：操作系统产生的日志，如 CPU、内存、磁盘等系统指标
- **访问日志**：Web 服务器产生的访问日志，记录 HTTP 请求和响应
- **数据库日志**：数据库产生的日志，如慢查询日志、错误日志等

### 2.2 日志格式

#### 2.2.1 应用日志格式

采用 JSON 格式记录应用日志，便于日志收集和分析：

```json
{
  "timestamp": "2023-01-01T12:00:00.123Z",
  "level": "INFO",
  "thread": "http-nio-8080-exec-1",
  "logger": "com.tagtag.controller.UserController",
  "message": "用户登录成功",
  "traceId": "1234567890abcdef",
  "spanId": "abcdef1234567890",
  "userId": 1,
  "ip": "192.168.1.100",
  "method": "POST",
  "path": "/api/auth/login",
  "status": 200,
  "duration": 123
}
```

#### 2.2.2 访问日志格式

Nginx 访问日志格式：

```text
log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for" '
                '$request_time $upstream_response_time';
```

### 2.3 日志收集

#### 2.3.1 使用 Loki + Promtail

**Promtail 配置**：

```yaml
server:
  http_listen_port: 9080
  grpc_listen_port: 0

positions:
  filename: /tmp/positions.yaml

clients:
  - url: http://loki:3100/loki/api/v1/push

scrape_configs:
  - job_name: system
    static_configs:
    - targets:
        - localhost
      labels:
        job: varlogs
        __path__: /var/log/*log

  - job_name: nginx
    static_configs:
    - targets:
        - localhost
      labels:
        job: nginx
        __path__: /var/log/nginx/*.log

  - job_name: application
    static_configs:
    - targets:
        - localhost
      labels:
        job: application
        __path__: /opt/tagtag/logs/*.log
```

#### 2.3.2 使用 ELK Stack

**Filebeat 配置**：

```yaml
filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /opt/tagtag/logs/*.log
  fields:
    application: tagtag
  fields_under_root: true

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  index: "tagtag-%{+yyyy.MM.dd}"

setup.ilm.enabled: true
setup.ilm.rollover_alias: "tagtag"
setup.ilm.pattern: "000001"
```

### 2.4 日志查询

#### 2.4.1 使用 Grafana + Loki

Grafana 支持通过 Loki 数据源查询日志，支持以下查询语法：

```text
# 查询所有日志
{job="application"}

# 按日志级别查询
{job="application"} |= "ERROR"

# 按时间范围查询
{job="application"} |= "ERROR" | __time > 1609459200000ms and __time < 1609545600000ms

# 按字段查询
{job="application"} | json | level="ERROR" and status=500
```

#### 2.4.2 使用 Kibana

Kibana 提供了强大的日志查询和可视化功能，支持以下查询语法：

```text
# 查询所有日志
application:tagtag

# 按日志级别查询
application:tagtag AND level:ERROR

# 按时间范围查询
application:tagtag AND @timestamp:[2023-01-01T00:00:00.000Z TO 2023-01-02T00:00:00.000Z]

# 按字段查询
application:tagtag AND level:ERROR AND status:500
```

### 2.5 日志轮换

**Logback 配置**：

```xml
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>/opt/tagtag/logs/tagtag.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <!-- 每天生成一个日志文件，保留30天 -->
            <fileNamePattern>/opt/tagtag/logs/tagtag.%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>
            <!-- 每个日志文件最大100MB -->
            <maxFileSize>100MB</maxFileSize>
            <!-- 保留30天 -->
            <maxHistory>30</maxHistory>
            <!-- 总大小限制10GB -->
            <totalSizeCap>10GB</totalSizeCap>
        </rollingPolicy>
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout class="net.logstash.logback.layout.LogstashLayout">
                <jsonGeneratorDecorator class="net.logstash.logback.decorate.ContextJsonGeneratorDecorator" />
            </layout>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="FILE" />
    </root>
</configuration>
```

## 3. 性能监控

### 3.1 服务器监控

#### 3.1.1 核心指标

- **CPU 使用率**：监控 CPU 使用率，阈值建议 80%
- **内存使用率**：监控内存使用率，阈值建议 85%
- **磁盘使用率**：监控磁盘使用率，阈值建议 90%
- **磁盘 I/O**：监控磁盘读写速率和 IOPS
- **网络流量**：监控网络流入流出速率
- **负载平均值**：监控系统负载，建议不超过 CPU 核心数

#### 3.1.2 监控配置

**Node Exporter 安装**：

```bash
# 下载 Node Exporter
wget https://github.com/prometheus/node_exporter/releases/download/v1.6.0/node_exporter-1.6.0.linux-amd64.tar.gz

# 解压安装
tar xvfz node_exporter-1.6.0.linux-amd64.tar.gz
mv node_exporter-1.6.0.linux-amd64/node_exporter /usr/local/bin/

# 创建系统服务
cat > /etc/systemd/system/node_exporter.service << EOF
[Unit]
Description=Node Exporter
After=network.target

[Service]
User=root
ExecStart=/usr/local/bin/node_exporter
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 启动服务
systemctl daemon-reload
systemctl start node_exporter
systemctl enable node_exporter
```

**Prometheus 配置**：

```yaml
global:
  scrape_interval:     15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'node'
    static_configs:
    - targets: ['localhost:9100']
```

### 3.2 Java 应用监控

#### 3.2.1 核心指标

- **JVM 内存使用**：堆内存、非堆内存使用率
- **垃圾回收**：GC 次数、GC 耗时
- **线程状态**：活跃线程数、阻塞线程数、死锁线程数
- **类加载**：已加载类数量
- **Tomcat 连接数**：当前连接数、最大连接数
- **接口响应时间**：平均响应时间、P95/P99 响应时间
- **错误率**：接口错误率

#### 3.2.2 监控配置

**JMX Exporter 配置**：

1. 下载 JMX Exporter JAR 文件
2. 创建配置文件 `jmx_exporter.yaml`
3. 修改应用启动脚本，添加 JMX Exporter 参数

**配置文件示例**：

```yaml
startDelaySeconds: 0
ssl: false
lowercaseOutputName: false
lowercaseOutputLabelNames: false
rules:
  - pattern: "java.lang<type=Memory><HeapMemoryUsage>(.+)":
      name: jvm_memory_heap_usage_$1
      type: GAUGE
  - pattern: "java.lang<type=Memory><NonHeapMemoryUsage>(.+)":
      name: jvm_memory_nonheap_usage_$1
      type: GAUGE
  - pattern: "java.lang<type=GarbageCollector,name=(.+)><(.+)>(.+)":
      name: jvm_gc_$2_$3
      labels:
        gc: $1
      type: GAUGE
  - pattern: "java.lang<type=Threading><(.+)>":
      name: jvm_threading_$1
      type: GAUGE
```

**启动脚本修改**：

```bash
java -javaagent:jmx_prometheus_javaagent-0.19.0.jar=9404:jmx_exporter.yaml -jar tagtag-backend.jar
```

### 3.3 数据库监控

#### 3.3.1 核心指标

- **连接数**：当前连接数、最大连接数
- **查询性能**：QPS、慢查询数
- **缓存命中率**：查询缓存命中率
- **InnoDB 指标**：缓冲池命中率、日志写入速率
- **复制状态**：主从复制延迟

#### 3.3.2 监控配置

**MySQL Exporter 安装**：

```bash
# 下载 MySQL Exporter
wget https://github.com/prometheus/mysqld_exporter/releases/download/v0.15.0/mysqld_exporter-0.15.0.linux-amd64.tar.gz

# 解压安装
tar xvfz mysqld_exporter-0.15.0.linux-amd64.tar.gz
mv mysqld_exporter-0.15.0.linux-amd64/mysqld_exporter /usr/local/bin/

# 创建 MySQL 用户
mysql -u root -p -e "CREATE USER 'exporter'@'localhost' IDENTIFIED BY 'password' WITH MAX_USER_CONNECTIONS 3;"
mysql -u root -p -e "GRANT PROCESS, REPLICATION CLIENT, SELECT ON *.* TO 'exporter'@'localhost';"

# 创建配置文件
cat > /etc/.mysqld_exporter.cnf << EOF
[client]
user=exporter
password=password
EOF

# 创建系统服务
cat > /etc/systemd/system/mysqld_exporter.service << EOF
[Unit]
Description=MySQL Exporter
After=network.target

[Service]
User=root
Environment="DATA_SOURCE_NAME=exporter:password@(localhost:3306)/"
ExecStart=/usr/local/bin/mysqld_exporter --config.my-cnf=/etc/.mysqld_exporter.cnf
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 启动服务
systemctl daemon-reload
systemctl start mysqld_exporter
systemctl enable mysqld_exporter
```

### 3.4 缓存监控

#### 3.4.1 核心指标

- **内存使用率**：Redis 内存使用率
- **命中率**：键命中率
- **连接数**：当前连接数、最大连接数
- **命令执行**：命令执行速率
- **过期键**：过期键数量
- **网络流量**：网络流入流出速率

#### 3.4.2 监控配置

**Redis Exporter 安装**：

```bash
# 下载 Redis Exporter
wget https://github.com/oliver006/redis_exporter/releases/download/v1.53.0/redis_exporter-v1.53.0.linux-amd64.tar.gz

# 解压安装
tar xvfz redis_exporter-v1.53.0.linux-amd64.tar.gz
mv redis_exporter-v1.53.0.linux-amd64/redis_exporter /usr/local/bin/

# 创建系统服务
cat > /etc/systemd/system/redis_exporter.service << EOF
[Unit]
Description=Redis Exporter
After=network.target

[Service]
User=root
ExecStart=/usr/local/bin/redis_exporter --redis.addr redis://localhost:6379 --redis.password password
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 启动服务
systemctl daemon-reload
systemctl start redis_exporter
systemctl enable redis_exporter
```

## 4. 告警配置

### 4.1 告警规则

#### 4.1.1 服务器告警

```yaml
groups:
- name: node-alerts
  rules:
  - alert: HighCpuUsage
    expr: 100 - (avg by(instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100 > 80
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High CPU usage on {{ $labels.instance }}"
      description: "CPU usage is {{ $value }}% for 5 minutes"
  
  - alert: HighMemoryUsage
    expr: 100 - ((node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes) * 100) > 85
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High memory usage on {{ $labels.instance }}"
      description: "Memory usage is {{ $value }}% for 5 minutes"
  
  - alert: HighDiskUsage
    expr: 100 - ((node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"}) * 100) > 90
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High disk usage on {{ $labels.instance }}"
      description: "Disk usage is {{ $value }}% for 5 minutes"
```

#### 4.1.2 应用告警

```yaml
groups:
- name: application-alerts
  rules:
  - alert: HighErrorRate
    expr: sum(rate(http_server_requests_seconds_count{status=~"5.."}[5m])) / sum(rate(http_server_requests_seconds_count[5m])) > 0.05
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High error rate on {{ $labels.instance }}"
      description: "Error rate is {{ $value }}% for 5 minutes"
  
  - alert: SlowResponseTime
    expr: histogram_quantile(0.95, sum(rate(http_server_requests_seconds_bucket[5m])) by (le, endpoint)) > 2
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Slow response time on {{ $labels.endpoint }}"
      description: "95th percentile response time is {{ $value }}s for 5 minutes"
  
  - alert: HighJvmMemoryUsage
    expr: sum(jvm_memory_used_bytes{area="heap"}) / sum(jvm_memory_max_bytes{area="heap"}) > 0.85
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "High JVM memory usage on {{ $labels.instance }}"
      description: "JVM heap memory usage is {{ $value }}% for 5 minutes"
```

### 4.2 告警渠道

- **邮件告警**：发送告警邮件
- **短信告警**：发送告警短信
- **即时通讯**：通过 Slack、DingTalk、WeChat 发送告警
- **电话告警**：严重告警时进行电话通知
- **PagerDuty**：专业告警管理平台

### 4.3 Alertmanager 配置

```yaml
global:
  resolve_timeout: 5m
  smtp_smarthost: 'smtp.example.com:587'
  smtp_from: 'alertmanager@example.com'
  smtp_auth_username: 'alertmanager@example.com'
  smtp_auth_password: 'password'
  smtp_require_tls: true

route:
  group_by: ['alertname', 'cluster', 'service']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 4h
  receiver: 'email'
  routes:
  - match:
      severity: critical
    receiver: 'sms'

receivers:
- name: 'email'
  email_configs:
  - to: 'admin@example.com'
    send_resolved: true

- name: 'sms'
  webhook_configs:
  - url: 'https://sms-gateway.example.com/send'
    send_resolved: true
```

## 5. 分布式链路追踪

### 5.1 Jaeger 安装

```bash
# 启动 Jaeger 容器
docker run -d --name jaeger \
  -e COLLECTOR_ZIPKIN_HOST_PORT=:9411 \
  -p 5775:5775/udp \
  -p 6831:6831/udp \
  -p 6832:6832/udp \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 14268:14268 \
  -p 14250:14250 \
  -p 9411:9411 \
  jaegertracing/all-in-one:1.48
```

### 5.2 Spring Boot 集成

**添加依赖**：

```xml
<dependency>
    <groupId>io.opentracing.contrib</groupId>
    <artifactId>opentracing-spring-jaeger-cloud-starter</artifactId>
    <version>3.3.1</version>
</dependency>
```

**配置文件**：

```yaml
opentracing:
  jaeger:
    enabled: true
    udp-sender:
      host: jaeger
      port: 6831
    log-spans: true
    service-name: tagtag-backend
```

### 5.3 查看链路追踪

访问 Jaeger UI：`http://localhost:16686`，可以查看：

- 服务拓扑图
- 调用链路详情
- 每个节点的响应时间
- 错误链路追踪

## 6. 系统维护

### 6.1 定期维护任务

| 任务    | 频率  | 负责人    | 描述            |
| ----- | --- | ------ | ------------- |
| 系统更新  | 每月  | 运维工程师  | 更新系统和软件包      |
| 数据库备份 | 每日  | 数据库管理员 | 备份数据库，保留 30 天 |
| 日志清理  | 每周  | 运维工程师  | 清理过期日志        |
| 性能优化  | 每月  | 运维工程师  | 分析系统性能，进行优化   |
| 安全审计  | 每月  | 安全工程师  | 进行安全扫描和审计     |
| 备份验证  | 每月  | 运维工程师  | 验证备份的完整性和可恢复性 |
| 容量规划  | 每季度 | 架构师    | 评估系统容量，进行扩容规划 |

### 6.2 系统备份

#### 6.2.1 数据库备份

**全量备份**：

```bash
# 使用 mysqldump 备份
mysqldump -u root -p --all-databases --single-transaction --routines --triggers > /backup/mysql/full_backup_$(date +%Y%m%d_%H%M%S).sql

# 使用 xtrabackup 备份
xtrabackup --backup --target-dir=/backup/mysql/full_backup_$(date +%Y%m%d_%H%M%S)
```

**增量备份**：

```bash
xtrabackup --backup --target-dir=/backup/mysql/incremental_$(date +%Y%m%d_%H%M%S) --incremental-basedir=/backup/mysql/full_backup_20230101_000000
```

#### 6.2.2 应用备份

```bash
# 备份应用配置和数据
BACKUP_DIR="/backup/app"
DATE=$(date +%Y%m%d_%H%M%S)
mkdir -p $BACKUP_DIR/$DATE

# 备份配置文件
cp -r /opt/tagtag/backend/config $BACKUP_DIR/$DATE/

# 备份日志（可选）
cp -r /opt/tagtag/backend/logs $BACKUP_DIR/$DATE/

# 备份静态资源
cp -r /usr/share/nginx/html/tagtag $BACKUP_DIR/$DATE/

# 压缩备份文件
tar -czf $BACKUP_DIR/app_backup_$DATE.tar.gz -C $BACKUP_DIR $DATE

# 删除临时目录
rm -rf $BACKUP_DIR/$DATE

# 删除 7 天前的备份
find $BACKUP_DIR -name "app_backup_*.tar.gz" -mtime +7 -delete
```

### 6.3 故障排查

#### 6.3.1 常见故障

**应用无法启动**：

- 查看应用日志：`tail -f /opt/tagtag/logs/tagtag.log`
- 检查端口占用：`netstat -tlnp | grep 8080`
- 检查数据库连接：`mysql -u root -p -h localhost`
- 检查 Redis 连接：`redis-cli -h localhost -p 6379 -a password ping`

**接口响应缓慢**：

- 查看应用日志，检查慢查询
- 使用 Prometheus 查看性能指标
- 使用 Jaeger 查看分布式链路
- 检查数据库慢查询日志

**数据库连接失败**：

- 检查数据库服务状态：`systemctl status mysqld`
- 检查数据库连接数：`show processlist;`
- 检查数据库日志：`tail -f /var/log/mysql/error.log`

#### 6.3.2 故障恢复

**数据库恢复**：

```bash
# 使用 mysqldump 恢复
mysql -u root -p < /backup/mysql/full_backup_20230101_000000.sql

# 使用 xtrabackup 恢复
xtrabackup --prepare --target-dir=/backup/mysql/full_backup_20230101_000000
xtrabackup --copy-back --target-dir=/backup/mysql/full_backup_20230101_000000
chown -R mysql:mysql /var/lib/mysql
```

**应用恢复**：

```bash
# 停止当前应用
systemctl stop tagtag-backend

# 恢复备份
cp -r /backup/app/app_backup_20230101_000000/config /opt/tagtag/backend/

# 启动应用
systemctl start tagtag-backend
```

## 7. 最佳实践

### 7.1 监控最佳实践

- **建立监控基线**：确定正常的性能指标范围
- **设置合理阈值**：根据业务需求设置告警阈值
- **分级告警**：根据告警严重程度进行分级
- **告警收敛**：避免告警风暴
- **定期review告警**：定期检查告警规则，优化告警策略
- **自动化处理**：对于常见告警，实现自动化处理

### 7.2 日志管理最佳实践

- **统一日志格式**：使用 JSON 格式，便于日志收集和分析
- **添加上下文信息**：如 traceId、spanId、userId 等
- **合理设置日志级别**：避免过多的 DEBUG 日志
- **定期清理日志**：避免日志占用过多磁盘空间
- **日志脱敏**：对敏感信息进行脱敏处理
- **日志备份**：重要日志进行异地备份

### 7.3 性能优化最佳实践

- **优化数据库查询**：添加索引，优化 SQL 语句
- **使用缓存**：合理使用 Redis 缓存热点数据
- **异步处理**：将耗时操作异步化
- **代码优化**：优化算法和数据结构
- **垂直拆分**：将大表拆分为小表
- **水平扩展**：增加服务器节点，实现负载均衡

### 7.4 安全最佳实践

- **定期安全扫描**：使用工具进行安全扫描
- **及时更新补丁**：修复已知漏洞
- **使用 HTTPS**：加密数据传输
- **设置防火墙**：限制访问端口
- **启用审计日志**：记录重要操作
- **定期安全培训**：提高团队安全意识

## 8. 总结

监控与维护是确保系统稳定运行的重要环节，通过建立完善的监控体系、日志管理机制、性能优化策略和系统维护流程，可以有效提高系统的可用性、可靠性和安全性。

本文档详细介绍了 Tagtag Starter 项目的监控系统架构、日志管理、性能监控、告警配置、分布式链路追踪和系统维护方案，希望能帮助您建立和完善系统的监控与维护体系。

在实际运营过程中，建议根据业务需求和系统特点，灵活调整监控策略和维护流程，持续优化系统性能和可靠性。
